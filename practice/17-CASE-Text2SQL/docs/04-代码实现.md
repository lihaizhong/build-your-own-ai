# Text2SQL智能查询系统 - 代码实现详解

## 核心代码结构

### 项目文件概览

```
code/
├── __init__.py              # 模块初始化，导出主要类和示例
├── text2sql_vanna.py        # 核心Text2SQL实现
├── cli.py                   # 交互式命令行界面
└── prepare_data.py          # 数据库和示例数据准备
```

## 核心模块实现

### text2sql_vanna.py

核心Text2SQL实现，提供自然语言转SQL的完整流程。

#### BaseVanna抽象基类

```python
"""
Text2SQL核心模块
基于Few-shot学习的自然语言转SQL系统
"""

from abc import ABC, abstractmethod
from typing import Any, Optional
import sqlite3
import os
from pathlib import Path

from openai import OpenAI
from dotenv import load_dotenv
from loguru import logger


class BaseVanna(ABC):
    """Vanna基类抽象，定义核心接口"""
    
    @abstractmethod
    def train(self, *args, **kwargs):
        """添加训练数据"""
        pass
    
    @abstractmethod
    def generate_sql(self, question: str) -> str:
        """根据问题生成SQL语句"""
        pass
    
    @abstractmethod
    def run_sql(self, sql: str) -> Any:
        """执行SQL查询"""
        pass
```

#### SimpleVanna类核心实现

```python
class SimpleVanna(BaseVanna):
    """
    简化版Vanna实现
    不依赖vanna库，直接使用OpenAI兼容API
    """
    
    def __init__(self, llm_provider: str = "dashscope", model: Optional[str] = None):
        """
        初始化Text2SQL系统
        
        Args:
            llm_provider: LLM提供商 (dashscope/openai/ollama)
            model: 指定模型名称
        """
        # 加载环境变量
        load_dotenv()
        
        # 初始化各组件
        self._init_llm_client(llm_provider, model)
        self._init_db_connection()
        self._load_training_data()
        
        # 构建系统提示词
        self.system_prompt = self._build_system_prompt()
        
        logger.info(f"SimpleVanna初始化完成 (provider: {llm_provider})")
```

#### LLM客户端初始化

```python
def _init_llm_client(self, provider: str, model: Optional[str] = None):
    """
    初始化LLM客户端，支持多种提供商
    
    Args:
        provider: LLM提供商
        model: 可选的模型名称
    """
    if provider == "dashscope":
        api_key = os.environ.get("DASHSCOPE_API_KEY")
        if not api_key:
            raise ValueError("DASHSCOPE_API_KEY环境变量未设置")
        
        self.client = OpenAI(
            api_key=api_key,
            base_url="https://dashscope.aliyuncs.com/compatible-mode/v1"
        )
        self.model = model or "qwen-turbo"
        
    elif provider == "openai":
        api_key = os.environ.get("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY环境变量未设置")
        
        self.client = OpenAI(api_key=api_key)
        self.model = model or "gpt-4o-mini"
        
    elif provider == "ollama":
        self.client = OpenAI(
            base_url="http://localhost:11434/v1",
            api_key="ollama"  # Ollama不需要API Key
        )
        self.model = model or "deepseek-r1:7b"
        
    else:
        raise ValueError(f"不支持的LLM提供商: {provider}")
    
    logger.info(f"LLM客户端初始化完成 (model: {self.model})")
```

#### 数据库连接管理

```python
def _init_db_connection(self):
    """初始化SQLite数据库连接"""
    db_path = get_project_path("data", "heros.db")
    
    if not db_path.exists():
        logger.warning(f"数据库文件不存在: {db_path}")
        logger.info("请先运行 python code/prepare_data.py 创建数据库")
        self.conn = None
        self.schema_info = ""
        return
    
    self.conn = sqlite3.connect(str(db_path))
    self.conn.row_factory = sqlite3.Row  # 返回字典格式
    
    # 加载表结构信息
    self.schema_info = self._load_schema_info()
    
    logger.info(f"数据库连接成功: {db_path}")

def _load_schema_info(self) -> str:
    """加载表结构信息"""
    cursor = self.conn.cursor()
    
    # 获取所有表名
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
    tables = cursor.fetchall()
    
    schema_parts = []
    for (table_name,) in tables:
        # 获取表结构
        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = cursor.fetchall()
        
        # 格式化列信息
        column_defs = []
        for col in columns:
            col_name = col[1]
            col_type = col[2]
            column_defs.append(f"{col_name} {col_type}")
        
        schema_parts.append(f"{table_name}({', '.join(column_defs)})")
    
    return "\n".join(schema_parts)
```

#### 训练数据管理

```python
def _load_training_data(self):
    """加载预置的训练数据"""
    self.training_data = [
        {
            "question": "查询所有英雄的名称和定位",
            "sql": "SELECT hero_name, role FROM heros"
        },
        {
            "question": "查询所有战士类英雄",
            "sql": "SELECT * FROM heros WHERE role = '战士'"
        },
        {
            "question": "查询生命值最高的前5个英雄",
            "sql": "SELECT hero_name, health FROM heros ORDER BY health DESC LIMIT 5"
        },
        {
            "question": "统计各个定位的英雄数量",
            "sql": "SELECT role, COUNT(*) as count FROM heros GROUP BY role"
        },
        {
            "question": "查询所有周免英雄",
            "sql": "SELECT hero_name FROM heros WHERE is_free = 1"
        },
        {
            "question": "查询价格在8888金币以上的英雄",
            "sql": "SELECT hero_name, price FROM heros WHERE price > 8888"
        },
        {
            "question": "查询平均生命值最高的定位",
            "sql": "SELECT role, AVG(health) as avg_health FROM heros GROUP BY role ORDER BY avg_health DESC LIMIT 1"
        },
        {
            "question": "查询攻击力最低的3个英雄",
            "sql": "SELECT hero_name, attack_damage FROM heros ORDER BY attack_damage ASC LIMIT 3"
        },
        {
            "question": "查询所有法师类英雄的名称和价格",
            "sql": "SELECT hero_name, price FROM heros WHERE role = '法师'"
        },
        {
            "question": "查询来自长城守卫军的英雄",
            "sql": "SELECT hero_name FROM heros WHERE region = '长城守卫军'"
        },
        {
            "question": "查询所有周免英雄的技能信息",
            "sql": "SELECT h.hero_name, s.skill_name, s.skill_type FROM heros h JOIN hero_skills s ON h.hero_id = s.hero_id WHERE h.is_free = 1"
        },
        {
            "question": "查询胜率最高的英雄",
            "sql": "SELECT h.hero_name, COUNT(*) as total, SUM(CASE WHEN m.win = 1 THEN 1 ELSE 0 END) as wins FROM heros h JOIN match_records m ON h.hero_id = m.hero_id GROUP BY h.hero_id ORDER BY wins*1.0/total DESC LIMIT 1"
        }
    ]
    
    logger.info(f"已加载 {len(self.training_data)} 条训练数据")
```

## Few-shot提示词构建

### 1. 系统提示词模板

```python
def _build_system_prompt(self) -> str:
    """构建系统提示词"""
    return f"""你是一个专业的SQL生成助手。你的任务是根据用户的问题，生成正确的SQL查询语句。

规则：
1. 只返回SQL语句，不要有任何其他文字说明
2. SQL语句必须符合SQLite语法
3. 表名和字段名要使用正确的名称
4. 字符串值使用单引号包围
5. 不要使用Markdown代码块格式
6. 不要添加分号结尾

可用的表：
{self.schema_info}

示例数据：
- heros表包含王者荣耀英雄信息
- hero_skills表包含英雄技能信息
- match_records表包含比赛记录"""
```

### 2. 相似问题查找

```python
def _find_similar_questions(self, question: str, top_k: int = 3) -> list:
    """
    查找相似问题作为Few-shot示例
    
    Args:
        question: 用户问题
        top_k: 返回的示例数量
        
    Returns:
        相似问题列表
    """
    # 简单的关键词匹配相似度计算
    question_keywords = set(question.lower().split())
    
    # 移除常见停用词
    stop_words = {"的", "查询", "所有", "请", "帮我", "一下"}
    question_keywords -= stop_words
    
    similarities = []
    for data in self.training_data:
        train_keywords = set(data["question"].lower().split()) - stop_words
        
        # 计算关键词交集
        intersection = question_keywords & train_keywords
        
        # Jaccard相似度
        if question_keywords or train_keywords:
            union = question_keywords | train_keywords
            similarity = len(intersection) / len(union) if union else 0
        else:
            similarity = 0
        
        similarities.append((similarity, data))
    
    # 排序并返回top_k个
    similarities.sort(reverse=True, key=lambda x: x[0])
    return [item[1] for item in similarities[:top_k]]
```

### 3. 完整提示词构建

```python
def _build_prompt(self, question: str) -> str:
    """
    构建Few-shot提示词
    
    Args:
        question: 用户问题
        
    Returns:
        完整的提示词
    """
    # 查找相似问题
    similar_examples = self._find_similar_questions(question)
    
    # 构建提示词各部分
    prompt_parts = []
    
    # 添加Few-shot示例
    for i, example in enumerate(similar_examples, 1):
        prompt_parts.append(f"示例{i}:")
        prompt_parts.append(f"问题: {example['question']}")
        prompt_parts.append(f"SQL: {example['sql']}")
        prompt_parts.append("")
    
    # 添加当前问题
    prompt_parts.append("现在请生成以下问题的SQL:")
    prompt_parts.append(f"问题: {question}")
    prompt_parts.append("SQL:")
    
    return "\n".join(prompt_parts)
```

## SQL生成与执行

### 1. LLM调用

```python
def _call_llm(self, prompt: str) -> str:
    """
    调用LLM生成响应
    
    Args:
        prompt: 提示词
        
    Returns:
        LLM生成的响应
    """
    try:
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": self.system_prompt},
                {"role": "user", "content": prompt}
            ],
            temperature=0.1,  # 低温度确保SQL生成稳定性
            max_tokens=1000
        )
        
        return response.choices[0].message.content or ""
        
    except Exception as e:
        logger.error(f"LLM调用失败: {e}")
        return ""
```

### 2. SQL清理

```python
def _clean_sql(self, sql: str) -> str:
    """
    清理SQL语句
    
    Args:
        sql: 原始SQL字符串
        
    Returns:
        清理后的SQL
    """
    # 移除Markdown代码块标记
    sql = sql.replace("```sql", "").replace("```", "")
    
    # 移除多余空白
    sql = sql.strip()
    
    # 移除结尾分号
    if sql.endswith(";"):
        sql = sql[:-1]
    
    return sql
```

### 3. SQL生成方法

```python
def generate_sql(self, question: str) -> str:
    """
    根据问题生成SQL语句
    
    Args:
        question: 自然语言问题
        
    Returns:
        生成的SQL语句
    """
    logger.info(f"生成SQL: {question}")
    
    # 构建提示词
    prompt = self._build_prompt(question)
    
    # 调用LLM
    response = self._call_llm(prompt)
    
    # 清理SQL
    sql = self._clean_sql(response)
    
    logger.info(f"生成结果: {sql}")
    return sql
```

### 4. SQL执行方法

```python
def run_sql(self, sql: str) -> list:
    """
    执行SQL查询
    
    Args:
        sql: SQL语句
        
    Returns:
        查询结果列表
    """
    if not self.conn:
        logger.error("数据库未连接")
        return []
    
    try:
        cursor = self.conn.cursor()
        cursor.execute(sql)
        
        # 获取列名
        columns = [description[0] for description in cursor.description]
        
        # 转换为字典列表
        results = [dict(zip(columns, row)) for row in cursor.fetchall()]
        
        logger.info(f"查询成功，返回 {len(results)} 条记录")
        return results
        
    except sqlite3.Error as e:
        logger.error(f"SQL执行失败: {e}")
        return []
```

### 5. 完整问答流程

```python
def ask(self, question: str) -> dict:
    """
    完整的问答流程
    
    Args:
        question: 自然语言问题
        
    Returns:
        包含问题、SQL、结果的字典
    """
    result = {
        "question": question,
        "sql": "",
        "results": [],
        "error": None
    }
    
    try:
        # 生成SQL
        sql = self.generate_sql(question)
        result["sql"] = sql
        
        # 执行查询
        results = self.run_sql(sql)
        result["results"] = results
        
    except Exception as e:
        result["error"] = str(e)
        logger.error(f"问答处理失败: {e}")
    
    return result
```

### 6. 训练数据添加

```python
def train(self, question: str, sql: str):
    """
    添加训练数据
    
    Args:
        question: 问题
        sql: 对应的SQL语句
    """
    self.training_data.append({
        "question": question,
        "sql": sql
    })
    logger.info(f"已添加训练数据: {question}")
```

## CLI交互界面实现

### cli.py

交互式命令行界面，提供用户友好的交互体验。

#### Text2SQLCLI类

```python
"""
Text2SQL交互式命令行界面
"""

from rich.console import Console
from rich.table import Table
from rich.syntax import Syntax
from rich.panel import Panel
from loguru import logger

from .text2sql_vanna import create_vanna


class Text2SQLCLI:
    """Text2SQL交互式命令行界面"""
    
    COMMANDS = {
        "history": "查看历史查询记录",
        "train": "添加自定义训练数据",
        "schema": "查看数据库表结构",
        "help": "显示帮助信息",
        "quit": "退出程序",
        "exit": "退出程序"
    }
    
    def __init__(self, llm_provider: str = "dashscope"):
        """初始化CLI"""
        self.vanna = create_vanna(llm_provider=llm_provider)
        self.console = Console()
        self.history = []
```

#### 启动方法

```python
def start(self):
    """启动交互式界面"""
    self._print_welcome()
    
    while True:
        try:
            user_input = input("\n请输入问题或命令: ").strip()
            
            if not user_input:
                continue
            
            # 处理命令
            if user_input.lower() in self.COMMANDS:
                self._handle_command(user_input.lower())
            else:
                # 处理问题
                self._handle_question(user_input)
                
        except KeyboardInterrupt:
            print("\n\n感谢使用，再见！")
            break
        except EOFError:
            break
```

#### 结果展示

```python
def _display_results(self, sql: str, results: list):
    """
    美化展示查询结果
    
    Args:
        sql: 生成的SQL语句
        results: 查询结果
    """
    # 展示SQL
    syntax = Syntax(sql, "sql", theme="monokai", line_numbers=False)
    self.console.print("\n[bold green]生成的SQL:[/bold green]")
    self.console.print(syntax)
    
    # 展示结果
    if results:
        self.console.print(f"\n[bold blue]查询结果 ({len(results)} 条记录):[/bold blue]")
        
        # 创建表格
        table = Table(show_header=True, header_style="bold magenta")
        
        # 添加列
        for key in results[0].keys():
            table.add_column(str(key))
        
        # 添加行
        for row in results:
            table.add_row(*[str(v) if v is not None else "" for v in row.values()])
        
        self.console.print(table)
    else:
        self.console.print("\n[yellow]查询结果为空[/yellow]")
```

## 数据准备模块

### prepare_data.py

数据库和示例数据准备脚本。

#### 创建数据库

```python
def create_heros_database():
    """创建SQLite数据库和表结构"""
    db_path = get_project_path("data", "heros.db")
    
    # 确保目录存在
    db_path.parent.mkdir(parents=True, exist_ok=True)
    
    conn = sqlite3.connect(str(db_path))
    cursor = conn.cursor()
    
    # 创建heros表
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS heros (
        hero_id INTEGER PRIMARY KEY AUTOINCREMENT,
        hero_name TEXT NOT NULL,
        role TEXT NOT NULL,
        health INTEGER DEFAULT 0,
        attack_damage INTEGER DEFAULT 0,
        is_free BOOLEAN DEFAULT 0,
        price INTEGER DEFAULT 0,
        region TEXT
    )
    """)
    
    # 创建hero_skills表
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS hero_skills (
        skill_id INTEGER PRIMARY KEY AUTOINCREMENT,
        hero_id INTEGER NOT NULL,
        skill_name TEXT NOT NULL,
        skill_type TEXT,
        cooldown REAL DEFAULT 0,
        damage_type TEXT,
        FOREIGN KEY (hero_id) REFERENCES heros(hero_id)
    )
    """)
    
    # 创建match_records表
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS match_records (
        match_id INTEGER PRIMARY KEY AUTOINCREMENT,
        hero_id INTEGER NOT NULL,
        kill_count INTEGER DEFAULT 0,
        death_count INTEGER DEFAULT 0,
        assist_count INTEGER DEFAULT 0,
        win BOOLEAN DEFAULT 0,
        match_date TEXT,
        FOREIGN KEY (hero_id) REFERENCES heros(hero_id)
    )
    """)
    
    conn.commit()
    logger.info(f"数据库创建成功: {db_path}")
    return conn
```

#### 插入英雄数据

```python
def insert_hero_data(conn):
    """插入王者荣耀英雄数据"""
    cursor = conn.cursor()
    
    heros = [
        # 战士
        ("亚瑟", "战士", 3500, 170, 1, 0, "勇士之地"),
        ("吕布", "战士", 3800, 190, 0, 18888, "乱世"),
        ("典韦", "战士", 3600, 180, 0, 13888, "魏地"),
        ("关羽", "战士", 3550, 175, 0, 18888, "蜀国"),
        ("老夫子", "战士", 3450, 165, 0, 8888, "稷下"),
        
        # 法师
        ("妲己", "法师", 2800, 150, 1, 0, "朝歌"),
        ("安琪拉", "法师", 2750, 145, 1, 0, "魔法森林"),
        ("王昭君", "法师", 2850, 155, 0, 8888, "北夷"),
        ("貂蝉", "法师", 2900, 160, 0, 18888, "乱世"),
        ("小乔", "法师", 2700, 140, 0, 5888, "吴国"),
        
        # ... 更多英雄数据
    ]
    
    cursor.executemany(
        "INSERT INTO heros (hero_name, role, health, attack_damage, is_free, price, region) VALUES (?, ?, ?, ?, ?, ?, ?)",
        heros
    )
    
    conn.commit()
    logger.info(f"已插入 {len(heros)} 条英雄数据")
```

## 错误处理和调试

### 1. 日志记录

```python
from loguru import logger
import sys

# 配置日志
logger.remove()
logger.add(
    sys.stdout,
    format="<green>{time:HH:mm:ss}</green> | <level>{level: <8}</level> | <level>{message}</level>",
    level="INFO"
)
logger.add(
    "logs/text2sql.log",
    rotation="1 day",
    retention="7 days",
    level="DEBUG"
)
```

### 2. 异常处理

```python
def generate_sql(self, question: str) -> str:
    try:
        prompt = self._build_prompt(question)
        response = self._call_llm(prompt)
        return self._clean_sql(response)
    except Exception as e:
        logger.error(f"SQL生成失败: {e}")
        return ""
```

---

*最后更新: 2026年2月15日*
*文档版本: v1.0*
*维护团队: build-your-own-ai项目团队*
