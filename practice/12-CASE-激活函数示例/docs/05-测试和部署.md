# 激活函数示例项目 - 测试和部署

## 测试策略

### 1. 单元测试

#### 激活函数测试

```python
import unittest
import numpy as np
from code.activation_optimized_final import sigmoid, tanh_func, relu


class TestActivationFunctions(unittest.TestCase):
    """激活函数单元测试"""
    
    def test_sigmoid_basic(self):
        """测试Sigmoid基本功能"""
        # 测试零点
        self.assertAlmostEqual(sigmoid(0), 0.5, places=6)
        
        # 测试正值
        self.assertTrue(0.5 < sigmoid(1) < 1)
        self.assertTrue(0.5 < sigmoid(10) < 1)
        
        # 测试负值
        self.assertTrue(0 < sigmoid(-1) < 0.5)
        self.assertTrue(0 < sigmoid(-10) < 0.5)
    
    def test_sigmoid_range(self):
        """测试Sigmoid输出范围"""
        x = np.linspace(-100, 100, 1000)
        y = sigmoid(x)
        
        # 输出应在(0, 1)范围内
        self.assertTrue(np.all(y > 0))
        self.assertTrue(np.all(y < 1))
    
    def test_sigmoid_symmetry(self):
        """测试Sigmoid对称性"""
        # σ(-x) = 1 - σ(x)
        x = np.array([0.5, 1.0, 2.0, 5.0])
        self.assertTrue(np.allclose(sigmoid(-x), 1 - sigmoid(x)))
    
    def test_tanh_basic(self):
        """测试Tanh基本功能"""
        # 测试零点
        self.assertAlmostEqual(tanh_func(0), 0.0, places=6)
        
        # 测试正值
        self.assertTrue(0 < tanh_func(1) < 1)
        
        # 测试负值
        self.assertTrue(-1 < tanh_func(-1) < 0)
    
    def test_tanh_range(self):
        """测试Tanh输出范围"""
        x = np.linspace(-100, 100, 1000)
        y = tanh_func(x)
        
        # 输出应在(-1, 1)范围内
        self.assertTrue(np.all(y > -1))
        self.assertTrue(np.all(y < 1))
    
    def test_tanh_symmetry(self):
        """测试Tanh奇函数性质"""
        # tanh(-x) = -tanh(x)
        x = np.array([0.5, 1.0, 2.0, 5.0])
        self.assertTrue(np.allclose(tanh_func(-x), -tanh_func(x)))
    
    def test_relu_basic(self):
        """测试ReLU基本功能"""
        # 测试正值
        self.assertEqual(relu(5), 5)
        self.assertEqual(relu(0.5), 0.5)
        
        # 测试负值
        self.assertEqual(relu(-5), 0)
        self.assertEqual(relu(-0.5), 0)
        
        # 测试零点
        self.assertEqual(relu(0), 0)
    
    def test_relu_range(self):
        """测试ReLU输出范围"""
        x = np.linspace(-100, 100, 1000)
        y = relu(x)
        
        # 输出应非负
        self.assertTrue(np.all(y >= 0))
    
    def test_vectorized_operations(self):
        """测试向量化操作"""
        x = np.array([-2, -1, 0, 1, 2])
        
        # Sigmoid
        sigmoid_y = sigmoid(x)
        self.assertEqual(len(sigmoid_y), 5)
        self.assertTrue(np.all(sigmoid_y > 0) and np.all(sigmoid_y < 1))
        
        # Tanh
        tanh_y = tanh_func(x)
        self.assertEqual(len(tanh_y), 5)
        self.assertTrue(np.all(tanh_y > -1) and np.all(tanh_y < 1))
        
        # ReLU
        relu_y = relu(x)
        self.assertEqual(len(relu_y), 5)
        self.assertTrue(np.all(relu_y >= 0))


class TestActivationDerivatives(unittest.TestCase):
    """激活函数导数测试"""
    
    def test_sigmoid_derivative(self):
        """测试Sigmoid导数"""
        from code.activation_derivatives import sigmoid_derivative
        
        # 在x=0处导数应为0.25
        self.assertAlmostEqual(sigmoid_derivative(0), 0.25, places=6)
        
        # 导数应始终在(0, 0.25]范围内
        x = np.linspace(-10, 10, 1000)
        deriv = sigmoid_derivative(x)
        self.assertTrue(np.all(deriv > 0))
        self.assertTrue(np.all(deriv <= 0.25))
    
    def test_tanh_derivative(self):
        """测试Tanh导数"""
        from code.activation_derivatives import tanh_derivative
        
        # 在x=0处导数应为1
        self.assertAlmostEqual(tanh_derivative(0), 1.0, places=6)
        
        # 导数应始终在(0, 1]范围内
        x = np.linspace(-10, 10, 1000)
        deriv = tanh_derivative(x)
        self.assertTrue(np.all(deriv >= 0))
        self.assertTrue(np.all(deriv <= 1))
    
    def test_relu_derivative(self):
        """测试ReLU导数"""
        from code.activation_derivatives import relu_derivative
        
        # 正值导数为1
        self.assertEqual(relu_derivative(1), 1)
        self.assertEqual(relu_derivative(100), 1)
        
        # 负值导数为0
        self.assertEqual(relu_derivative(-1), 0)
        self.assertEqual(relu_derivative(-100), 0)
        
        # 零点导数（本实现为0）
        self.assertEqual(relu_derivative(0), 0)
    
    def test_numerical_derivative_verification(self):
        """数值导数验证"""
        from code.activation_derivatives import sigmoid_derivative, tanh_derivative, relu_derivative
        
        # 数值导数计算函数
        def numerical_derivative(func, x, h=1e-5):
            return (func(x + h) - func(x - h)) / (2 * h)
        
        test_points = [-2, -1, -0.5, 0, 0.5, 1, 2]
        
        # 验证Sigmoid导数
        for x in test_points:
            analytical = sigmoid_derivative(x)
            numerical = numerical_derivative(sigmoid, x)
            self.assertAlmostEqual(analytical, numerical, places=4,
                                 msg=f"Sigmoid derivative mismatch at x={x}")
        
        # 验证Tanh导数
        for x in test_points:
            analytical = tanh_derivative(x)
            numerical = numerical_derivative(tanh_func, x)
            self.assertAlmostEqual(analytical, numerical, places=4,
                                 msg=f"Tanh derivative mismatch at x={x}")


class TestEdgeCases(unittest.TestCase):
    """边界情况测试"""
    
    def test_extreme_values(self):
        """测试极端值"""
        # 大正数
        self.assertAlmostEqual(sigmoid(1000), 1.0, places=6)
        self.assertAlmostEqual(tanh_func(1000), 1.0, places=6)
        self.assertEqual(relu(1000), 1000)
        
        # 大负数
        self.assertAlmostEqual(sigmoid(-1000), 0.0, places=6)
        self.assertAlmostEqual(tanh_func(-1000), -1.0, places=6)
        self.assertEqual(relu(-1000), 0)
    
    def test_special_values(self):
        """测试特殊值"""
        # 零
        self.assertAlmostEqual(sigmoid(0), 0.5)
        self.assertAlmostEqual(tanh_func(0), 0.0)
        self.assertEqual(relu(0), 0)
        
        # 无穷大
        self.assertEqual(sigmoid(np.inf), 1.0)
        self.assertEqual(sigmoid(-np.inf), 0.0)
        self.assertEqual(tanh_func(np.inf), 1.0)
        self.assertEqual(tanh_func(-np.inf), -1.0)
    
    def test_array_operations(self):
        """测试数组操作"""
        # 空数组
        empty = np.array([])
        self.assertEqual(len(sigmoid(empty)), 0)
        self.assertEqual(len(tanh_func(empty)), 0)
        self.assertEqual(len(relu(empty)), 0)
        
        # 单元素数组
        single = np.array([1.0])
        self.assertEqual(len(sigmoid(single)), 1)
        self.assertEqual(len(tanh_func(single)), 1)
        self.assertEqual(len(relu(single)), 1)


if __name__ == '__main__':
    # 运行所有测试
    unittest.main(verbosity=2)
```

### 2. 集成测试

```python
import pytest
import tempfile
import os
import numpy as np


class TestVisualizationIntegration:
    """可视化集成测试"""
    
    @pytest.fixture
    def temp_output_dir(self):
        """创建临时输出目录"""
        with tempfile.TemporaryDirectory() as temp_dir:
            yield temp_dir
    
    def test_activation_plot_generation(self, temp_output_dir):
        """测试激活函数图生成"""
        import matplotlib.pyplot as plt
        
        # 生成测试数据
        x = np.linspace(-5, 5, 1000)
        
        # 绘制图形
        plt.figure(figsize=(10, 6))
        plt.plot(x, sigmoid(x), label='Sigmoid')
        plt.plot(x, tanh_func(x), label='Tanh')
        plt.plot(x, relu(x), label='ReLU')
        plt.legend()
        
        # 保存图像
        output_path = os.path.join(temp_output_dir, 'test_plot.png')
        plt.savefig(output_path)
        plt.close()
        
        # 验证文件创建
        self.assertTrue(os.path.exists(output_path))
        self.assertGreater(os.path.getsize(output_path), 0)
    
    def test_derivative_plot_generation(self, temp_output_dir):
        """测试导数图生成"""
        import matplotlib.pyplot as plt
        from code.activation_derivatives import sigmoid_derivative, tanh_derivative, relu_derivative
        
        # 生成测试数据
        x = np.linspace(-5, 5, 1000)
        
        # 绘制图形
        plt.figure(figsize=(10, 6))
        plt.plot(x, sigmoid_derivative(x), label='Sigmoid Derivative')
        plt.plot(x, tanh_derivative(x), label='Tanh Derivative')
        plt.plot(x, relu_derivative(x), label='ReLU Derivative')
        plt.legend()
        
        # 保存图像
        output_path = os.path.join(temp_output_dir, 'test_derivative_plot.png')
        plt.savefig(output_path)
        plt.close()
        
        # 验证文件创建
        self.assertTrue(os.path.exists(output_path))
```

### 3. 性能测试

```python
import time
import numpy as np


class TestPerformance:
    """性能测试"""
    
    def test_computation_speed(self):
        """测试计算速度"""
        # 生成大规模数据
        x = np.random.randn(1000000)  # 100万个数据点
        
        # Sigmoid性能测试
        start = time.time()
        y_sigmoid = sigmoid(x)
        sigmoid_time = time.time() - start
        
        # Tanh性能测试
        start = time.time()
        y_tanh = tanh_func(x)
        tanh_time = time.time() - start
        
        # ReLU性能测试
        start = time.time()
        y_relu = relu(x)
        relu_time = time.time() - start
        
        print(f"\n性能测试结果 (100万数据点):")
        print(f"  Sigmoid: {sigmoid_time:.4f}秒")
        print(f"  Tanh: {tanh_time:.4f}秒")
        print(f"  ReLU: {relu_time:.4f}秒")
        
        # 性能断言：ReLU应该最快
        self.assertLess(relu_time, sigmoid_time)
        self.assertLess(relu_time, tanh_time)
    
    def test_memory_usage(self):
        """测试内存使用"""
        import sys
        
        # 测试不同规模数据的内存使用
        sizes = [1000, 10000, 100000, 1000000]
        
        for size in sizes:
            x = np.random.randn(size)
            y = sigmoid(x)
            
            memory_mb = sys.getsizeof(y) / (1024 * 1024)
            print(f"数据规模 {size}: 内存使用 {memory_mb:.2f} MB")
            
            # 清理
            del x, y
    
    def test_derivative_computation_speed(self):
        """测试导数计算速度"""
        from code.activation_derivatives import sigmoid_derivative, tanh_derivative, relu_derivative
        
        x = np.random.randn(1000000)
        
        # Sigmoid导数性能
        start = time.time()
        sigmoid_deriv = sigmoid_derivative(x)
        sigmoid_deriv_time = time.time() - start
        
        # Tanh导数性能
        start = time.time()
        tanh_deriv = tanh_derivative(x)
        tanh_deriv_time = time.time() - start
        
        # ReLU导数性能
        start = time.time()
        relu_deriv = relu_derivative(x)
        relu_deriv_time = time.time() - start
        
        print(f"\n导数计算性能测试 (100万数据点):")
        print(f"  Sigmoid导数: {sigmoid_deriv_time:.4f}秒")
        print(f"  Tanh导数: {tanh_deriv_time:.4f}秒")
        print(f"  ReLU导数: {relu_deriv_time:.4f}秒")
```

## 部署策略

### 1. 开发环境部署

#### 依赖管理

```toml
# pyproject.toml
[project]
name = "activation-functions-demo"
version = "1.0.0"
description = "激活函数可视化与分析示例项目"
requires-python = ">=3.11"
dependencies = [
    "numpy>=1.24.0",
    "matplotlib>=3.7.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "basedpyright>=0.1.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

#### 本地开发环境

```bash
# 克隆项目
git clone <repository-url>
cd 12-CASE-激活函数示例

# 创建虚拟环境
uv venv --python 3.11
source .venv/bin/activate

# 安装依赖
uv sync

# 运行测试
uv run pytest

# 运行代码检查
uv run basedpyright code/
```

### 2. Docker容器化部署

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    libfreetype6-dev \
    libpng-dev \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY pyproject.toml .
RUN pip install --no-cache-dir numpy matplotlib

# 复制应用代码
COPY code/ ./code/

# 创建输出目录
RUN mkdir -p user_data

# 设置环境变量
ENV PYTHONUNBUFFERED=1

# 默认命令
CMD ["python", "code/activation_optimized_final.py"]
```

#### Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  activation-demo:
    build: .
    container_name: activation-functions-demo
    volumes:
      - ./user_data:/app/user_data
    environment:
      - PYTHONUNBUFFERED=1
```

### 3. CI/CD流水线

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.11', '3.12']
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install numpy matplotlib pytest
    
    - name: Run tests
      run: |
        pytest tests/ -v --tb=short
    
    - name: Type check
      run: |
        pip install basedpyright
        basedpyright code/

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: |
        docker build -t activation-demo:${{ github.sha }} .
    
    - name: Test Docker image
      run: |
        docker run --rm activation-demo:${{ github.sha }} python -c "import numpy; print('OK')"
```

## 监控和日志

### 1. 日志配置

```python
import logging
import sys

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('activation_demo.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

def log_execution_info(func):
    """执行信息日志装饰器"""
    def wrapper(*args, **kwargs):
        logger.info(f"开始执行: {func.__name__}")
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"执行完成: {func.__name__}, 耗时: {duration:.3f}秒")
            return result
        except Exception as e:
            logger.error(f"执行失败: {func.__name__}, 错误: {str(e)}")
            raise
    
    return wrapper
```

### 2. 性能监控

```python
import time
from functools import wraps

def performance_monitor(threshold_ms=100):
    """性能监控装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time.perf_counter()
            result = func(*args, **kwargs)
            end = time.perf_counter()
            
            duration_ms = (end - start) * 1000
            
            if duration_ms > threshold_ms:
                logger.warning(
                    f"性能警告: {func.__name__} 执行时间 {duration_ms:.2f}ms "
                    f"超过阈值 {threshold_ms}ms"
                )
            else:
                logger.debug(f"{func.__name__} 执行时间: {duration_ms:.2f}ms")
            
            return result
        return wrapper
    return decorator

# 使用示例
@performance_monitor(threshold_ms=1000)
def generate_comprehensive_plot():
    """生成综合分析图"""
    # 绘图代码
    pass
```

## 部署验证

### 1. 部署后验证脚本

```python
def validate_deployment():
    """验证部署是否成功"""
    print("=" * 60)
    print("部署验证开始")
    print("=" * 60)
    
    # 1. 验证Python环境
    import sys
    print(f"Python版本: {sys.version}")
    assert sys.version_info >= (3, 11), "Python版本需>=3.11"
    
    # 2. 验证依赖
    import numpy as np
    import matplotlib
    print(f"NumPy版本: {np.__version__}")
    print(f"Matplotlib版本: {matplotlib.__version__}")
    
    # 3. 验证激活函数
    test_x = np.array([0, 1, -1])
    assert np.allclose(sigmoid(0), 0.5), "Sigmoid验证失败"
    assert tanh_func(0) == 0, "Tanh验证失败"
    assert relu(-1) == 0, "ReLU验证失败"
    print("激活函数验证通过")
    
    # 4. 验证可视化
    import matplotlib.pyplot as plt
    fig, ax = plt.subplots()
    ax.plot([0, 1], [0, 1])
    plt.close(fig)
    print("可视化功能验证通过")
    
    # 5. 验证输出目录
    import os
    os.makedirs('user_data', exist_ok=True)
    assert os.path.exists('user_data'), "输出目录创建失败"
    print("输出目录验证通过")
    
    print("=" * 60)
    print("部署验证完成 - 所有检查通过")
    print("=" * 60)

if __name__ == '__main__':
    validate_deployment()
```

### 2. 健康检查脚本

```bash
#!/bin/bash
# health_check.sh

echo "执行健康检查..."

# 检查Python环境
python3 -c "import numpy; import matplotlib; print('依赖检查通过')" || exit 1

# 检查代码语法
python3 -m py_compile code/activation_optimized_final.py || exit 1

# 运行简单测试
python3 -c "from code.activation_optimized_final import sigmoid, tanh_func, relu; \
            assert sigmoid(0) == 0.5; \
            assert tanh_func(0) == 0; \
            assert relu(-1) == 0; \
            print('功能检查通过')" || exit 1

echo "健康检查完成"
```

---

*最后更新: 2026年2月15日*
*测试和部署版本: v1.0*
*运维团队: DevOps运维组*
