# MCP Agent 调用示例 - 测试和部署

## 测试策略

### 1. 单元测试

#### MCP Server 测试

```python
import unittest
import tempfile
import os
from pathlib import Path
from unittest.mock import patch, MagicMock


class TestTxtCounterMCP(unittest.TestCase):
    """TXT 统计 MCP Server 测试"""
    
    def setUp(self):
        """测试前准备"""
        # 创建临时目录模拟桌面
        self.temp_dir = tempfile.mkdtemp()
        self.original_home = os.environ.get('HOME')
        os.environ['HOME'] = self.temp_dir
        os.makedirs(os.path.join(self.temp_dir, 'Desktop'))
        
        # 创建测试文件
        self.desktop = Path(os.path.join(self.temp_dir, 'Desktop'))
        for i in range(3):
            (self.desktop / f"test{i}.txt").write_text(f"Test content {i}")
        # 创建非 txt 文件
        (self.desktop / "other.pdf").write_text("PDF content")
    
    def tearDown(self):
        """测试后清理"""
        import shutil
        shutil.rmtree(self.temp_dir)
        if self.original_home:
            os.environ['HOME'] = self.original_home
    
    def test_count_desktop_txt_files(self):
        """测试统计 txt 文件数量"""
        from code.mcp_servers.txt_counter import count_desktop_txt_files
        
        count = count_desktop_txt_files()
        self.assertEqual(count, 3)
    
    def test_list_desktop_txt_files(self):
        """测试列出 txt 文件"""
        from code.mcp_servers.txt_counter import list_desktop_txt_files
        
        result = list_desktop_txt_files()
        self.assertIn("3 个 .txt 文件", result)
        self.assertIn("test0.txt", result)
        self.assertIn("test1.txt", result)
        self.assertIn("test2.txt", result)
    
    def test_read_txt_file_success(self):
        """测试读取 txt 文件 - 成功"""
        from code.mcp_servers.txt_counter import read_txt_file
        
        result = read_txt_file("test0.txt")
        self.assertIn("Test content 0", result)
    
    def test_read_txt_file_not_found(self):
        """测试读取 txt 文件 - 文件不存在"""
        from code.mcp_servers.txt_counter import read_txt_file
        
        result = read_txt_file("nonexistent.txt")
        self.assertIn("错误", result)
        self.assertIn("不存在", result)
    
    def test_read_txt_file_wrong_type(self):
        """测试读取 txt 文件 - 错误文件类型"""
        from code.mcp_servers.txt_counter import read_txt_file
        
        result = read_txt_file("other.pdf")
        self.assertIn("错误", result)
        self.assertIn("不是 txt 文件", result)


class TestMCPConfig(unittest.TestCase):
    """MCP 配置测试"""
    
    @patch.dict(os.environ, {
        'DASHSCOPE_API_KEY': 'test_key',
        'AMAP_API_KEY': 'amap_key',
        'ENABLE_SSE_MCP': 'false'
    })
    def test_get_mcp_config_with_amap(self):
        """测试 MCP 配置 - 包含高德地图"""
        from code.main import get_mcp_config
        
        config = get_mcp_config()
        
        self.assertIn('mcpServers', config)
        self.assertIn('amap-maps', config['mcpServers'])
        self.assertIn('txt-counter', config['mcpServers'])
    
    @patch.dict(os.environ, {
        'DASHSCOPE_API_KEY': 'test_key',
        'AMAP_API_KEY': '',
        'ENABLE_SSE_MCP': 'false'
    }, clear=True)
    def test_get_mcp_config_without_amap(self):
        """测试 MCP 配置 - 不包含高德地图"""
        from code.main import get_mcp_config
        
        config = get_mcp_config()
        
        self.assertIn('mcpServers', config)
        self.assertNotIn('amap-maps', config['mcpServers'])
        self.assertIn('txt-counter', config['mcpServers'])
    
    @patch.dict(os.environ, {
        'DASHSCOPE_API_KEY': 'test_key',
        'MODELSCOPE_API_KEY': 'ms_key',
        'ENABLE_SSE_MCP': 'true'
    })
    def test_get_mcp_config_with_sse(self):
        """测试 MCP 配置 - 包含 SSE 服务"""
        from code.main import get_mcp_config
        
        config = get_mcp_config()
        
        self.assertIn('fetch', config['mcpServers'])
        self.assertIn('bing-cn-mcp-server', config['mcpServers'])


if __name__ == '__main__':
    unittest.main(verbosity=2)
```

### 2. 集成测试

#### Agent 集成测试

```python
import pytest
import os
from unittest.mock import patch, MagicMock


class TestAgentIntegration:
    """Agent 集成测试"""
    
    @pytest.fixture
    def mock_env(self):
        """模拟环境变量"""
        original_env = os.environ.copy()
        os.environ['DASHSCOPE_API_KEY'] = 'test_key'
        yield
        os.environ.clear()
        os.environ.update(original_env)
    
    @patch('qwen_agent.agents.Assistant')
    def test_init_agent_service(self, mock_assistant, mock_env):
        """测试 Agent 初始化"""
        from code.main import init_agent_service
        
        bot = init_agent_service()
        
        # 验证 Assistant 被正确调用
        mock_assistant.assert_called_once()
        call_kwargs = mock_assistant.call_args[1]
        
        assert call_kwargs['name'] == 'MCP 智能助手'
        assert 'system_message' in call_kwargs
        assert 'function_list' in call_kwargs
    
    @patch('qwen_agent.agents.Assistant')
    def test_agent_run(self, mock_assistant, mock_env):
        """测试 Agent 运行"""
        from code.main import init_agent_service
        
        # 模拟 Agent 响应
        mock_bot = MagicMock()
        mock_bot.run.return_value = [
            [{'role': 'assistant', 'content': '测试响应'}]
        ]
        mock_assistant.return_value = mock_bot
        
        bot = init_agent_service()
        messages = [{'role': 'user', 'content': '测试问题'}]
        
        responses = list(bot.run(messages))
        
        mock_bot.run.assert_called_once_with(messages)
        assert len(responses) > 0


class TestMCPServerIntegration:
    """MCP Server 集成测试"""
    
    def test_txt_counter_server_startup(self):
        """测试 TXT Counter 服务启动"""
        import subprocess
        import time
        
        # 启动 MCP Server
        process = subprocess.Popen(
            ['python3', 'code/mcp_servers/txt_counter.py'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # 等待服务启动
        time.sleep(2)
        
        # 检查进程状态
        assert process.poll() is None, "服务应该正在运行"
        
        # 终止服务
        process.terminate()
        process.wait()
```

### 3. 性能测试

#### MCP 服务响应测试

```python
import time
import pytest


class TestMCPPerformance:
    """MCP 性能测试"""
    
    def test_txt_counter_performance(self):
        """测试 TXT Counter 性能"""
        from code.mcp_servers.txt_counter import (
            count_desktop_txt_files,
            list_desktop_txt_files
        )
        
        # 测试统计性能
        start_time = time.time()
        for _ in range(100):
            count_desktop_txt_files()
        duration = time.time() - start_time
        
        print(f"100 次统计调用耗时: {duration:.3f}秒")
        assert duration < 5.0, "100 次调用应在 5 秒内完成"
        
        # 测试列表性能
        start_time = time.time()
        for _ in range(50):
            list_desktop_txt_files()
        duration = time.time() - start_time
        
        print(f"50 次列表调用耗时: {duration:.3f}秒")
        assert duration < 3.0, "50 次调用应在 3 秒内完成"
    
    def test_agent_response_time(self):
        """测试 Agent 响应时间"""
        # 注意：此测试需要真实的 API Key
        pytest.skip("需要真实 API Key")
        
        from code.main import init_agent_service
        
        bot = init_agent_service()
        messages = [{'role': 'user', 'content': '统计桌面上的txt文件数量'}]
        
        start_time = time.time()
        for _ in bot.run(messages):
            pass
        duration = time.time() - start_time
        
        print(f"Agent 响应时间: {duration:.3f}秒")
        assert duration < 30.0, "响应应在 30 秒内完成"


class TestConcurrency:
    """并发测试"""
    
    def test_concurrent_mcp_calls(self):
        """测试并发 MCP 调用"""
        from concurrent.futures import ThreadPoolExecutor
        from code.mcp_servers.txt_counter import count_desktop_txt_files
        
        def call_task():
            return count_desktop_txt_files()
        
        start_time = time.time()
        with ThreadPoolExecutor(max_workers=10) as executor:
            results = list(executor.map(call_task, range(20)))
        duration = time.time() - start_time
        
        print(f"20 个并发调用耗时: {duration:.3f}秒")
        assert duration < 10.0, "20 个并发调用应在 10 秒内完成"
        assert all(r >= 0 for r in results), "所有结果应为有效数字"
```

## 部署策略

### 1. 开发环境部署

#### 本地开发环境

```bash
# 1. 克隆项目
git clone https://github.com/lihaizhong/build-your-own-ai.git
cd build-your-own-ai/practice/20-CASE-调用Agent调用MCP

# 2. 安装依赖
uv sync
source .venv/bin/activate

# 3. 配置环境变量
cp .env.example .env
# 编辑 .env 文件，填写 API Key

# 4. 启动服务
python code/main.py
```

#### Docker 容器化部署

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    nodejs \
    npm \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY pyproject.toml .
RUN pip install --no-cache-dir qwen-agent mcp python-dotenv loguru

# 复制应用代码
COPY code/ ./code/

# 创建必要的目录
RUN mkdir -p /app/data /app/output /app/logs

# 设置环境变量
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 暴露端口
EXPOSE 7860

# 启动命令
CMD ["python", "code/main.py"]
```

#### Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  mcp-agent:
    build: .
    container_name: mcp-agent
    volumes:
      - ./data:/app/data
      - ./output:/app/output
      - ./logs:/app/logs
    environment:
      - DASHSCOPE_API_KEY=${DASHSCOPE_API_KEY}
      - AMAP_API_KEY=${AMAP_API_KEY}
      - MODELSCOPE_API_KEY=${MODELSCOPE_API_KEY}
      - ENABLE_SSE_MCP=${ENABLE_SSE_MCP:-false}
    ports:
      - "7860:7860"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7860"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
```

### 2. 生产环境部署

#### Kubernetes 部署

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-agent
  labels:
    app: mcp-agent
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mcp-agent
  template:
    metadata:
      labels:
        app: mcp-agent
    spec:
      containers:
      - name: mcp-agent
        image: mcp-agent:latest
        ports:
        - containerPort: 7860
        env:
        - name: DASHSCOPE_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: dashscope-api-key
        - name: AMAP_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: amap-api-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 7860
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 7860
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: mcp-agent-service
spec:
  selector:
    app: mcp-agent
  ports:
  - protocol: TCP
    port: 80
    targetPort: 7860
  type: LoadBalancer

---
apiVersion: v1
kind: Secret
metadata:
  name: api-secrets
type: Opaque
stringData:
  dashscope-api-key: "your_dashscope_api_key"
  amap-api-key: "your_amap_api_key"
```

### 3. 环境变量配置

#### 开发环境 (.env.development)

```bash
# API 配置
DASHSCOPE_API_KEY=your_dev_api_key
AMAP_API_KEY=your_amap_api_key
MODELSCOPE_API_KEY=your_modelscope_api_key

# 功能开关
ENABLE_SSE_MCP=false

# 日志级别
LOG_LEVEL=DEBUG

# 超时配置
API_TIMEOUT=120
```

#### 生产环境 (.env.production)

```bash
# API 配置
DASHSCOPE_API_KEY=your_prod_api_key
AMAP_API_KEY=your_amap_api_key
MODELSCOPE_API_KEY=your_modelscope_api_key

# 功能开关
ENABLE_SSE_MCP=true

# 日志级别
LOG_LEVEL=INFO

# 超时配置
API_TIMEOUT=60
```

## 监控和日志

### 1. 日志配置

```python
# logging_config.py
from loguru import logger
import sys

def setup_logging(log_level: str = "INFO", log_file: str = "logs/app.log"):
    """
    配置日志
    
    Args:
        log_level: 日志级别
        log_file: 日志文件路径
    """
    # 移除默认处理器
    logger.remove()
    
    # 控制台输出
    logger.add(
        sys.stdout,
        level=log_level,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>"
    )
    
    # 文件输出
    logger.add(
        log_file,
        level=log_level,
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
        rotation="1 day",
        retention="30 days",
        compression="zip"
    )
    
    # 错误日志单独文件
    logger.add(
        "logs/error.log",
        level="ERROR",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
        rotation="1 day",
        retention="90 days"
    )
    
    return logger
```

### 2. 健康检查

```python
# health_check.py
import requests
import sys
from loguru import logger


def check_health(base_url: str) -> bool:
    """
    健康检查
    
    Args:
        base_url: 服务基础 URL
        
    Returns:
        是否健康
    """
    try:
        response = requests.get(f"{base_url}", timeout=5)
        if response.status_code == 200:
            logger.info("健康检查通过")
            return True
        else:
            logger.error(f"健康检查失败: {response.status_code}")
            return False
    except Exception as e:
        logger.error(f"健康检查异常: {e}")
        return False


def check_api_keys() -> bool:
    """检查 API Key 配置"""
    import os
    
    required_keys = ['DASHSCOPE_API_KEY']
    optional_keys = ['AMAP_API_KEY', 'MODELSCOPE_API_KEY']
    
    all_ok = True
    
    for key in required_keys:
        if not os.getenv(key):
            logger.error(f"必需的 API Key 未配置: {key}")
            all_ok = False
        else:
            logger.info(f"API Key 已配置: {key}")
    
    for key in optional_keys:
        if os.getenv(key):
            logger.info(f"可选 API Key 已配置: {key}")
        else:
            logger.warning(f"可选 API Key 未配置: {key}")
    
    return all_ok


def main():
    """主函数"""
    base_url = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:7860"
    
    checks = [
        ("API Key 配置", check_api_keys()),
        ("服务健康", check_health(base_url)),
    ]
    
    all_passed = all(result for _, result in checks)
    
    print("\n检查结果:")
    for name, result in checks:
        status = "✅ 通过" if result else "❌ 失败"
        print(f"  {name}: {status}")
    
    if all_passed:
        print("\n✅ 所有检查通过")
        sys.exit(0)
    else:
        print("\n❌ 部分检查失败")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

### 3. 监控指标

```python
# metrics.py
from prometheus_client import Counter, Histogram, Gauge, start_http_server

# 定义指标
REQUEST_COUNT = Counter(
    'mcp_agent_requests_total',
    'Total number of requests',
    ['service', 'tool']
)

REQUEST_LATENCY = Histogram(
    'mcp_agent_request_latency_seconds',
    'Request latency in seconds',
    ['service', 'tool']
)

MCP_CALL_COUNT = Counter(
    'mcp_agent_mcp_calls_total',
    'Total number of MCP service calls',
    ['service', 'tool', 'status']
)

ACTIVE_CONNECTIONS = Gauge(
    'mcp_agent_active_connections',
    'Number of active connections'
)


def track_request(service: str, tool: str):
    """跟踪请求"""
    REQUEST_COUNT.labels(service=service, tool=tool).inc()


def track_latency(service: str, tool: str, duration: float):
    """跟踪延迟"""
    REQUEST_LATENCY.labels(service=service, tool=tool).observe(duration)


def track_mcp_call(service: str, tool: str, status: str):
    """跟踪 MCP 调用"""
    MCP_CALL_COUNT.labels(service=service, tool=tool, status=status).inc()


def start_metrics_server(port: int = 9090):
    """启动指标服务器"""
    start_http_server(port)
```

## CI/CD 流水线

### GitHub Actions 配置

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.11, 3.12]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install qwen-agent mcp python-dotenv loguru pytest pytest-cov
        pip install flake8 black
    
    - name: Lint with flake8
      run: |
        flake8 code/ --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 code/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    
    - name: Format check with black
      run: |
        black --check code/
    
    - name: Run tests
      run: |
        pytest code/ -v --cov=code --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: |
        docker build -t mcp-agent:${{ github.sha }} .
        docker tag mcp-agent:${{ github.sha }} mcp-agent:latest
    
    - name: Push to registry
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push mcp-agent:${{ github.sha }}
        docker push mcp-agent:latest

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Deploy to production
      run: |
        kubectl set image deployment/mcp-agent \
          mcp-agent=mcp-agent:${{ github.sha }} \
          -n production
```

## 部署验证

### 1. 验证脚本

```bash
#!/bin/bash
# deploy_verify.sh

echo "开始部署验证..."

# 1. 检查服务状态
echo "检查服务状态..."
curl -f http://localhost:7860 || exit 1

# 2. 检查 API Key 配置
echo "检查 API Key 配置..."
python health_check.py

# 3. 测试基本功能
echo "测试基本功能..."
# 这里可以添加功能测试

echo "部署验证完成！"
```

### 2. 回滚策略

```python
# rollback.py
import subprocess
import logging

logger = logging.getLogger(__name__)


class RollbackManager:
    """回滚管理器"""
    
    def __init__(self, deployment_name: str, namespace: str = "default"):
        self.deployment_name = deployment_name
        self.namespace = namespace
    
    def get_current_version(self) -> str:
        """获取当前版本"""
        cmd = [
            "kubectl", "get", "deployment", self.deployment_name,
            "-o", "jsonpath={.spec.template.spec.containers[0].image}",
            "-n", self.namespace
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result.stdout.strip()
    
    def rollback(self, version: str) -> bool:
        """回滚到指定版本"""
        try:
            logger.info(f"开始回滚到版本: {version}")
            
            cmd = [
                "kubectl", "set", "image", "deployment", self.deployment_name,
                f"{self.deployment_name}={version}",
                "-n", self.namespace
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                logger.error(f"回滚失败: {result.stderr}")
                return False
            
            logger.info("回滚成功")
            return True
                
        except Exception as e:
            logger.error(f"回滚异常: {e}")
            return False


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="回滚管理")
    parser.add_argument("--version", required=True, help="目标版本")
    parser.add_argument("--deployment", default="mcp-agent", help="部署名称")
    parser.add_argument("--namespace", default="production", help="命名空间")
    
    args = parser.parse_args()
    
    manager = RollbackManager(args.deployment, args.namespace)
    
    current = manager.get_current_version()
    print(f"当前版本: {current}")
    print(f"目标版本: {args.version}")
    
    if manager.rollback(args.version):
        print("回滚成功！")
    else:
        print("回滚失败！")
```

---

*最后更新: 2026年2月24日*
*测试和部署版本: v1.0*
*运维团队: DevOps运维组*
