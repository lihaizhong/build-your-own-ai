# 钢铁缺陷检测系统 - 代码实现详解

## 核心代码结构

### 1. 项目路径管理模块

```python
from pathlib import Path

def get_project_path(*paths: str) -> Path:
    """获取项目路径的统一方法"""
    try:
        current_dir = Path(__file__).parent
        project_dir = current_dir.parent
        return project_dir.joinpath(*paths)
    except NameError:
        # 在交互式环境中
        return Path.cwd().joinpath(*paths)
```

**功能特点：**
- **统一路径管理**: 提供项目路径的标准化获取方法
- **容错处理**: 处理不同运行环境下的路径差异
- **灵活扩展**: 支持任意层级的路径构建

### 2. SteelDefectTrainer类核心实现

#### 初始化方法详解

```python
class SteelDefectTrainer:
    def __init__(self, config_path="config/training_config.yaml"):
        """
        初始化训练器
        
        Args:
            config_path: 训练配置文件路径
        """
        self.config_path = Path(config_path)
        self.config = self.load_config()
        
        # 设置随机种子
        self.set_seed(self.config.get("seed", 42))
        
        # 设备设置
        self.device = self.set_device()
        
        # 输出目录
        self.output_dir = Path(self.config.get("output_dir", "runs/detect"))
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # 实验名称
        exp_name = self.config.get("experiment_name", "steel_defect")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.exp_dir = self.output_dir / f"{exp_name}_{timestamp}"
        self.exp_dir.mkdir(parents=True, exist_ok=True)
```

**关键设计点：**
- **模块化初始化**: 分步骤初始化各个组件
- **路径标准化**: 统一管理项目目录结构
- **实验管理**: 自动生成带时间戳的实验目录

## 配置管理模块详解

### 1. 配置加载

```python
def load_config(self):
    """加载训练配置"""
    if not self.config_path.exists():
        print(f"警告: 配置文件不存在 {self.config_path}，使用默认配置")
        return self.get_default_config()
    
    with open(self.config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    
    return config
```

### 2. 默认配置

```python
def get_default_config(self):
    """获取默认训练配置"""
    return {
        # 数据配置
        "data_yaml": "data/yolo_format/data.yaml",
        "imgsz": 200,  # 保持原尺寸
        
        # 模型配置
        "model": "yolo11n.pt",  # 从nano模型开始
        "pretrained": True,
        
        # 训练配置
        "epochs": 200,
        "batch_size": 16,
        "workers": 4,
        "device": "0",  # GPU设备
        
        # 优化器配置
        "optimizer": "AdamW",
        "lr0": 0.001,   # 初始学习率
        "cos_lr": True,  # 余弦退火
        
        # 损失函数权重
        "box": 7.5,
        "cls": 0.5,
        "dfl": 1.5,
        
        # 数据增强
        "hsv_h": 0.015,
        "hsv_s": 0.7,
        "hsv_v": 0.4,
        "degrees": 10.0,
        "translate": 0.1,
        "scale": 0.5,
        "fliplr": 0.5,
        
        # 其他配置
        "patience": 50,
        "seed": 42,
    }
```

### 3. 随机种子设置

```python
def set_seed(self, seed=42):
    """设置随机种子确保可重复性"""
    import random
    import numpy as np
    
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    
    # 确保可重复性
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
    
    print(f"设置随机种子: {seed}")
```

## 数据转换模块详解

### 1. SteelDefectConverter类

```python
class SteelDefectConverter:
    def __init__(self, data_root="data"):
        """
        初始化转换器
        
        Args:
            data_root: 数据根目录
        """
        self.data_root = Path(data_root)
        self.train_images_dir = self.data_root / "train" / "IMAGES"
        self.train_annotations_dir = self.data_root / "train" / "ANNOTATIONS"
        self.test_images_dir = self.data_root / "test" / "IMAGES"
        
        # 缺陷类别映射
        self.class_map = {
            "rolled-in_scale": 0,
            "patches": 1,
            "scratches": 2,
            "inclusion": 3,
            "crazing": 4,
            "pitted_surface": 5
        }
        
        # 输出目录
        self.output_dir = self.data_root / "yolo_format"
        self.yolo_images_dir = self.output_dir / "images"
        self.yolo_labels_dir = self.output_dir / "labels"
```

### 2. VOC到YOLO格式转换

```python
def convert_voc_to_yolo(self, xml_path, output_txt_path):
    """
    转换单个VOC XML文件到YOLO格式
    
    Args:
        xml_path: VOC XML文件路径
        output_txt_path: 输出YOLO格式文件路径
    """
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()
        
        # 获取图像尺寸
        size = root.find('size')
        if size is None:
            print(f"警告: {xml_path} 中没有size信息，使用默认200×200")
            width, height = 200, 200
        else:
            width = int(size.find('width').text)
            height = int(size.find('height').text)
        
        annotations = []
        
        # 处理每个缺陷对象
        for obj in root.findall('object'):
            # 获取类别
            cls_name = obj.find('name').text
            if cls_name not in self.class_map:
                print(f"警告: 未知类别 '{cls_name}'，跳过")
                continue
            
            cls_id = self.class_map[cls_name]
            
            # 获取边界框
            bbox = obj.find('bndbox')
            if bbox is None:
                continue
            
            xmin = int(bbox.find('xmin').text)
            ymin = int(bbox.find('ymin').text)
            xmax = int(bbox.find('xmax').text)
            ymax = int(bbox.find('ymax').text)
            
            # 转换为YOLO格式 (cx, cy, w, h)
            cx = (xmin + xmax) / 2 / width
            cy = (ymin + ymax) / 2 / height
            w = (xmax - xmin) / width
            h = (ymax - ymin) / height
            
            # 确保坐标在[0,1]范围内
            cx = max(0, min(1, cx))
            cy = max(0, min(1, cy))
            w = max(0, min(1, w))
            h = max(0, min(1, h))
            
            annotations.append(f"{cls_id} {cx:.6f} {cy:.6f} {w:.6f} {h:.6f}")
        
        # 写入YOLO格式文件
        if annotations:
            with open(output_txt_path, 'w') as f:
                f.write('\n'.join(annotations))
            return True
        return False
            
    except Exception as e:
        print(f"错误: 处理 {xml_path} 时出错: {e}")
        return False
```

**转换公式：**
- **中心点x**: `cx = (xmin + xmax) / 2 / width`
- **中心点y**: `cy = (ymin + ymax) / 2 / height`
- **宽度**: `w = (xmax - xmin) / width`
- **高度**: `h = (ymax - ymin) / height`

### 3. 数据集划分

```python
def split_train_val(self, train_files, val_ratio=0.2):
    """
    分割训练集和验证集
    
    Args:
        train_files: 训练集文件列表
        val_ratio: 验证集比例
    
    Returns:
        train_split, val_split: 分割后的文件列表
    """
    random.seed(42)  # 固定随机种子确保可重复性
    random.shuffle(train_files)
    
    val_size = int(len(train_files) * val_ratio)
    val_split = train_files[:val_size]
    train_split = train_files[val_size:]
    
    return train_split, val_split
```

## 训练评估模块详解

### 1. 数据集分析

```python
def analyze_dataset(self):
    """分析数据集分布"""
    print("\n" + "=" * 60)
    print("分析数据集分布")
    print("=" * 60)
    
    data_yaml = self.config.get("data_yaml")
    if not Path(data_yaml).exists():
        print(f"错误: 数据配置文件不存在 {data_yaml}")
        return
    
    # 读取数据配置
    with open(data_yaml, 'r', encoding='utf-8') as f:
        data_config = yaml.safe_load(f)
    
    # 获取类别信息
    class_names = data_config.get("names", [])
    num_classes = len(class_names)
    
    # 统计每个类别的样本数量
    train_labels_dir = Path(data_config['path']) / "labels" / "train"
    val_labels_dir = Path(data_config['path']) / "labels" / "val"
    
    class_counts = {i: 0 for i in range(num_classes)}
    
    # 统计训练集和验证集
    for labels_dir in [train_labels_dir, val_labels_dir]:
        if labels_dir.exists():
            for label_file in labels_dir.glob("*.txt"):
                with open(label_file, 'r') as f:
                    for line in f:
                        if line.strip():
                            cls_id = int(line.strip().split()[0])
                            if cls_id in class_counts:
                                class_counts[cls_id] += 1
    
    # 打印统计结果
    print("\n类别分布统计:")
    total_instances = sum(class_counts.values())
    for cls_id, count in class_counts.items():
        cls_name = class_names[cls_id]
        percentage = (count / total_instances * 100) if total_instances > 0 else 0
        print(f"  {cls_name} (ID: {cls_id}): {count} 个实例 ({percentage:.1f}%)")
```

### 2. 模型训练

```python
def train_model(self):
    """训练YOLOv11模型"""
    print("\n" + "=" * 60)
    print("开始训练YOLOv11模型")
    print("=" * 60)
    
    # 获取训练参数
    train_args = {
        'data': self.config.get("data_yaml"),
        'epochs': self.config.get("epochs", 200),
        'imgsz': self.config.get("imgsz", 200),
        'batch': self.config.get("batch_size", 16),
        'workers': self.config.get("workers", 4),
        'device': self.config.get("device", "0"),
        'project': self.config.get("project", "steel_defect_detection"),
        'name': self.config.get("name", "yolo11n_steel_v1"),
        'exist_ok': self.config.get("exist_ok", True),
        'pretrained': self.config.get("pretrained", True),
        'optimizer': self.config.get("optimizer", "AdamW"),
        'lr0': self.config.get("lr0", 0.001),
        'cos_lr': self.config.get("cos_lr", True),
        'patience': self.config.get("patience", 50),
        'save': True,
        'save_period': self.config.get("save_period", 10),
        
        # 数据增强参数
        'hsv_h': self.config.get("hsv_h", 0.015),
        'hsv_s': self.config.get("hsv_s", 0.7),
        'hsv_v': self.config.get("hsv_v", 0.4),
        'degrees': self.config.get("degrees", 10.0),
        'translate': self.config.get("translate", 0.1),
        'scale': self.config.get("scale", 0.5),
        'fliplr': self.config.get("fliplr", 0.5),
        
        # 损失函数权重
        'box': self.config.get("box", 7.5),
        'cls': self.config.get("cls", 0.5),
        'dfl': self.config.get("dfl", 1.5),
    }
    
    # 加载模型
    model_name = self.config.get("model", "yolo11n.pt")
    print(f"\n加载模型: {model_name}")
    
    try:
        model = YOLO(model_name)
    except Exception as e:
        print(f"错误: 加载模型失败: {e}")
        return None, None
    
    # 开始训练
    print("\n开始训练...")
    try:
        results = model.train(**train_args)
        print("训练完成!")
        
        # 保存训练结果
        self.save_training_results(results, model)
        
        return model, results
        
    except Exception as e:
        print(f"训练过程中出错: {e}")
        return None, None
```

### 3. 模型评估

```python
def evaluate_model(self, model_path=None):
    """评估训练好的模型"""
    print("\n" + "=" * 60)
    print("评估模型性能")
    print("=" * 60)
    
    if model_path is None:
        # 查找最佳模型
        model_files = list(self.exp_dir.glob("**/best.pt"))
        if not model_files:
            print("错误: 未找到训练好的模型")
            return
        
        model_path = model_files[0]
    
    print(f"加载模型: {model_path}")
    
    try:
        model = YOLO(model_path)
    except Exception as e:
        print(f"错误: 加载模型失败: {e}")
        return
    
    # 在验证集上评估
    data_yaml = self.config.get("data_yaml")
    
    try:
        metrics = model.val(
            data=data_yaml,
            imgsz=self.config.get("imgsz", 200),
            batch=self.config.get("batch_size", 16),
            conf=0.25,      # 置信度阈值
            iou=0.45,       # IoU阈值
            device=self.config.get("device", "0"),
            plots=True,     # 生成评估图表
            save_json=True, # 保存JSON结果
        )
        
        # 打印关键指标
        print("\n评估结果:")
        print(f"  mAP50-95: {metrics.box.map:.4f}")
        print(f"  mAP50: {metrics.box.map50:.4f}")
        print(f"  精确率: {metrics.box.p:.4f}")
        print(f"  召回率: {metrics.box.r:.4f}")
        print(f"  F1分数: {2 * metrics.box.p * metrics.box.r / (metrics.box.p + metrics.box.r + 1e-16):.4f}")
        
        return metrics
        
    except Exception as e:
        print(f"评估过程中出错: {e}")
        return None
```

### 4. 模型导出

```python
def export_model(self, model_path=None, format="onnx"):
    """导出模型为其他格式"""
    print("\n" + "=" * 60)
    print(f"导出模型为 {format.upper()} 格式")
    print("=" * 60)
    
    if model_path is None:
        model_files = list(self.exp_dir.glob("**/best.pt"))
        if not model_files:
            print("错误: 未找到训练好的模型")
            return
        
        model_path = model_files[0]
    
    print(f"加载模型: {model_path}")
    
    try:
        model = YOLO(model_path)
        
        # 导出模型
        export_args = {
            'format': format,
            'imgsz': self.config.get("imgsz", 200),
            'device': self.config.get("device", "0"),
            'simplify': True,  # 简化模型
            'opset': 12,       # ONNX opset版本
        }
        
        if format == "engine":  # TensorRT
            export_args['workspace'] = 4
        
        exported_path = model.export(**export_args)
        print(f"模型已导出到: {exported_path}")
        
        return exported_path
        
    except Exception as e:
        print(f"导出过程中出错: {e}")
        return None
```

## 错误处理和调试机制

### 1. 异常处理策略

```python
def safe_train(self):
    """安全训练，包含完善的错误处理"""
    try:
        print("开始安全训练流程...")
        
        # 1. 检查配置
        if not self.config_path.exists():
            raise FileNotFoundError(f"配置文件不存在: {self.config_path}")
        
        # 2. 检查数据
        data_yaml = Path(self.config.get("data_yaml"))
        if not data_yaml.exists():
            raise FileNotFoundError(f"数据配置文件不存在: {data_yaml}")
        
        # 3. 检查GPU（如果使用）
        device = self.config.get("device", "0")
        if device != "cpu" and not torch.cuda.is_available():
            print("警告: GPU不可用，切换到CPU")
            self.config["device"] = "cpu"
        
        # 4. 开始训练
        model, results = self.train_model()
        
        if model is None:
            raise RuntimeError("训练失败")
        
        return model, results
        
    except FileNotFoundError as e:
        print(f"文件错误: {e}")
        return None, None
    except RuntimeError as e:
        print(f"运行时错误: {e}")
        return None, None
    except Exception as e:
        print(f"未知错误: {e}")
        import traceback
        traceback.print_exc()
        return None, None
```

### 2. 性能监控

```python
import time

def monitor_performance(self, operation: str):
    """性能监控装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            
            duration = end_time - start_time
            if duration > 1.0:
                print(f"⚠️  {operation} 执行时间较长: {duration:.2f}秒")
            else:
                print(f"✅ {operation} 执行完成: {duration:.3f}秒")
            
            return result
        return wrapper
    return decorator
```

### 3. 日志记录

```python
import logging

def setup_logging(self):
    """设置日志记录"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(self.exp_dir / 'training.log'),
            logging.StreamHandler()
        ]
    )
    
    self.logger = logging.getLogger(__name__)
    self.logger.info("日志系统初始化完成")
```

## 示例代码

### 完整训练流程

```python
# 完整训练流程示例
from pathlib import Path
from code.train_yolov11 import SteelDefectTrainer

def main():
    """主函数"""
    # 1. 创建训练器
    trainer = SteelDefectTrainer("config/training_config.yaml")
    
    # 2. 分析数据集
    trainer.analyze_dataset()
    
    # 3. 训练模型
    model, results = trainer.train_model()
    
    if model is None:
        print("训练失败")
        return
    
    # 4. 评估模型
    metrics = trainer.evaluate_model()
    
    # 5. 导出模型
    trainer.export_model(format="onnx")
    
    print(f"\n训练完成！实验目录: {trainer.exp_dir}")

if __name__ == "__main__":
    main()
```

### 模型推理示例

```python
# 使用训练好的模型进行推理
from ultralytics import YOLO
import cv2

def predict_image(model_path, image_path):
    """单张图像预测"""
    # 加载模型
    model = YOLO(model_path)
    
    # 预测
    results = model.predict(image_path, conf=0.25)
    
    # 解析结果
    for result in results:
        boxes = result.boxes
        for box in boxes:
            # 获取边界框坐标
            x1, y1, x2, y2 = box.xyxy[0].tolist()
            
            # 获取类别和置信度
            cls_id = int(box.cls[0])
            conf = float(box.conf[0])
            
            print(f"检测到缺陷: 类别={cls_id}, 置信度={conf:.3f}, 位置=({x1:.1f}, {y1:.1f}, {x2:.1f}, {y2:.1f})")
    
    # 可视化
    results[0].show()

if __name__ == "__main__":
    predict_image(
        "runs/detect/steel_defect_yolo11n_*/weights/best.pt",
        "data/test/IMAGES/1400.jpg"
    )
```

---

*最后更新: 2026年2月14日*
*代码实现版本: v1.0*
*开发团队: AI系统开发组*
