# 钢铁缺陷检测系统 - 技术架构

## 架构概览

钢铁缺陷检测系统采用分层架构设计，包含数据层、处理层、模型层和应用层四个核心层次，确保系统的可扩展性、可维护性和高性能。

```
┌─────────────────────────────────────────────────────────────┐
│                       应用层                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │  模型训练   │  │  模型评估   │  │  模型导出   │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       模型层                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   YOLOv11 模型                       │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │   │
│  │  │ Backbone │  │   Neck   │  │   Head   │          │   │
│  │  └──────────┘  └──────────┘  └──────────┘          │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       处理层                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 数据转换    │  │ 数据增强    │  │ 后处理      │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       数据层                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ 训练数据    │  │ 验证数据    │  │ 测试数据    │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件架构

### 1. SteelDefectTrainer类架构

```python
class SteelDefectTrainer:
    """
    钢铁缺陷检测训练器
    核心功能模块：
    - 配置管理模块
    - 数据分析模块  
    - 模型训练模块
    - 模型评估模块
    - 模型导出模块
    """
    
    def __init__(self, config_path="config/training_config.yaml"):
        # 加载训练配置
        self.config = self.load_config()
        
        # 设置随机种子
        self.set_seed(self.config.get("seed", 42))
        
        # 设备设置
        self.device = self.set_device()
        
        # 输出目录
        self.output_dir = Path(self.config.get("output_dir", "runs/detect"))
        self.exp_dir = self.output_dir / f"{exp_name}_{timestamp}"
```

### 2. 数据处理流程

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│  原始数据    │────▶│  格式转换    │────▶│  YOLO格式    │
│  (VOC XML)   │     │  (Converter) │     │  (TXT)       │
└──────────────┘     └──────────────┘     └──────────────┘
                           │
                           ▼
                     ┌──────────────┐
                     │  数据划分    │
                     │  (80/20)     │
                     └──────────────┘
                           │
              ┌────────────┼────────────┐
              ▼            ▼            ▼
        ┌──────────┐ ┌──────────┐ ┌──────────┐
        │ 训练集   │ │ 验证集   │ │ 测试集   │
        │ (1120)   │ │ (280)    │ │ (400)    │
        └──────────┘ └──────────┘ └──────────┘
```

## 技术栈详解

### 1. YOLO模型架构

#### YOLOv11核心结构
```
输入图像 (200×200×3)
       │
       ▼
┌──────────────────┐
│    Backbone      │  特征提取
│  (C3k2 + C2PSA)  │  多尺度特征
└──────────────────┘
       │
       ▼
┌──────────────────┐
│      Neck        │  特征融合
│    (FPN+PAN)     │  多尺度检测
└──────────────────┘
       │
       ▼
┌──────────────────┐
│    Head          │  检测输出
│  (解耦检测头)    │  分类+回归
└──────────────────┘
       │
       ▼
检测结果 (边界框 + 类别 + 置信度)
```

#### 模型尺寸对比
| 模型 | 参数量 | FLOPs | mAP | 速度 | 适用场景 |
|------|--------|-------|-----|------|----------|
| yolo11n | 2.6M | 6.4G | 39.5 | 最快 | 边缘设备 |
| yolo11s | 9.4M | 21.5G | 47.0 | 快 | 实时检测 |
| yolo11m | 20.1M | 68.0G | 51.5 | 中等 | 平衡场景 |
| yolo11l | 25.3M | 86.9G | 53.4 | 较慢 | 高精度需求 |
| yolo11x | 56.9M | 194.9G | 54.7 | 最慢 | 研究用途 |

### 2. 数据处理模块

#### VOC到YOLO格式转换
```python
def convert_voc_to_yolo(xml_path, output_txt_path):
    """
    将PASCAL VOC XML转换为YOLO格式
    
    转换公式：
    cx = (xmin + xmax) / 2 / width
    cy = (ymin + ymax) / 2 / height
    w = (xmax - xmin) / width
    h = (ymax - ymin) / height
    
    输出格式：
    class_id cx cy w h
    """
    # 解析XML获取边界框
    tree = ET.parse(xml_path)
    root = tree.getroot()
    
    # 获取图像尺寸
    size = root.find('size')
    width = int(size.find('width').text)
    height = int(size.find('height').text)
    
    # 转换坐标
    for obj in root.findall('object'):
        cls_name = obj.find('name').text
        cls_id = class_map[cls_name]
        
        bbox = obj.find('bndbox')
        xmin = int(bbox.find('xmin').text)
        ymin = int(bbox.find('ymin').text)
        xmax = int(bbox.find('xmax').text)
        ymax = int(bbox.find('ymax').text)
        
        # YOLO格式坐标
        cx = (xmin + xmax) / 2 / width
        cy = (ymin + ymax) / 2 / height
        w = (xmax - xmin) / width
        h = (ymax - ymin) / height
```

### 3. 数据增强策略

#### 工业场景优化配置
```python
# 针对钢铁缺陷检测的数据增强配置
AUGMENTATION_CONFIG = {
    # 颜色增强（灰度图像影响较小）
    'hsv_h': 0.015,     # 色调增强
    'hsv_s': 0.7,       # 饱和度增强
    'hsv_v': 0.4,       # 明度增强（模拟不同光照）
    
    # 几何变换
    'degrees': 10.0,    # 旋转角度（±10度）
    'translate': 0.1,   # 平移（10%）
    'scale': 0.5,       # 缩放（0.5-1.5倍）
    'fliplr': 0.5,      # 水平翻转概率
    'flipud': 0.0,      # 垂直翻转（钢铁图像通常不需要）
    
    # 高级增强
    'mosaic': 1.0,      # Mosaic数据增强概率
    'mixup': 0.0,       # MixUp增强（小数据集谨慎使用）
    'copy_paste': 0.0,  # 复制粘贴增强
}
```

#### 数据增强流程图
```
原始图像 ──┬──▶ 颜色增强 ──▶ HSV调整
           │
           ├──▶ 几何变换 ──▶ 旋转/平移/缩放/翻转
           │
           ├──▶ 高级增强 ──▶ Mosaic/MixUp
           │
           └──▶ 输出增强图像
```

### 4. 损失函数设计

#### 小目标检测优化
```python
# 损失函数权重配置（针对小目标优化）
LOSS_CONFIG = {
    'box': 7.5,     # 边界框损失权重（提高定位精度）
    'cls': 0.5,     # 分类损失权重（适当降低）
    'dfl': 1.5,     # Distribution Focal Loss权重
}

# 损失函数组成
# Total Loss = box_loss * 7.5 + cls_loss * 0.5 + dfl_loss * 1.5
```

#### 损失函数类型
1. **边界框损失 (CIoU Loss)**
   - 考虑边界框的重叠面积
   - 中心点距离和宽高比
   - 提高定位精度

2. **分类损失 (BCE Loss)**
   - 二分类交叉熵损失
   - 多类别分类
   - 支持类别不平衡处理

3. **DFL损失 (Distribution Focal Loss)**
   - 边界框回归的分布建模
   - 提高小目标检测精度

## 系统配置架构

### 1. 配置文件结构

```yaml
# config/training_config.yaml 结构
training_config:
  # 数据配置
  data:
    data_yaml: "data/yolo_format/data.yaml"
    imgsz: 200
    batch_size: 16
    workers: 4
    
  # 模型配置
  model:
    name: "yolo11n.pt"
    pretrained: true
    
  # 训练配置
  training:
    epochs: 200
    optimizer: "AdamW"
    lr0: 0.001
    cos_lr: true
    patience: 50
    
  # 数据增强
  augmentation:
    hsv_h: 0.015
    hsv_s: 0.7
    hsv_v: 0.4
    degrees: 10.0
    translate: 0.1
    scale: 0.5
    fliplr: 0.5
    
  # 损失权重
  loss:
    box: 7.5
    cls: 0.5
    dfl: 1.5
```

### 2. 目录结构设计

```
项目根目录/
├── config/                    # 配置文件
│   └── training_config.yaml
├── code/                      # 源代码
│   ├── train_yolov11.py
│   └── convert_voc_to_yolo.py
├── data/                      # 数据目录
│   ├── train/
│   ├── test/
│   └── yolo_format/
├── runs/                      # 训练输出
│   └── detect/
│       └── experiment_*/
│           ├── weights/       # 模型权重
│           ├── results.csv    # 训练日志
│           └── plots/         # 可视化图表
├── docs/                      # 文档
└── .venv/                     # 虚拟环境
```

## 性能优化架构

### 1. 训练优化

#### 学习率调度
```python
# 余弦退火学习率调度
def cosine_lr_scheduler(epoch, total_epochs, lr0, lrf):
    """
    余弦退火学习率调度
    适合小数据集训练，避免过早收敛
    """
    # 预热阶段
    warmup_epochs = 3
    if epoch < warmup_epochs:
        return lr0 * (epoch / warmup_epochs)
    
    # 余弦退火阶段
    progress = (epoch - warmup_epochs) / (total_epochs - warmup_epochs)
    return lrf + 0.5 * (lr0 - lrf) * (1 + cos(pi * progress))
```

#### 早停策略
```python
# 早停配置
EARLY_STOPPING = {
    'patience': 50,       # 无改善容忍次数
    'min_delta': 0.001,   # 最小改善阈值
    'monitor': 'mAP50',   # 监控指标
}
```

### 2. 推理优化

#### 模型量化
```python
# 支持的量化方式
QUANTIZATION_OPTIONS = {
    'fp32': {           # 全精度
        'size': '100%',
        'speed': '1x',
        'accuracy': '100%',
    },
    'fp16': {           # 半精度
        'size': '50%',
        'speed': '1.5-2x',
        'accuracy': '99%+',
    },
    'int8': {           # INT8量化
        'size': '25%',
        'speed': '2-4x',
        'accuracy': '95-99%',
    },
}
```

#### TensorRT加速
```python
# TensorRT导出配置
TENSORRT_CONFIG = {
    'workspace': 4,        # 工作空间大小(GB)
    'simplify': True,      # 简化模型
    'dynamic': False,      # 静态输入尺寸
    'fp16': True,          # FP16精度
}
```

## 扩展架构

### 1. 模型扩展

#### 支持的YOLO版本
```python
YOLO_VERSIONS = {
    'yolo11n': 'Ultralytics YOLOv11 Nano',
    'yolo11s': 'Ultralytics YOLOv11 Small',
    'yolo11m': 'Ultralytics YOLOv11 Medium',
    'yolo11l': 'Ultralytics YOLOv11 Large',
    'yolov8n': 'Ultralytics YOLOv8 Nano',
    'yolov10n': 'Tsinghua YOLOv10 Nano (无NMS)',
}
```

#### 多模型集成
```python
class ModelEnsemble:
    """模型集成框架"""
    
    def __init__(self, models: List[str]):
        self.models = [YOLO(m) for m in models]
    
    def predict(self, image):
        """集成预测"""
        results = []
        for model in self.models:
            results.append(model.predict(image))
        
        # NMS融合
        return self.nms_fusion(results)
```

### 2. 功能扩展

#### 自定义数据增强
```python
class CustomAugmentation:
    """自定义数据增强"""
    
    def __init__(self):
        self.transforms = [
            RandomBrightness(limit=0.2),
            RandomContrast(limit=0.2),
            RandomGaussianNoise(var_limit=(10, 50)),
            # 添加更多自定义增强
        ]
    
    def __call__(self, image, bboxes):
        for transform in self.transforms:
            image, bboxes = transform(image, bboxes)
        return image, bboxes
```

#### 主动学习支持
```python
class ActiveLearning:
    """主动学习框架"""
    
    def select_hard_samples(self, unlabeled_data, model, n_samples):
        """选择难样本进行标注"""
        # 计算不确定性分数
        uncertainty_scores = []
        for sample in unlabeled_data:
            pred = model.predict(sample)
            uncertainty = self.compute_uncertainty(pred)
            uncertainty_scores.append(uncertainty)
        
        # 选择最不确定的样本
        hard_indices = np.argsort(uncertainty_scores)[-n_samples:]
        return [unlabeled_data[i] for i in hard_indices]
```

---

*最后更新: 2026年2月14日*
*架构版本: v1.0*
*技术负责人: AI系统架构组*
