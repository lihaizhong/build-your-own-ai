# Dify本地化部署和应用 - 测试和部署

## 测试策略

### 1. 单元测试

#### DifyAgentClient类测试

```python
import unittest
from unittest.mock import Mock, patch, MagicMock
from dify_agent_client import DifyAgentClient
import requests


class TestDifyAgentClient(unittest.TestCase):
    """DifyAgentClient类的单元测试"""
    
    def setUp(self):
        """测试前准备"""
        self.base_url = "https://api.dify.ai/v1"
        self.api_key = "test_api_key"
        self.client = DifyAgentClient(self.base_url, self.api_key)
    
    def test_initialization(self):
        """测试客户端初始化"""
        self.assertEqual(self.client.base_url, self.base_url)
        self.assertEqual(self.client.api_key, self.api_key)
        self.assertIn("Authorization", self.client.headers)
        self.assertIn("Bearer", self.client.headers["Authorization"])
    
    def test_url_normalization(self):
        """测试URL标准化"""
        # 带尾部斜杠的URL
        client = DifyAgentClient("https://api.dify.ai/v1/", "test_key")
        self.assertEqual(client.base_url, "https://api.dify.ai/v1")
    
    @patch('requests.post')
    def test_chat_endpoint_success(self, mock_post):
        """测试Chat端点成功响应"""
        # 模拟成功响应
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "answer": "你好！我是AI助手",
            "conversation_id": "conv_001",
            "message_id": "msg_001"
        }
        mock_post.return_value = mock_response
        
        result = self.client.chat_completion(
            user_input="你好",
            user_id="user_001",
            app_type="chat"
        )
        
        self.assertFalse(result.get("error"))
        self.assertEqual(result.get("answer"), "你好！我是AI助手")
        self.assertEqual(result.get("conversation_id"), "conv_001")
    
    @patch('requests.post')
    def test_chat_endpoint_with_conversation(self, mock_post):
        """测试带会话ID的Chat请求"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "answer": "当然记得！",
            "conversation_id": "conv_001",
            "message_id": "msg_002"
        }
        mock_post.return_value = mock_response
        
        result = self.client.chat_completion(
            user_input="你记得我刚才说了什么吗？",
            user_id="user_001",
            conversation_id="conv_001",
            app_type="chat"
        )
        
        # 验证请求中包含conversation_id
        call_args = mock_post.call_args
        self.assertIn("conversation_id", call_args.kwargs.get("json", {}))
    
    @patch('requests.post')
    def test_workflow_endpoint(self, mock_post):
        """测试Workflow端点"""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "data": {
                "outputs": {
                    "answer": "分析结果"
                }
            },
            "workflow_run_id": "wf_001"
        }
        mock_post.return_value = mock_response
        
        result = self.client.run_workflow(
            inputs={"query": "分析这段文本"},
            user_id="user_001"
        )
        
        self.assertFalse(result.get("error"))
        self.assertEqual(result.get("answer"), "分析结果")
    
    @patch('requests.post')
    def test_error_handling(self, mock_post):
        """测试错误处理"""
        mock_response = Mock()
        mock_response.status_code = 401
        mock_response.text = "Unauthorized"
        mock_post.return_value = mock_response
        
        result = self.client.chat_completion(
            user_input="测试",
            user_id="user_001",
            app_type="chat"
        )
        
        self.assertTrue(result.get("error"))
        self.assertIn("401", result.get("message"))
    
    @patch('requests.post')
    def test_auto_detection_chat(self, mock_post):
        """测试自动检测Chat类型"""
        # 第一次调用成功
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "answer": "测试回复",
            "conversation_id": "conv_001"
        }
        mock_post.return_value = mock_response
        
        result = self.client.chat_completion(
            user_input="测试",
            user_id="user_001",
            app_type="auto"
        )
        
        # 验证只调用了一次（Chat端点成功）
        self.assertEqual(mock_post.call_count, 1)
        self.assertFalse(result.get("error"))
    
    @patch('requests.post')
    def test_auto_detection_fallback(self, mock_post):
        """测试自动检测降级"""
        # 第一次调用失败（非Chat应用）
        mock_response1 = Mock()
        mock_response1.status_code = 400
        mock_response1.text = "not_chat_app"
        
        # 第二次调用成功（Completion应用）
        mock_response2 = Mock()
        mock_response2.status_code = 200
        mock_response2.json.return_value = {"answer": "成功"}
        
        mock_post.side_effect = [mock_response1, mock_response2]
        
        result = self.client.chat_completion(
            user_input="测试",
            user_id="user_001",
            app_type="auto"
        )
        
        # 验证降级到Completion端点
        self.assertEqual(mock_post.call_count, 2)
        self.assertFalse(result.get("error"))


class TestStreamingResponse(unittest.TestCase):
    """流式响应测试"""
    
    def setUp(self):
        self.client = DifyAgentClient("https://api.dify.ai/v1", "test_key")
    
    @patch('requests.post')
    def test_streaming_response(self, mock_post):
        """测试流式响应处理"""
        # 模拟SSE响应
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.iter_lines.return_value = [
            b'data: {"event": "message", "answer": "你好"}',
            b'data: {"event": "message", "answer": "，我是"}',
            b'data: {"event": "message", "answer": "AI助手"}',
            b'data: {"event": "message_end", "conversation_id": "conv_001"}'
        ]
        mock_post.return_value = mock_response
        
        result = self.client.chat_completion(
            user_input="你好",
            user_id="user_001",
            stream=True,
            app_type="chat"
        )
        
        self.assertFalse(result.get("error"))
        self.assertEqual(result.get("answer"), "你好，我是AI助手")


class TestCozeClient(unittest.TestCase):
    """CozeClient类测试"""
    
    def setUp(self):
        """测试前准备"""
        with patch.dict('os.environ', {
            'COZE_API_TOKEN': 'test_token',
            'COZE_BOT_ID': 'test_bot_id',
            'COZE_CN_BASE_URL': 'https://api.coze.cn',
            'DEFAULT_USER_ID': 'test_user'
        }):
            from coze_client import CozeClient
            self.client = CozeClient()
    
    @patch('cozepy.Coze')
    def test_chat_success(self, mock_coze):
        """测试普通聊天成功"""
        # 模拟聊天响应
        mock_chat_poll = Mock()
        mock_chat_poll.chat.status = "completed"
        
        mock_message = Mock()
        mock_message.role = "assistant"
        mock_message.content = "这是测试回复"
        mock_chat_poll.messages = [mock_message]
        
        mock_coze_instance = Mock()
        mock_coze_instance.chat.create_and_poll.return_value = mock_chat_poll
        mock_coze.return_value = mock_coze_instance
        
        response = self.client.chat("测试消息")
        
        self.assertEqual(response, "这是测试回复")


if __name__ == '__main__':
    unittest.main(verbosity=2)
```

### 2. 集成测试

#### 端到端测试

```python
import pytest
import os
from dotenv import load_dotenv


class TestIntegration:
    """集成测试"""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """测试前设置"""
        load_dotenv()
        
        self.dify_base_url = os.getenv("DIFY_BASE_URL")
        self.dify_api_key = os.getenv("DIFY_API_KEY")
        self.coze_token = os.getenv("COZE_API_TOKEN")
        self.coze_bot_id = os.getenv("COZE_BOT_ID")
    
    @pytest.mark.skipif(not os.getenv("DIFY_API_KEY"), reason="需要配置DIFY_API_KEY")
    def test_dify_chat_integration(self):
        """测试Dify Chat集成"""
        from dify_agent_client import DifyAgentClient
        
        client = DifyAgentClient(self.dify_base_url, self.dify_api_key)
        
        result = client.chat_completion(
            user_input="你好，请简单介绍一下自己",
            user_id="test_user",
            app_type="auto"
        )
        
        assert not result.get("error"), f"API调用失败: {result.get('message')}"
        assert result.get("answer"), "返回的答案为空"
    
    @pytest.mark.skipif(not os.getenv("COZE_API_TOKEN"), reason="需要配置COZE_API_TOKEN")
    def test_coze_chat_integration(self):
        """测试Coze集成"""
        from coze_client import CozeClient
        
        client = CozeClient()
        
        response = client.chat("你好，请简单介绍一下自己")
        
        assert response, "返回的答案为空"
    
    def test_multi_turn_conversation(self):
        """测试多轮对话"""
        from dify_agent_client import DifyAgentClient
        
        if not self.dify_api_key:
            pytest.skip("需要配置DIFY_API_KEY")
        
        client = DifyAgentClient(self.dify_base_url, self.dify_api_key)
        
        # 第一轮对话
        result1 = client.chat_completion(
            user_input="我叫小明",
            user_id="test_user_multi"
        )
        conversation_id = result1.get("conversation_id")
        
        # 第二轮对话
        result2 = client.chat_completion(
            user_input="你记得我的名字吗？",
            user_id="test_user_multi",
            conversation_id=conversation_id
        )
        
        assert not result2.get("error")
        assert "小明" in result2.get("answer", ""), "模型应该记住用户名字"


class TestErrorHandling:
    """错误处理测试"""
    
    def test_invalid_api_key(self):
        """测试无效API密钥"""
        from dify_agent_client import DifyAgentClient
        
        client = DifyAgentClient("https://api.dify.ai/v1", "invalid_key")
        
        result = client.chat_completion(
            user_input="测试",
            user_id="test_user"
        )
        
        assert result.get("error"), "应该返回错误"
        assert "401" in result.get("message", ""), "应该是401错误"
    
    def test_timeout_handling(self):
        """测试超时处理"""
        from dify_agent_client import DifyAgentClient
        import time
        
        client = DifyAgentClient("https://api.dify.ai/v1", "test_key")
        
        # 模拟超时场景
        start_time = time.time()
        result = client.chat_completion("测试超时")
        
        # 确保不会无限等待
        assert time.time() - start_time < 120, "请求超时时间过长"
```

### 3. 性能测试

```python
import time
import pytest
from concurrent.futures import ThreadPoolExecutor, as_completed


class TestPerformance:
    """性能测试"""
    
    def test_response_time(self):
        """测试响应时间"""
        from dify_agent_client import DifyAgentClient
        
        client = DifyAgentClient(
            os.getenv("DIFY_BASE_URL"),
            os.getenv("DIFY_API_KEY")
        )
        
        start_time = time.time()
        result = client.chat_completion("你好")
        end_time = time.time()
        
        duration = end_time - start_time
        
        assert duration < 30, f"响应时间过长: {duration:.2f}秒"
        print(f"响应时间: {duration:.2f}秒")
    
    def test_concurrent_requests(self):
        """测试并发请求"""
        from dify_agent_client import DifyAgentClient
        
        client = DifyAgentClient(
            os.getenv("DIFY_BASE_URL"),
            os.getenv("DIFY_API_KEY")
        )
        
        def send_request(i):
            return client.chat_completion(f"测试消息 {i}")
        
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(send_request, i) for i in range(10)]
            results = [f.result() for f in as_completed(futures)]
        
        end_time = time.time()
        
        success_count = sum(1 for r in results if not r.get("error"))
        
        print(f"并发请求: 10个")
        print(f"成功: {success_count}个")
        print(f"总耗时: {end_time - start_time:.2f}秒")
        
        assert success_count >= 8, "并发请求成功率过低"
```

## 部署策略

### 1. Docker容器化部署

#### Dockerfile

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY code/ ./code/

# 设置环境变量
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "from code.dify_agent_client import DifyAgentClient; print('OK')" || exit 1

# 默认命令
CMD ["python", "code/dify_workflow_example.py"]
```

#### Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  dify-client:
    build: .
    container_name: dify-client
    environment:
      - DIFY_BASE_URL=${DIFY_BASE_URL}
      - DIFY_API_KEY=${DIFY_API_KEY}
      - COZE_API_TOKEN=${COZE_API_TOKEN}
      - COZE_BOT_ID=${COZE_BOT_ID}
      - DEFAULT_USER_ID=${DEFAULT_USER_ID:-default_user}
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "print('OK')"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### 2. Kubernetes部署

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dify-client
  labels:
    app: dify-client
spec:
  replicas: 2
  selector:
    matchLabels:
      app: dify-client
  template:
    metadata:
      labels:
        app: dify-client
    spec:
      containers:
      - name: dify-client
        image: dify-client:latest
        env:
        - name: DIFY_BASE_URL
          valueFrom:
            secretKeyRef:
              name: dify-secrets
              key: base-url
        - name: DIFY_API_KEY
          valueFrom:
            secretKeyRef:
              name: dify-secrets
              key: api-key
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          exec:
            command:
            - python
            - -c
            - print('OK')
          initialDelaySeconds: 30
          periodSeconds: 30

---
apiVersion: v1
kind: Secret
metadata:
  name: dify-secrets
type: Opaque
stringData:
  base-url: "https://api.dify.ai/v1"
  api-key: "your_api_key_here"
```

### 3. 环境配置管理

#### 开发环境

```bash
# .env.development
DIFY_BASE_URL=https://api.dify.ai/v1
DIFY_API_KEY=dev_api_key

COZE_API_TOKEN=dev_token
COZE_BOT_ID=dev_bot_id
COZE_CN_BASE_URL=https://api.coze.cn

DEFAULT_USER_ID=dev_user
LOG_LEVEL=DEBUG
```

#### 生产环境

```bash
# .env.production
DIFY_BASE_URL=https://api.dify.ai/v1
DIFY_API_KEY=prod_api_key

COZE_API_TOKEN=prod_token
COZE_BOT_ID=prod_bot_id
COZE_CN_BASE_URL=https://api.coze.cn

DEFAULT_USER_ID=default_user
LOG_LEVEL=INFO
```

## 监控和日志

### 1. 日志配置

```python
# logging_config.py
import logging
import logging.config

LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
        },
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(lineno)d: %(message)s'
        },
    },
    'handlers': {
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'standard'
        },
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'formatter': 'detailed',
            'filename': '/app/logs/app.log',
            'maxBytes': 10485760,
            'backupCount': 5
        }
    },
    'loggers': {
        '': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False
        }
    }
}

def setup_logging():
    logging.config.dictConfig(LOGGING_CONFIG)
```

### 2. 性能监控

```python
# monitoring.py
import time
import logging
from functools import wraps

logger = logging.getLogger(__name__)

def monitor_performance(func):
    """性能监控装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"{func.__name__} 执行成功，耗时: {duration:.2f}秒")
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"{func.__name__} 执行失败，耗时: {duration:.2f}秒，错误: {e}")
            raise
    return wrapper
```

### 3. 健康检查

```python
# health_check.py
import os
from dify_agent_client import DifyAgentClient
from coze_client import CozeClient

def check_dify_health():
    """检查Dify连接健康状态"""
    try:
        client = DifyAgentClient(
            os.getenv("DIFY_BASE_URL"),
            os.getenv("DIFY_API_KEY")
        )
        result = client.chat_completion("健康检查", user_id="health_check")
        return not result.get("error")
    except Exception:
        return False

def check_coze_health():
    """检查Coze连接健康状态"""
    try:
        client = CozeClient()
        info = client.get_bot_info()
        return info is not None
    except Exception:
        return False

def health_check():
    """完整健康检查"""
    return {
        "dify": check_dify_health(),
        "coze": check_coze_health(),
        "status": "healthy" if all([check_dify_health(), check_coze_health()]) else "unhealthy"
    }
```

## CI/CD流水线

### GitHub Actions配置

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.11, 3.12]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov flake8
    
    - name: Lint with flake8
      run: |
        flake8 code/ --count --select=E9,F63,F7,F82 --show-source --statistics
    
    - name: Run tests
      run: |
        pytest tests/ --cov=code --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: |
        docker build -t dify-client:${{ github.sha }} .
        docker tag dify-client:${{ github.sha }} dify-client:latest
```

## 部署验证

### 验证脚本

```python
# validate_deployment.py
import requests
import time
import logging

logger = logging.getLogger(__name__)

def validate_dify_connection():
    """验证Dify连接"""
    from dify_agent_client import DifyAgentClient
    import os
    
    client = DifyAgentClient(
        os.getenv("DIFY_BASE_URL"),
        os.getenv("DIFY_API_KEY")
    )
    
    result = client.chat_completion("部署验证测试")
    
    if result.get("error"):
        logger.error(f"❌ Dify连接验证失败: {result.get('message')}")
        return False
    
    logger.info("✅ Dify连接验证成功")
    return True

def validate_deployment():
    """完整部署验证"""
    logger.info("开始部署验证...")
    
    checks = [
        ("Dify连接", validate_dify_connection),
    ]
    
    results = []
    for name, check_func in checks:
        try:
            result = check_func()
            results.append((name, result))
        except Exception as e:
            logger.error(f"❌ {name}验证异常: {e}")
            results.append((name, False))
    
    # 打印结果
    logger.info("=" * 50)
    logger.info("部署验证结果:")
    for name, result in results:
        status = "✅ 通过" if result else "❌ 失败"
        logger.info(f"  {name}: {status}")
    logger.info("=" * 50)
    
    return all(result for _, result in results)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    success = validate_deployment()
    exit(0 if success else 1)
```

---

*最后更新: 2026年2月21日*
*测试和部署版本: v1.0*
*运维团队: DevOps运维组*
