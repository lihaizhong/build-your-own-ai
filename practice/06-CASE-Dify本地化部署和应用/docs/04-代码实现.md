# Difyæœ¬åœ°åŒ–éƒ¨ç½²å’Œåº”ç”¨ - ä»£ç å®ç°è¯¦è§£

## æ ¸å¿ƒä»£ç ç»“æ„

### 1. é¡¹ç›®æ–‡ä»¶ç»„ç»‡

```
code/
â”œâ”€â”€ dify_agent_client.py      # Dify APIå®¢æˆ·ç«¯æ ¸å¿ƒå®ç°
â”œâ”€â”€ dify_workflow_example.py  # å·¥ä½œæµè°ƒç”¨ç¤ºä¾‹
â””â”€â”€ coze_client.py            # Coze APIå®¢æˆ·ç«¯å®ç°
```

### 2. æ¨¡å—ä¾èµ–å…³ç³»

```mermaid
graph TD
    A[dify_workflow_example.py] --> B[dify_agent_client.py]
    B --> C[requests]
    B --> D[python-dotenv]
    E[coze_client.py] --> F[cozepy]
    E --> D
```

## DifyAgentClientç±»è¯¦è§£

### 1. åˆå§‹åŒ–æ–¹æ³•

```python
class DifyAgentClient:
    """Dify Agent API å®¢æˆ·ç«¯ç±»"""
    
    def __init__(self, base_url: str, api_key: str):
        """
        åˆå§‹åŒ– Dify Agent å®¢æˆ·ç«¯
        
        Args:
            base_url: Dify API çš„åŸºç¡€ URL
            api_key: åº”ç”¨çš„ API å¯†é’¥
        """
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
```

**è®¾è®¡è¦ç‚¹ï¼š**
- **URLæ ‡å‡†åŒ–**: ä½¿ç”¨`rstrip("/")`ç§»é™¤å°¾éƒ¨æ–œæ ï¼Œç¡®ä¿URLæ‹¼æ¥æ­£ç¡®
- **è¯·æ±‚å¤´å°è£…**: ç»Ÿä¸€è®¾ç½®è®¤è¯å’Œå†…å®¹ç±»å‹å¤´
- **é…ç½®é›†ä¸­**: æ‰€æœ‰é…ç½®é›†ä¸­åœ¨åˆå§‹åŒ–æ–¹æ³•ä¸­

### 2. æ ¸å¿ƒèŠå¤©æ–¹æ³•

```python
def chat_completion(
    self,
    user_input: str,
    user_id: str = "default_usr",
    conversation_id: Optional[str] = None,
    stream: bool = False,
    app_type: str = "auto"
) -> Dict[str, Any]:
    """
    è°ƒç”¨ Dify Agent è¿›è¡Œå¯¹è¯
    
    Args:
        user_input: ç”¨æˆ·è¾“å…¥çš„æ¶ˆæ¯
        user_id: ç”¨æˆ·ID
        conversation_id: ä¼šè¯ IDï¼Œç”¨äºç»´æŒå¯¹è¯ä¸Šä¸‹æ–‡
        stream: æ˜¯å¦ä½¿ç”¨æµå¼å“åº”
        app_type: åº”ç”¨ç±»å‹ï¼Œæ”¯æŒ "chat"ã€"completion"ã€"workflow" æˆ– "auto"
    
    Returns:
        API å“åº”ç»“æœ
    """
```

**åŠŸèƒ½ç‰¹ç‚¹ï¼š**
- **è‡ªåŠ¨æ£€æµ‹**: æ”¯æŒè‡ªåŠ¨æ£€æµ‹åº”ç”¨ç±»å‹
- **å¤šç«¯ç‚¹æ”¯æŒ**: æ”¯æŒChatã€Completionã€Workflowä¸‰ç§ç«¯ç‚¹
- **æµå¼æ”¯æŒ**: æ”¯æŒé˜»å¡å¼å’Œæµå¼ä¸¤ç§å“åº”æ¨¡å¼
- **ä¼šè¯ç®¡ç†**: æ”¯æŒå¤šè½®å¯¹è¯çš„ä¼šè¯ä¸Šä¸‹æ–‡

## å¤šç«¯ç‚¹é€‚é…å®ç°

### 1. è‡ªåŠ¨æ£€æµ‹æœºåˆ¶

```python
def chat_completion(self, user_input: str, app_type: str = "auto"):
    if app_type == "auto":
        # å…ˆå°è¯• chat ç«¯ç‚¹
        result = self._try_chat_endpoint(user_input, user_id, conversation_id, stream)
        
        # å¦‚æœå¤±è´¥ä¸”æ˜¯"éèŠå¤©åº”ç”¨"é”™è¯¯ï¼Œåˆ‡æ¢åˆ° completion ç«¯ç‚¹
        if result.get("error") and "not_chat_app" in str(result.get("message", "")):
            print("æ£€æµ‹åˆ°éèŠå¤©åº”ç”¨ï¼Œåˆ‡æ¢åˆ° completion ç«¯ç‚¹...")
            result = self._try_completion_endpoint(user_input, user_id, stream)
            
            # å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯• workflow ç«¯ç‚¹
            if result.get("error") and "app_unavailable" in str(result.get("message", "")):
                print("æ£€æµ‹åˆ°éå®Œæˆåº”ç”¨ï¼Œåˆ‡æ¢åˆ°å·¥ä½œæµç«¯ç‚¹...")
                result = self._try_workflow_endpoint(user_input, user_id, stream)
        
        return result
```

**é™çº§ç­–ç•¥ï¼š**
1. é¦–å…ˆå°è¯•Chatç«¯ç‚¹ï¼ˆæœ€å¸¸ç”¨çš„åº”ç”¨ç±»å‹ï¼‰
2. å¦‚æœè¿”å›"not_chat_app"é”™è¯¯ï¼Œé™çº§åˆ°Completionç«¯ç‚¹
3. å¦‚æœè¿”å›"app_unavailable"é”™è¯¯ï¼Œé™çº§åˆ°Workflowç«¯ç‚¹

### 2. Chatç«¯ç‚¹å®ç°

```python
def _try_chat_endpoint(
    self,
    user_input: str,
    user_id: str,
    conversation_id: Optional[str],
    stream: bool
) -> Dict[str, Any]:
    """å°è¯•ä½¿ç”¨ chat ç«¯ç‚¹"""
    url = f"{self.base_url}/chat-messages"
    
    # æ„å»ºè¯·æ±‚ä½“
    payload = {
        "inputs": {},
        "query": user_input,
        "response_mode": "streaming" if stream else "blocking",
        "user": user_id
    }
    
    # åªæœ‰å½“ conversation_id å­˜åœ¨æ—¶æ‰æ·»åŠ 
    if conversation_id:
        payload["conversation_id"] = conversation_id
    
    try:
        if stream:
            return self._handle_streaming_response(url, payload)
        else:
            return self._handle_blocking_response(url, payload)
    except requests.exceptions.RequestException as e:
        return {
            "error": True,
            "message": f"è¯·æ±‚å¤±è´¥ï¼š{str(e)}"
        }
```

**å…³é”®å®ç°ï¼š**
- **æ¡ä»¶å‚æ•°**: `conversation_id`ä»…åœ¨å­˜åœ¨æ—¶æ·»åŠ ï¼Œé¿å…ä¼ é€’Noneæˆ–ç©ºå­—ç¬¦ä¸²
- **å“åº”æ¨¡å¼**: æ ¹æ®`stream`å‚æ•°é€‰æ‹©é˜»å¡å¼æˆ–æµå¼å“åº”
- **å¼‚å¸¸æ•è·**: æ•è·ç½‘ç»œè¯·æ±‚å¼‚å¸¸å¹¶è¿”å›ç»Ÿä¸€æ ¼å¼çš„é”™è¯¯ä¿¡æ¯

### 3. Completionç«¯ç‚¹å®ç°

```python
def _try_completion_endpoint(
    self,
    user_input: str,
    user_id: str,
    stream: bool
) -> Dict[str, Any]:
    """å°è¯•ä½¿ç”¨ completion ç«¯ç‚¹"""
    url = f"{self.base_url}/completions-messages"
    
    # æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼Œcompletion ç«¯ç‚¹çš„æ­£ç¡®æ ¼å¼
    payload = {
        "inputs": {},  # ç©ºå¯¹è±¡ï¼Œä¸æ˜¯åŒ…å« query çš„å¯¹è±¡
        "response_mode": "streaming" if stream else "blocking",
        "user": user_id
    }
    
    try:
        if stream:
            return self._handle_streaming_response(url, payload)
        else:
            return self._handle_blocking_response(url, payload)
    except requests.exceptions.RequestException as e:
        return {
            "error": True,
            "message": f"è¯·æ±‚å¤±è´¥ï¼š{str(e)}"
        }
```

**æ³¨æ„äº‹é¡¹ï¼š**
- Completionç«¯ç‚¹çš„`inputs`å­—æ®µæ˜¯ç©ºå¯¹è±¡ï¼Œä¸Chatç«¯ç‚¹ä¸åŒ
- ä¸æ”¯æŒ`conversation_id`ï¼ˆå•è½®å¯¹è¯ï¼‰
- é”™è¯¯å¤„ç†ä¸Chatç«¯ç‚¹ä¸€è‡´

### 4. Workflowç«¯ç‚¹å®ç°

```python
def _try_workflow_endpoint(
    self,
    user_input: str,
    user_id: str,
    stream: bool
) -> Dict[str, Any]:
    """å°è¯•ä½¿ç”¨ workflow ç«¯ç‚¹"""
    url = f"{self.base_url}/workflows/run"
    
    # å·¥ä½œæµç«¯ç‚¹çš„ payload æ ¼å¼
    payload = {
        "inputs": {"query": user_input},  # å·¥ä½œæµé€šå¸¸éœ€è¦åœ¨ inputs ä¸­ä¼ é€’å‚æ•°
        "response_mode": "stream" if stream else "blocking",
        "user": user_id
    }
    
    try:
        if stream:
            return self._handle_workflow_streaming_response(url, payload)
        else:
            return self._handle_workflow_blocking_response(url, payload)
    except requests.exceptions.RequestException as e:
        return {
            "error": True,
            "message": f"è¯·æ±‚å¤±è´¥ï¼š{str(e)}"
        }
```

**å·®å¼‚ç‚¹ï¼š**
- Workflowç«¯ç‚¹çš„è·¯å¾„æ˜¯`/workflows/run`
- `inputs`å‚æ•°æ ¼å¼ä¸åŒï¼Œéœ€è¦åŒ…å«å…·ä½“çš„å·¥ä½œæµè¾“å…¥å‚æ•°
- å“åº”å¤„ç†æ–¹æ³•ä¸åŒï¼ˆä¸“é—¨çš„Workflowå“åº”å¤„ç†æ–¹æ³•ï¼‰

## å“åº”å¤„ç†è¯¦è§£

### 1. é˜»å¡å¼å“åº”å¤„ç†

```python
def _handle_blocking_response(
    self,
    url: str,
    payload: Dict[str, Any]
) -> Dict[str, Any]:
    """å¤„ç†é˜»å¡å¼å“åº”"""
    try:
        response = requests.post(url, headers=self.headers, json=payload, timeout=60)
        
        # è°ƒè¯•ä¿¡æ¯
        print(f"è¯·æ±‚URL: {url}")
        print(f"å“åº”çŠ¶æ€ç : {response.status_code}")
        
        if response.status_code != 200:
            print(f"å“åº”æ•°æ®: {response.text}")
            return {
                "error": True,
                "message": f"HTTP {response.status_code}: {response.text}"
            }
        
        result = response.json()
        return {
            "error": False,
            "data": result,
            "answer": result.get("answer", ""),
            "conversation_id": result.get("conversation_id", ""),
            "message_id": result.get("message_id", "")
        }
    except requests.exceptions.RequestException as e:
        return {
            "error": True,
            "message": f"ç½‘ç»œè¯·æ±‚å¼‚å¸¸ï¼š{str(e)}"
        }
    except json.JSONDecodeError as e:
        return {
            "error": True,
            "message": f"JSON è§£æå¼‚å¸¸ï¼š{str(e)}"
        }
```

**å¤„ç†æµç¨‹ï¼š**
1. å‘é€HTTP POSTè¯·æ±‚
2. æ£€æŸ¥å“åº”çŠ¶æ€ç 
3. è§£æJSONå“åº”
4. æå–å…³é”®å­—æ®µï¼ˆanswerã€conversation_idã€message_idï¼‰
5. å¼‚å¸¸æ•è·å’Œå¤„ç†

### 2. æµå¼å“åº”å¤„ç†

```python
def _handle_streaming_response(
    self,
    url: str,
    payload: Dict[str, Any]
) -> Dict[str, Any]:
    """å¤„ç†æµå¼å“åº”"""
    try:
        response = requests.post(url, headers=self.headers, json=payload, stream=True, timeout=60)
        
        if response.status_code != 200:
            return {
                "error": True,
                "message": f"HTTP {response.status_code}: {response.text}"
            }
        
        full_answer = ""
        conversation_id = ""
        message_id = ""
        
        # éå†SSEæ•°æ®æµ
        for line in response.iter_lines():
            if line:
                line = line.decode("utf-8")
                if line.startswith("data: "):
                    try:
                        data = json.loads(line[6:])
                        if data.get("event") == "message":
                            full_answer += data.get("answer", "")
                        elif data.get("event") == "message_id":
                            conversation_id = data.get("conversation_id", "")
                            message_id = data.get("id", "")
                    except json.JSONDecodeError:
                        continue
        
        return {
            "error": False,
            "answer": full_answer,
            "conversation_id": conversation_id,
            "message_id": message_id
        }
    except requests.exceptions.RequestException as e:
        return {
            "error": True,
            "message": f"ç½‘ç»œè¯·æ±‚å¼‚å¸¸ï¼š{str(e)}"
        }
```

**SSEæ•°æ®æ ¼å¼ï¼š**
```
data: {"event": "message", "answer": "ä½ å¥½"}
data: {"event": "message", "answer": "ï¼Œ"}
data: {"event": "message", "answer": "æˆ‘æ˜¯"}
data: {"event": "message_end", "conversation_id": "xxx", "id": "yyy"}
```

### 3. Workflowå“åº”å¤„ç†

```python
def _handle_workflow_blocking_response(
    self,
    url: str,
    payload: Dict[str, Any]
) -> Dict[str, Any]:
    """å¤„ç†å·¥ä½œæµé˜»å¡å¼å“åº”"""
    try:
        response = requests.post(url, headers=self.headers, json=payload, timeout=60)
        
        if response.status_code != 200:
            return {
                "error": True,
                "message": f"HTTP {response.status_code}: {response.text}"
            }
        
        result = response.json()
        outputs = result.get("data", {}).get("outputs", {})
        
        # å°è¯•ä» outputs ä¸­æå–ç­”æ¡ˆ
        answer = ""
        if isinstance(outputs, dict):
            # å¸¸è§çš„è¾“å‡ºå­—æ®µå
            for key in ["answer", "result", "output", "text", "response"]:
                if key in outputs:
                    answer = str(outputs[key])
                    break
            
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå€¼
            if not answer and outputs:
                answer = str(list(outputs.values())[0])
        
        return {
            "error": False,
            "data": result,
            "answer": answer,
            "outputs": outputs,
            "workflow_run_id": result.get("workflow_run_id", ""),
            "task_id": result.get("task_id", "")
        }
    except Exception as e:
        return {
            "error": True,
            "message": f"å¤„ç†å“åº”æ—¶å‡ºé”™ï¼š{str(e)}"
        }
```

**å“åº”ç»“æ„å·®å¼‚ï¼š**
- Workflowå“åº”çš„æ•°æ®åœ¨`data.outputs`ä¸­
- è¾“å‡ºå­—æ®µåå¯èƒ½å› å·¥ä½œæµé…ç½®ä¸åŒè€Œå˜åŒ–
- éœ€è¦å°è¯•å¤šç§å¯èƒ½çš„å­—æ®µå

## CozeClientç±»è¯¦è§£

### 1. åˆå§‹åŒ–æ–¹æ³•

```python
class CozeClient:
    """åŸºäº cozepy çš„ Coze API å®¢æˆ·ç«¯ç±»"""

    def __init__(self, api_token: str = None, bot_id: str = None, base_url: str = None):
        """
        åˆå§‹åŒ– Coze å®¢æˆ·ç«¯
        
        Args:
            api_token: Coze API token
            bot_id: æ™ºèƒ½ä½“ ID
            base_url: API åŸºç¡€ URL
        """
        self.api_token = api_token or os.getenv("COZE_API_TOKEN")
        self.bot_id = bot_id or os.getenv("COZE_BOT_ID")
        self.base_url = base_url or os.getenv("COZE_CN_BASE_URL")

        # åˆå§‹åŒ– Coze å®¢æˆ·ç«¯
        self.coze = Coze(
            auth=TokenAuth(token=self.api_token),
            base_url=self.base_url
        )
```

**ç‰¹ç‚¹ï¼š**
- ä½¿ç”¨å®˜æ–¹SDKï¼ˆcozepyï¼‰
- æ”¯æŒç¯å¢ƒå˜é‡é…ç½®
- åˆå§‹åŒ–æ—¶æ‰“å°é…ç½®ä¿¡æ¯ä¾¿äºè°ƒè¯•

### 2. æµå¼èŠå¤©å®ç°

```python
def chat_stream(self, message: str, user_id: str = None) -> Generator[str, None, None]:
    """
    æµå¼èŠå¤©ï¼Œå®æ—¶è¿”å›æ™ºèƒ½ä½“çš„å›å¤
    
    Args:
        message: ç”¨æˆ·æ¶ˆæ¯
        user_id: ç”¨æˆ·ID
    
    Yield:
        æ™ºèƒ½ä½“å›å¤çš„æ–‡æœ¬ç‰‡æ®µ
    """
    user_id = user_id or os.getenv("DEFAULT_USER_ID")

    try:
        # åˆ›å»ºæµå¼èŠå¤©
        for event in self.coze.chat.stream(
            bot_id=self.bot_id,
            user_id=user_id,
            additional_messages=[Message.build_user_question_text(message)],
        ):
            # å¤„ç†æ¶ˆæ¯å¢é‡äº‹ä»¶
            if event.event == ChatEventType.CONVERSATION_MESSAGE_DELTA:
                # æ£€æŸ¥æ¶ˆæ¯å†…å®¹æ˜¯å¦å­˜åœ¨ä¸”ä¸ºæ–‡æœ¬ç±»å‹
                if (
                    hasattr(event.message, "content") and
                    event.message.content and
                    hasattr(event.message.content, "type") and
                    event.message.content.type == MessageContentType.TEXT
                ):
                    yield event.message.content.text
    except Exception as e:
        print(f"âŒ æµå¼èŠå¤©å‘ç”Ÿé”™è¯¯: {e}")
        yield f"é”™è¯¯: {str(e)}"
```

**å®ç°è¦ç‚¹ï¼š**
- ä½¿ç”¨ç”Ÿæˆå™¨æ¨¡å¼è¿”å›æµå¼æ•°æ®
- æ­£ç¡®å¤„ç†SDKè¿”å›çš„äº‹ä»¶ç±»å‹
- å®Œå–„çš„é”™è¯¯å¤„ç†

### 3. æ™®é€šèŠå¤©å®ç°

```python
def chat(self, message: str, user_id: str = None) -> Optional[str]:
    """
    æ™®é€šèŠå¤©ï¼Œè¿”å›å®Œæ•´çš„æ™ºèƒ½ä½“å›å¤
    
    Args:
        message: ç”¨æˆ·æ¶ˆæ¯
        user_id: ç”¨æˆ·ID
    
    Returns:
        æ™ºèƒ½ä½“çš„å®Œæ•´å›å¤
    """
    user_id = user_id or os.getenv("DEFAULT_USER_ID")

    try:
        # ä½¿ç”¨ create_and_poll æ–¹æ³•
        chat_poll = self.coze.chat.create_and_poll(
            bot_id=self.bot_id,
            user_id=user_id,
            additional_messages=[Message.build_user_question_text(message)],
        )

        # æ£€æŸ¥èŠå¤©çŠ¶æ€
        if chat_poll.chat.status == ChatStatus.COMPLETED:
            # ä»æ¶ˆæ¯åˆ—è¡¨ä¸­æå–åŠ©æ‰‹çš„å›å¤
            for msg in chat_poll.messages:
                if msg.role == "assistant" and msg.content:
                    return msg.content
            
            return "æ™ºèƒ½ä½“æ²¡æœ‰å›å¤å†…å®¹"
        else:
            return f"èŠå¤©æœªå®Œæˆï¼ŒçŠ¶æ€ï¼š{chat_poll.chat.status}"

    except Exception as e:
        print(f"âŒ èŠå¤©å‘ç”Ÿé”™è¯¯: {e}")
        return None
```

### 4. äº¤äº’å¼èŠå¤©å®ç°

```python
def interactive_chat():
    """äº¤äº’å¼èŠå¤©å‡½æ•°"""
    print("ğŸš€ Cozeæ™ºèƒ½ä½“äº¤äº’å¼èŠå¤©å¯åŠ¨ï¼")
    print("ğŸ’¡ è¾“å…¥ 'quit' æˆ– 'exit' é€€å‡ºç¨‹åº")
    print("ğŸ’¡ è¾“å…¥ 'stream' åˆ‡æ¢åˆ°æµå¼æ¨¡å¼")
    print("ğŸ’¡ è¾“å…¥ 'normal' åˆ‡æ¢åˆ°æ™®é€šæ¨¡å¼")
    print("ğŸ’¡ è¾“å…¥ 'info' æŸ¥çœ‹æ™ºèƒ½ä½“ä¿¡æ¯")
    
    client = CozeClient()
    stream_mode = False
    
    while True:
        try:
            user_input = input(f"\n{'[æµå¼]' if stream_mode else '[æ™®é€š]'} è¯·è¾“å…¥æ‚¨çš„é—®é¢˜: ").strip()
            
            if user_input.lower() in ["quit", "exit", "é€€å‡º"]:
                print("ğŸ‘‹ å†è§ï¼")
                break
            
            if user_input.lower() == "stream":
                stream_mode = True
                continue
            
            if user_input.lower() == "normal":
                stream_mode = False
                continue
            
            if stream_mode:
                for chunk in client.chat_stream(user_input):
                    print(chunk, end="", flush=True)
                print()
            else:
                response = client.chat(user_input)
                if response:
                    print(f"ğŸ¤– æ™ºèƒ½ä½“: {response}")
        except KeyboardInterrupt:
            print("\nğŸ‘‹ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­ï¼Œå†è§ï¼")
            break
```

## é”™è¯¯å¤„ç†å’Œè°ƒè¯•æœºåˆ¶

### 1. ç»Ÿä¸€é”™è¯¯æ ¼å¼

```python
# æˆåŠŸå“åº”æ ¼å¼
{
    "error": False,
    "data": {...},
    "answer": "...",
    "conversation_id": "...",
    "message_id": "..."
}

# é”™è¯¯å“åº”æ ¼å¼
{
    "error": True,
    "message": "é”™è¯¯æè¿°ä¿¡æ¯"
}
```

### 2. è°ƒè¯•ä¿¡æ¯è¾“å‡º

```python
def _handle_blocking_response(self, url: str, payload: Dict[str, Any]):
    # æ‰“å°è°ƒè¯•ä¿¡æ¯
    print(f"è¯·æ±‚URL: {url}")
    print(f"è¯·æ±‚å¤´: {self.headers}")
    print(f"è¯·æ±‚ä½“: {json.dumps(payload, ensure_ascii=False, indent=2)}")
    print(f"å“åº”çŠ¶æ€ç : {response.status_code}")
    
    if response.status_code != 200:
        print(f"å“åº”æ•°æ®: {response.text}")
```

### 3. å¼‚å¸¸æ•è·ç­–ç•¥

```python
try:
    # APIè°ƒç”¨
    response = requests.post(url, headers=headers, json=payload, timeout=60)
except requests.exceptions.Timeout:
    return {"error": True, "message": "è¯·æ±‚è¶…æ—¶"}
except requests.exceptions.ConnectionError:
    return {"error": True, "message": "ç½‘ç»œè¿æ¥é”™è¯¯"}
except requests.exceptions.RequestException as e:
    return {"error": True, "message": f"è¯·æ±‚å¤±è´¥ï¼š{str(e)}"}
except json.JSONDecodeError as e:
    return {"error": True, "message": f"JSONè§£æé”™è¯¯ï¼š{str(e)}"}
except Exception as e:
    return {"error": True, "message": f"æœªçŸ¥é”™è¯¯ï¼š{str(e)}"}
```

---

*æœ€åæ›´æ–°: 2026å¹´2æœˆ21æ—¥*
*ä»£ç å®ç°ç‰ˆæœ¬: v1.0*
*å¼€å‘å›¢é˜Ÿ: AIç³»ç»Ÿå¼€å‘ç»„*
