# RAG问答系统 - 使用指南

## 环境准备

### 系统要求

- **操作系统**: macOS / Linux / Windows
- **Python版本**: 3.11+
- **内存**: 建议 4GB 以上
- **网络**: 需要访问 DashScope API

### 依赖安装

#### 1. 进入项目目录
```bash
cd /Users/lihaizhong/Documents/Project/build-your-own-x/build-your-own-ai/practice/15-CASE-创建RAG问答
```

#### 2. 创建虚拟环境
```bash
# 使用uv创建虚拟环境
uv venv --python 3.11

# 激活虚拟环境
source .venv/bin/activate  # Linux/macOS
# 或
.venv\Scripts\activate     # Windows
```

#### 3. 安装项目依赖
```bash
# 同步所有依赖
uv sync

# 验证安装
python -c "import langchain; print(f'LangChain版本: {langchain.__version__}')"
python -c "import faiss; print(f'FAISS安装成功')"
```

### API密钥配置

#### 1. 获取DashScope API密钥

1. 访问 [阿里云DashScope控制台](https://dashscope.console.aliyun.com/)
2. 注册并登录阿里云账号
3. 创建API密钥并复制

#### 2. 配置环境变量

**方法一：使用.env文件（推荐）**
```bash
# 在项目根目录创建.env文件
cat > .env << 'EOF'
DASHSCOPE_API_KEY=sk-your-api-key-here
EOF
```

**方法二：设置系统环境变量**
```bash
# Linux/macOS
export DASHSCOPE_API_KEY=sk-your-api-key-here

# Windows PowerShell
$env:DASHSCOPE_API_KEY="sk-your-api-key-here"
```

#### 3. 验证API配置
```bash
# 运行测试验证API配置
uv run python test_system.py
```

## 快速开始

### 5分钟快速体验

```bash
# 1. 确保在项目目录
cd practice/15-CASE-创建RAG问答

# 2. 激活环境
source .venv/bin/activate

# 3. 启动系统
uv run python code/main.py

# 4. 选择交互式问答模式
# 输入 1 进入交互模式

# 5. 开始提问
# 例如: 产品经理需要具备哪些核心能力？
```

### 完整运行流程

```
┌─────────────────────────────────────────────────────────┐
│                    步骤1: 启动系统                       │
│  $ uv run python code/main.py                           │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                    步骤2: 选择模式                       │
│  请选择运行模式:                                         │
│  1. 交互式问答模式                                       │
│  2. 自动测试模式                                         │
│  3. 退出                                                 │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                    步骤3: 系统初始化                     │
│  • 加载PDF文档...                                       │
│  • 创建向量数据库...                                     │
│  • 初始化LLM模型...                                      │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                    步骤4: 开始问答                       │
│  请输入您的问题: 产品经理需要具备哪些核心能力？           │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                    步骤5: 获取回答                       │
│  正在检索相关文档...                                     │
│  正在生成回答...                                         │
│                                                          │
│  回答: 产品经理需要具备以下核心能力...                   │
│  来源: 页码5, 页码12...                                  │
└─────────────────────────────────────────────────────────┘
```

## 交互式问答模式

### 启动交互模式

```bash
# 方式1: 通过菜单选择
uv run python code/main.py
# 然后选择 "1. 交互式问答模式"

# 方式2: 直接指定模式
uv run python code/main.py --mode interactive
```

### 交互操作指南

#### 基本操作
```
============================================================
RAG问答系统已就绪！
============================================================
提示: 输入 'quit' 或 'exit' 退出系统
------------------------------------------------------------

请输入您的问题: 产品经理需要具备哪些核心能力？

正在检索与'产品经理需要具备哪些核心能力？'相关的文档...
正在生成回答...

============================================================
问题: 产品经理需要具备哪些核心能力？
============================================================
回答: 根据文档内容，产品经理需要具备以下核心能力：

1. 产品规划能力：能够制定产品战略和路线图
2. 用户洞察能力：深入理解用户需求和行为
3. 数据分析能力：基于数据驱动产品决策
4. 项目管理能力：协调资源推动项目落地
5. 沟通协调能力：与各方有效沟通协作

来源文档:

1. 页码: 5, 来源: AI产品经理面试题65道.pdf
   内容: 产品经理的核心能力包括产品规划、用户洞察...

2. 页码: 12, 来源: AI产品经理面试题65道.pdf
   内容: 数据分析是产品经理必备的技能之一...

请输入您的问题: 
```

#### 退出系统
```
请输入您的问题: quit
感谢使用RAG问答系统，再见！
```

### 常见问题示例

#### 1. 产品能力类问题
```
请输入您的问题: 产品经理需要具备哪些核心能力？
请输入您的问题: 如何进行用户需求分析？
请输入您的问题: 产品设计的基本原则是什么？
```

#### 2. 方法论类问题
```
请输入您的问题: 如何制定产品路线图？
请输入您的问题: 产品迭代的基本流程是什么？
请输入您的问题: 如何进行竞品分析？
```

#### 3. 数据分析类问题
```
请输入您的问题: 如何定义产品关键指标？
请输入您的问题: 如何进行A/B测试？
请输入您的问题: 数据分析在产品中的应用场景有哪些？
```

## 自动测试模式

### 运行测试模式

```bash
# 方式1: 通过菜单选择
uv run python code/main.py
# 然后选择 "2. 自动测试模式"

# 方式2: 直接指定模式
uv run python code/main.py --mode test
```

### 测试输出示例

```
============================================================
RAG系统功能测试
============================================================

============================================================
创建完整的RAG问答系统
============================================================

1. 加载PDF文档并处理页码...
成功加载 68 个文档块
文档统计信息:
  total_documents: 68
  total_pages: 17
  total_characters: 25432
  pdf_file: AI产品经理面试题65道.pdf

2. 分割文档...
分割后得到 45 个文档块

3. 创建向量数据库...
向量数据库创建成功

4. 初始化DashScope LLM...
DashScope LLM初始化成功

5. 创建检索器...
RAG系统创建完成！

============================================================
测试 1: 产品经理需要具备哪些核心能力？
============================================================
正在检索与'产品经理需要具备哪些核心能力？'相关的文档...
正在生成回答...

回答: [AI生成的详细回答...]

来源文档:
1. 页码: 5, 来源: AI产品经理面试题65道.pdf
...

============================================================
RAG系统测试完成！
============================================================
```

## 自定义文档处理

### 使用自定义PDF文档

#### 方法1: 命令行参数指定
```bash
# 使用绝对路径
uv run python code/main.py --pdf /path/to/your/document.pdf

# 使用相对路径
uv run python code/main.py --pdf ./data/custom.pdf

# 使用~路径
uv run python code/main.py --pdf ~/Documents/knowledge.pdf
```

#### 方法2: 修改代码配置
```python
# 编辑 code/main.py 文件
# 修改 PDF_FILE_PATH 变量

PDF_FILE_PATH = str(Path(__file__).parent.parent / "data" / "your_document.pdf")
```

### 支持的文档路径格式

| 路径类型 | 示例 | 说明 |
|---------|------|------|
| 绝对路径 | `/Users/name/docs/file.pdf` | 完整路径 |
| 相对路径 | `./data/file.pdf` | 相对当前目录 |
| ~路径 | `~/Documents/file.pdf` | 用户主目录 |

## 高级配置

### 文本分割参数调整

```python
# 编辑 code/main.py 中的分割参数
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=1500,        # 增大块大小
    chunk_overlap=300,      # 增加重叠
    separators=["\n\n", "\n", "。", " ", ""]
)
```

**参数说明**:
- `chunk_size`: 文本块最大字符数，建议 800-2000
- `chunk_overlap`: 块之间的重叠字符数，建议 chunk_size 的 10-20%
- `separators`: 分隔符优先级列表

### 检索参数调整

```python
# 修改检索返回的文档数量
retriever = vector_store.as_retriever(
    search_kwargs={"k": 6}  # 返回前6个相关文档
)
```

### 模型参数调整

```python
# 使用不同的LLM模型
llm = get_dashscope_llm(
    model_name="qwen-plus",  # 使用更强大的模型
    temperature=0.1          # 降低随机性
)
```

**可用模型**:
- `qwen-turbo`: 快速响应，适合一般问答
- `qwen-plus`: 增强能力，复杂任务
- `qwen-max`: 最强性能，高质量要求

## 常见问题解决

### Q1: API密钥配置错误

**错误信息**:
```
ValueError: 请设置环境变量 DASHSCOPE_API_KEY
```

**解决方案**:
```bash
# 检查环境变量是否设置
echo $DASHSCOPE_API_KEY

# 如果未设置，创建.env文件
echo "DASHSCOPE_API_KEY=your-api-key" > .env
```

### Q2: PDF文件找不到

**错误信息**:
```
FileNotFoundError: [Errno 2] No such file or directory
```

**解决方案**:
```bash
# 检查文件是否存在
ls -la data/

# 使用绝对路径
uv run python code/main.py --pdf $(pwd)/data/AI产品经理面试题65道.pdf
```

### Q3: 依赖版本冲突

**错误信息**:
```
ImportError: cannot import name 'xxx' from 'langchain'
```

**解决方案**:
```bash
# 重新安装依赖
rm -rf .venv
uv venv --python 3.11
source .venv/bin/activate
uv sync
```

### Q4: 内存不足

**错误信息**:
```
MemoryError: Unable to allocate array
```

**解决方案**:
```python
# 减小chunk_size
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,    # 减小块大小
    chunk_overlap=50   # 减小重叠
)
```

### Q5: API调用超时

**错误信息**:
```
TimeoutError: Request timed out
```

**解决方案**:
```bash
# 检查网络连接
ping dashscope.aliyuncs.com

# 或在代码中增加超时设置
import os
os.environ['DASHSCOPE_TIMEOUT'] = '60'
```

## 性能调优

### 检索性能优化

#### 1. 调整索引类型
```python
# 对于大规模数据，使用IVF索引
import faiss

# 创建IVF索引
quantizer = faiss.IndexFlatL2(dimension)
index = faiss.IndexIVFFlat(quantizer, dimension, nlist=100)

# 需要先训练
index.train(embeddings)
index.add(embeddings)
```

#### 2. 使用缓存
```python
# 持久化向量索引
vector_store.save_local("faiss_index")

# 加载已保存的索引
vector_store = FAISS.load_local("faiss_index", embeddings)
```

### 生成性能优化

#### 1. 批量处理
```python
# 批量生成嵌入
batch_size = 32
for i in range(0, len(texts), batch_size):
    batch = texts[i:i+batch_size]
    batch_embeddings = embeddings.embed_documents(batch)
```

#### 2. 异步调用
```python
import asyncio

async def async_query(question):
    result = await rag_system['retriever'].ainvoke(question)
    return result
```

### 内存优化

#### 1. 减少向量精度
```python
# 使用float16而非float32
embeddings = embeddings.astype('float16')
```

#### 2. 及时释放资源
```python
# 处理完成后释放大对象
del large_embeddings
import gc
gc.collect()
```

## 日志和调试

### 启用详细日志

```python
import logging

# 设置日志级别
logging.basicConfig(level=logging.DEBUG)

# LangChain特定日志
logging.getLogger("langchain").setLevel(logging.DEBUG)
```

### 查看中间结果

```python
# 查看检索到的文档
def debug_retrieval(question, retriever):
    docs = retriever.invoke(question)
    for i, doc in enumerate(docs, 1):
        print(f"\n文档 {i}:")
        print(f"内容: {doc.page_content[:200]}...")
        print(f"元数据: {doc.metadata}")
    return docs
```

### 性能监控

```python
import time

def timed_operation(operation_name):
    def decorator(func):
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            elapsed = time.time() - start
            print(f"{operation_name} 耗时: {elapsed:.2f}秒")
            return result
        return wrapper
    return decorator
```

## 扩展使用

### 添加自定义文档格式支持

```python
from langchain_community.document_loaders import TextLoader, UnstructuredMarkdownLoader

def load_custom_document(file_path):
    """支持多种文档格式"""
    ext = Path(file_path).suffix.lower()
    
    if ext == '.pdf':
        loader = PyPDFLoader(file_path)
    elif ext == '.txt':
        loader = TextLoader(file_path)
    elif ext == '.md':
        loader = UnstructuredMarkdownLoader(file_path)
    else:
        raise ValueError(f"不支持的文件格式: {ext}")
    
    return loader.load()
```

### 实现多轮对话

```python
class ConversationRAG:
    def __init__(self, rag_system):
        self.rag_system = rag_system
        self.history = []
    
    def chat(self, question):
        # 结合历史上下文
        context = "\n".join([f"Q: {q}\nA: {a}" for q, a in self.history[-3:]])
        enhanced_question = f"历史对话:\n{context}\n\n当前问题: {question}"
        
        result = query_rag_system(self.rag_system, enhanced_question)
        self.history.append((question, result['result']))
        return result
```

---

*最后更新: 2026年2月15日*
*文档版本: v1.0*
*维护团队: build-your-own-ai项目*
