# 销售数据业务助手 - 代码实现详解

## 核心代码结构

### 1. 项目模块结构

```
code/
├── __init__.py      # 模块初始化，定义公共接口
├── main.py          # 主程序入口，Agent 初始化和运行
├── tools.py         # Function Calling 工具实现
├── db.py            # 数据库连接和操作
├── init_db.py       # 数据库初始化和示例数据生成
└── test_tools.py    # 工具测试文件
```

### 2. 模块依赖关系

```
main.py
   │
   ├── tools.py
   │      │
   │      └── db.py
   │
   └── qwen_agent (外部依赖)

init_db.py
   │
   └── db.py (间接依赖)
```

## 主程序入口 (main.py)

### 1. 导入和配置

```python
import json
import os
import sys
from typing import Any, Dict, List, Optional

import dashscope
from dotenv import load_dotenv
from loguru import logger
from qwen_agent.agents import Assistant
from qwen_agent.tools.base import BaseTool, register_tool

# 支持直接运行
if __name__ == "__main__" and __package__ is None:
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from code.tools import (
        execute_custom_sql,
        get_monthly_sales,
        get_monthly_sales_growth,
        get_province_sales,
        get_top_channels,
    )
else:
    from .tools import (
        execute_custom_sql,
        get_monthly_sales,
        get_monthly_sales_growth,
        get_province_sales,
        get_top_channels,
    )

# 加载环境变量
load_dotenv()

# 配置 DashScope
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY", "")
dashscope.timeout = 60  # type: ignore
```

### 2. 系统提示词设计

```python
SYSTEM_PROMPT = """你是企业销售数据分析助手，可以帮助用户查询和分析销售数据。

## 数据库表结构

以下是销售数据表 `sales` 的字段说明：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INT | 主键ID |
| order_date | DATE | 订单日期 |
| order_month | VARCHAR(7) | 订单月份，格式 YYYY-MM |
| province | VARCHAR(50) | 省份 |
| city | VARCHAR(50) | 城市 |
| channel | VARCHAR(100) | 销售渠道 |
| product_name | VARCHAR(200) | 产品名称 |
| quantity | INT | 销售数量 |
| unit_price | DECIMAL(10,2) | 单价 |
| total_amount | DECIMAL(12,2) | 销售金额 |
| customer_id | VARCHAR(50) | 客户ID |

## 可用工具

1. `get_monthly_sales`: 查询某个月份的销量和销售额
   - 参数: month (格式: YYYY-MM)
   
2. `get_monthly_sales_growth`: 计算某月相比上月的销量环比增长
   - 参数: month (格式: YYYY-MM)
   
3. `get_province_sales`: 查询各省份的销售额
   - 参数: start_month, end_month (可选，格式: YYYY-MM)
   
4. `get_top_channels`: 查询某时间段销售金额 Top N 的渠道
   - 参数: start_date, end_date (可选，格式: YYYY-MM-DD), top_n (默认3)
   
5. `execute_custom_sql`: 执行自定义 SELECT 查询
   - 参数: sql (SELECT 语句)

## 回答规范

1. 使用中文回答
2. 销售金额保留两位小数，使用 ¥ 符号
3. 大数字使用千分位分隔符
4. 增长率使用百分比格式，正数显示 + 号
5. 如果用户问题不明确，主动询问澄清
"""
```

**设计要点：**
- **角色定义**: 明确定义 Agent 的身份和职责
- **上下文提供**: 包含数据库结构等必要信息
- **工具说明**: 详细描述每个工具的功能和参数
- **输出规范**: 规定回答的格式和风格

### 3. Function Calling 工具定义

```python
FUNCTIONS_DESC = [
    {
        "name": "get_monthly_sales",
        "description": "查询某个月份的销量和销售额",
        "parameters": {
            "type": "object",
            "properties": {
                "month": {
                    "type": "string",
                    "description": "月份，格式 YYYY-MM，例如 2024-01",
                }
            },
            "required": ["month"],
        },
    },
    # ... 其他工具定义
]
```

## 工具注册与调用

### 1. 安全注册机制

```python
def _safe_register_tool(name: str):
    """
    安全注册工具的装饰器，避免重复注册
    
    Args:
        name: 工具名称
        
    Returns:
        装饰器函数
    """
    from qwen_agent.tools.base import TOOL_REGISTRY
    
    if name in TOOL_REGISTRY:
        # 如果工具已注册，返回空装饰器
        def decorator(cls):
            return cls
        return decorator
    
    return register_tool(name)
```

### 2. 工具类实现模式

```python
@_safe_register_tool("get_monthly_sales")
class GetMonthlySalesTool(BaseTool):
    """查询月度销量工具"""
    
    description = "查询某个月份的销量和销售额"
    parameters = [{
        "name": "month",
        "type": "string",
        "description": "月份，格式 YYYY-MM",
        "required": True,
    }]
    
    def call(self, params: str, **kwargs) -> str:
        """
        执行工具调用
        
        Args:
            params: JSON 格式的参数字符串
            **kwargs: 额外参数（如 engine）
            
        Returns:
            工具执行结果（Markdown 格式）
        """
        args = json.loads(params)
        month = args.get("month")
        
        if not month:
            return "请提供月份参数"
        
        return get_monthly_sales(month)
```

### 3. 完整工具注册示例

```python
# 月度销量工具
@_safe_register_tool("get_monthly_sales")
class GetMonthlySalesTool(BaseTool):
    description = "查询某个月份的销量和销售额"
    parameters = [{"name": "month", "type": "string", "description": "月份", "required": True}]
    
    def call(self, params: str, **kwargs) -> str:
        args = json.loads(params)
        return get_monthly_sales(args.get("month"))

# 环比增长工具
@_safe_register_tool("get_monthly_sales_growth")
class GetMonthlySalesGrowthTool(BaseTool):
    description = "计算某个月份相比上个月的销量环比增长"
    parameters = [{"name": "month", "type": "string", "description": "当前月份", "required": True}]
    
    def call(self, params: str, **kwargs) -> str:
        args = json.loads(params)
        return get_monthly_sales_growth(args.get("month"))

# 省份销售工具
@_safe_register_tool("get_province_sales")
class GetProvinceSalesTool(BaseTool):
    description = "查询不同省份的销售额"
    parameters = [
        {"name": "start_month", "type": "string", "description": "开始月份（可选）", "required": False},
        {"name": "end_month", "type": "string", "description": "结束月份（可选）", "required": False},
    ]
    
    def call(self, params: str, **kwargs) -> str:
        args = json.loads(params)
        return get_province_sales(args.get("start_month"), args.get("end_month"))

# Top 渠道工具
@_safe_register_tool("get_top_channels")
class GetTopChannelsTool(BaseTool):
    description = "查询某时间段销售金额 Top N 的渠道"
    parameters = [
        {"name": "start_date", "type": "string", "description": "开始日期（可选）", "required": False},
        {"name": "end_date", "type": "string", "description": "结束日期（可选）", "required": False},
        {"name": "top_n", "type": "integer", "description": "返回前几名，默认 3", "required": False},
    ]
    
    def call(self, params: str, **kwargs) -> str:
        args = json.loads(params)
        return get_top_channels(args.get("start_date"), args.get("end_date"), args.get("top_n", 3))

# 自定义 SQL 工具
@_safe_register_tool("execute_custom_sql")
class ExecuteCustomSQLTool(BaseTool):
    description = "执行自定义 SQL SELECT 查询"
    parameters = [{"name": "sql", "type": "string", "description": "SELECT 查询语句", "required": True}]
    
    def call(self, params: str, **kwargs) -> str:
        args = json.loads(params)
        return execute_custom_sql(args.get("sql"))
```

## Agent 初始化

### 1. Agent 服务初始化

```python
def init_agent_service() -> Assistant:
    """
    初始化业务助手服务
    
    Returns:
        Assistant 实例
    """
    # 大模型配置
    llm_cfg = {
        "model": "qwen-turbo-latest",
        "timeout": 60,
        "retry_count": 3,
    }
    
    try:
        bot = Assistant(
            llm=llm_cfg,
            name="销售数据助手",
            description="企业销售数据查询与分析助手",
            system_message=SYSTEM_PROMPT,
            function_list=[
                "get_monthly_sales",
                "get_monthly_sales_growth",
                "get_province_sales",
                "get_top_channels",
                "execute_custom_sql",
            ],
        )
        logger.info("业务助手初始化成功")
        return bot
    except Exception as e:
        logger.error(f"业务助手初始化失败: {e}")
        raise
```

### 2. 消息处理流程

```python
def process_message(bot: Assistant, messages: List[Dict]) -> str:
    """
    处理用户消息并返回响应
    
    Args:
        bot: Assistant 实例
        messages: 消息历史
        
    Returns:
        响应文本
    """
    response_text = ""
    
    # 流式获取响应
    for response in bot.run(messages):  # type: ignore
        if response:
            for msg in response:
                if msg.get("role") == "assistant" and msg.get("content"):
                    content = msg["content"]
                    if isinstance(content, str):
                        response_text = content
    
    return response_text
```

## 工具函数实现 (tools.py)

### 1. 月度销量查询

```python
def get_monthly_sales(month: str, engine: Optional[Any] = None) -> str:
    """
    查询某个月份的销量和销售额
    
    Args:
        month: 月份，格式 YYYY-MM
        engine: 数据库引擎
        
    Returns:
        查询结果的 Markdown 表格
    """
    sql = f"""
        SELECT 
            order_month as 月份,
            SUM(quantity) as 总销量,
            ROUND(SUM(total_amount), 2) as 总销售额
        FROM sales
        WHERE order_month = '{month}'
        GROUP BY order_month
    """
    
    try:
        df = execute_sql(sql, engine)
        if df.empty:
            return f"未找到 {month} 的销售数据"
        return df.to_markdown(index=False)
    except Exception as e:
        logger.error(f"查询月度销量失败: {e}")
        return f"查询失败: {str(e)}"
```

### 2. 环比增长计算

```python
def get_monthly_sales_growth(month: str, engine: Optional[Any] = None) -> str:
    """
    计算某个月份相比上个月的销量环比增长
    
    Args:
        month: 当前月份，格式 YYYY-MM
        engine: 数据库引擎
        
    Returns:
        环比增长分析结果
    """
    # 计算上个月
    year, m = map(int, month.split("-"))
    prev_month = f"{year}-{m-1:02d}" if m > 1 else f"{year-1}-12"
    
    sql = f"""
        SELECT 
            order_month as 月份,
            SUM(quantity) as 总销量,
            ROUND(SUM(total_amount), 2) as 总销售额
        FROM sales
        WHERE order_month IN ('{month}', '{prev_month}')
        GROUP BY order_month
        ORDER BY order_month
    """
    
    try:
        df = execute_sql(sql, engine)
        
        if df.empty:
            return f"未找到 {month} 和 {prev_month} 的销售数据"
        
        # 转换为字典方便查询
        data = df.set_index("月份").to_dict("index")
        
        if month not in data:
            return f"未找到 {month} 的销售数据"
        
        current = data.get(month, {})
        previous = data.get(prev_month, {})
        
        curr_qty = current.get("总销量", 0) or 0
        prev_qty = previous.get("总销量", 0) or 0
        curr_amount = current.get("总销售额", 0) or 0
        prev_amount = previous.get("总销售额", 0) or 0
        
        # 计算环比增长率
        if prev_qty > 0:
            qty_growth = (curr_qty - prev_qty) / prev_qty * 100
        else:
            qty_growth = 0 if curr_qty == 0 else 100
        
        if prev_amount > 0:
            amount_growth = (curr_amount - prev_amount) / prev_amount * 100
        else:
            amount_growth = 0 if curr_amount == 0 else 100
        
        result = f"""
## {month} 销售环比分析

| 指标 | {prev_month} | {month} | 环比增长 |
|------|-------------|---------|---------|
| 总销量 | {prev_qty:,} | {curr_qty:,} | {qty_growth:+.2f}% |
| 总销售额 | ¥{prev_amount:,.2f} | ¥{curr_amount:,.2f} | {amount_growth:+.2f}% |
"""
        return result
        
    except Exception as e:
        logger.error(f"计算环比增长失败: {e}")
        return f"查询失败: {str(e)}"
```

### 3. 省份销售额分析

```python
def get_province_sales(
    start_month: Optional[str] = None,
    end_month: Optional[str] = None,
    engine: Optional[Any] = None,
) -> str:
    """
    查询不同省份的销售额
    
    Args:
        start_month: 开始月份（可选）
        end_month: 结束月份（可选）
        engine: 数据库引擎
        
    Returns:
        各省销售额的 Markdown 表格
    """
    where_clauses = []
    if start_month:
        where_clauses.append(f"order_month >= '{start_month}'")
    if end_month:
        where_clauses.append(f"order_month <= '{end_month}'")
    
    where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
    
    sql = f"""
        SELECT 
            province as 省份,
            COUNT(*) as 订单数,
            SUM(quantity) as 总销量,
            ROUND(SUM(total_amount), 2) as 总销售额
        FROM sales
        WHERE {where_sql}
        GROUP BY province
        ORDER BY 总销售额 DESC
    """
    
    try:
        df = execute_sql(sql, engine)
        if df.empty:
            return "未找到符合条件的销售数据"
        
        # 计算占比
        total_amount = df["总销售额"].sum()
        df["销售额占比"] = (df["总销售额"] / total_amount * 100).round(2)
        
        return df.to_markdown(index=False)
    except Exception as e:
        logger.error(f"查询省份销售额失败: {e}")
        return f"查询失败: {str(e)}"
```

### 4. Top 渠道查询

```python
def get_top_channels(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    top_n: int = 3,
    engine: Optional[Any] = None,
) -> str:
    """
    查询某时间段销售金额 Top N 的渠道
    
    Args:
        start_date: 开始日期（可选）
        end_date: 结束日期（可选）
        top_n: 返回前几名
        engine: 数据库引擎
        
    Returns:
        Top N 渠道的 Markdown 表格
    """
    where_clauses = []
    if start_date:
        where_clauses.append(f"order_date >= '{start_date}'")
    if end_date:
        where_clauses.append(f"order_date <= '{end_date}'")
    
    where_sql = " AND ".join(where_clauses) if where_clauses else "1=1"
    
    sql = f"""
        SELECT 
            channel as 渠道,
            COUNT(*) as 订单数,
            SUM(quantity) as 总销量,
            ROUND(SUM(total_amount), 2) as 总销售额
        FROM sales
        WHERE {where_sql}
        GROUP BY channel
        ORDER BY 总销售额 DESC
        LIMIT {top_n}
    """
    
    try:
        df = execute_sql(sql, engine)
        if df.empty:
            return "未找到符合条件的销售数据"
        
        # 计算占比
        total_amount = df["总销售额"].sum()
        df["销售额占比"] = (df["总销售额"] / total_amount * 100).round(2)
        
        result = f"## 销售金额 Top{top_n} 渠道\n\n"
        result += df.to_markdown(index=False)
        return result
    except Exception as e:
        logger.error(f"查询 Top 渠道失败: {e}")
        return f"查询失败: {str(e)}"
```

### 5. 自定义 SQL 查询

```python
def execute_custom_sql(sql: str, engine: Optional[Any] = None) -> str:
    """
    执行自定义 SQL 查询
    
    Args:
        sql: SQL 查询语句
        engine: 数据库引擎
        
    Returns:
        查询结果的 Markdown 表格
    """
    # 安全检查：只允许 SELECT 语句
    sql_upper = sql.strip().upper()
    if not sql_upper.startswith("SELECT"):
        return "只允许执行 SELECT 查询语句"
    
    # 禁止危险操作
    dangerous_keywords = ["DROP", "DELETE", "TRUNCATE", "ALTER", "CREATE", "INSERT", "UPDATE"]
    for keyword in dangerous_keywords:
        if keyword in sql_upper:
            return f"禁止执行包含 {keyword} 的语句"
    
    try:
        df = execute_sql(sql, engine)
        if df.empty:
            return "查询结果为空"
        
        # 限制返回行数
        if len(df) > 50:
            df = df.head(50)
            return df.to_markdown(index=False) + "\n\n*注：结果已截断，仅显示前 50 条*"
        
        return df.to_markdown(index=False)
    except Exception as e:
        logger.error(f"执行自定义 SQL 失败: {e}")
        return f"查询失败: {str(e)}"
```

## 数据库操作模块 (db.py)

### 1. 数据库连接

```python
def get_engine() -> Engine:
    """
    获取数据库连接引擎
    
    优先使用 DATABASE_URL 环境变量，否则使用单独的配置项
    """
    database_url = os.getenv("DATABASE_URL")
    
    if database_url:
        logger.info("使用 DATABASE_URL 连接数据库")
        # SQLite 不支持 connect_timeout 和 pool 参数
        if database_url.startswith("sqlite"):
            return create_engine(database_url)
        return create_engine(
            database_url,
            connect_args={"connect_timeout": 10},
            pool_size=10,
            max_overflow=20,
        )
    
    # 单独配置项（用于本地开发）
    db_host = os.getenv("DB_HOST", "localhost")
    db_port = os.getenv("DB_PORT", "3306")
    db_user = os.getenv("DB_USER", "root")
    db_password = os.getenv("DB_PASSWORD", "")
    db_name = os.getenv("DB_NAME", "sales_db")
    
    connection_url = f"mysql+mysqlconnector://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}?charset=utf8mb4"
    logger.info(f"连接数据库: {db_host}:{db_port}/{db_name}")
    
    return create_engine(
        connection_url,
        connect_args={"connect_timeout": 10},
        pool_size=10,
        max_overflow=20,
    )
```

### 2. SQL 执行

```python
def execute_sql(sql: str, engine: Optional[Engine] = None) -> pd.DataFrame:
    """
    执行 SQL 查询并返回 DataFrame
    
    Args:
        sql: SQL 查询语句
        engine: 数据库引擎（可选）
        
    Returns:
        查询结果的 DataFrame
    """
    if engine is None:
        engine = get_engine()
    
    try:
        df = pd.read_sql(sql, engine)
        logger.info(f"SQL 执行成功，返回 {len(df)} 条记录")
        return df
    except Exception as e:
        logger.error(f"SQL 执行失败: {e}")
        raise
```

### 3. 连接测试

```python
def test_connection() -> bool:
    """测试数据库连接"""
    try:
        engine = get_engine()
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        logger.info("数据库连接测试成功")
        return True
    except Exception as e:
        logger.error(f"数据库连接测试失败: {e}")
        return False
```

## 数据初始化 (init_db.py)

### 1. 示例数据生成

```python
def generate_sample_data(
    start_date: str = "2024-01-01",
    end_date: str = "2024-12-31",
    num_records: int = 2000,
) -> pd.DataFrame:
    """
    生成示例销售数据
    
    Args:
        start_date: 开始日期
        end_date: 结束日期
        num_records: 记录数量
        
    Returns:
        销售数据 DataFrame
    """
    start = datetime.strptime(start_date, "%Y-%m-%d")
    end = datetime.strptime(end_date, "%Y-%m-%d")
    date_range = (end - start).days
    
    records = []
    
    for _ in range(num_records):
        # 随机日期
        random_days = random.randint(0, date_range)
        order_date = start + timedelta(days=random_days)
        order_month = order_date.strftime("%Y-%m")
        
        # 随机省份和城市
        province = random.choice(PROVINCES)
        city = random.choice(CITIES[province])
        
        # 随机渠道和产品
        channel = random.choice(CHANNELS)
        product_name, unit_price = random.choice(PRODUCTS)
        
        # 随机数量和折扣
        quantity = random.randint(1, 50)
        discount = random.uniform(0.9, 1.0)
        total_amount = round(unit_price * quantity * discount, 2)
        
        # 客户ID
        customer_id = f"C{random.randint(10000, 99999)}"
        
        records.append({
            "order_date": order_date.strftime("%Y-%m-%d"),
            "order_month": order_month,
            "province": province,
            "city": city,
            "channel": channel,
            "product_name": product_name,
            "quantity": quantity,
            "unit_price": unit_price,
            "total_amount": total_amount,
            "customer_id": customer_id,
        })
    
    return pd.DataFrame(records)
```

### 2. SQLite 初始化

```python
def init_sqlite_db(db_path: str, df: pd.DataFrame):
    """
    初始化 SQLite 数据库
    
    Args:
        db_path: 数据库文件路径
        df: 销售数据 DataFrame
    """
    engine = create_engine(f"sqlite:///{db_path}")
    
    # 建表
    with engine.connect() as conn:
        conn.execute(text("""
            CREATE TABLE IF NOT EXISTS sales (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                order_date TEXT NOT NULL,
                order_month TEXT NOT NULL,
                province TEXT NOT NULL,
                city TEXT,
                channel TEXT NOT NULL,
                product_name TEXT,
                quantity INTEGER NOT NULL DEFAULT 0,
                unit_price REAL NOT NULL DEFAULT 0,
                total_amount REAL NOT NULL DEFAULT 0,
                customer_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """))
        conn.commit()
    
    # 插入数据
    df.to_sql("sales", engine, if_exists="append", index=False)
    logger.info(f"SQLite 数据库初始化完成: {db_path}")
```

## 用户交互实现

### 1. 终端交互模式

```python
def run_tui():
    """终端交互模式"""
    logger.info("启动终端交互模式")
    
    bot = init_agent_service()
    messages: List[Dict] = []
    
    print("=" * 60)
    print("销售数据业务助手")
    print("=" * 60)
    print("可用查询:")
    print("  1. 查询某月销量: 2024年1月的销量是多少？")
    print("  2. 环比增长: 2024年2月的销量环比增长多少？")
    print("  3. 省份销售额: 各省的销售额是多少？")
    print("  4. Top 渠道: 2024年第一季度销售金额Top3的渠道")
    print("  输入 'quit' 退出")
    print("=" * 60)
    
    while True:
        try:
            query = input("\n用户: ").strip()
            
            if query.lower() == "quit":
                print("再见！")
                break
            
            if not query:
                continue
            
            messages.append({"role": "user", "content": query})
            
            print("\n助手: ", end="")
            response_text = ""
            
            for response in bot.run(messages):
                if response:
                    for msg in response:
                        if msg.get("role") == "assistant" and msg.get("content"):
                            content = msg["content"]
                            if isinstance(content, str):
                                response_text = content
            
            print(response_text)
            messages.append({"role": "assistant", "content": response_text})
            
        except KeyboardInterrupt:
            print("\n再见！")
            break
        except Exception as e:
            logger.error(f"处理请求出错: {e}")
            print(f"处理出错: {e}")
```

### 2. Web 界面模式

```python
def run_gui():
    """Web 图形界面模式"""
    try:
        from qwen_agent.gui import WebUI
    except ImportError as e:
        logger.error(f"GUI 依赖未安装: {e}")
        print("GUI 依赖未安装，请运行: pip install 'qwen-agent[gui]'")
        print("或使用终端模式: python main.py --mode tui")
        return
    
    logger.info("启动 Web 界面模式")
    
    bot = init_agent_service()
    
    chatbot_config = {
        "prompt.suggestions": [
            "2024年1月的销量是多少？",
            "2024年2月相比1月，销量环比增长多少？",
            "不同省份的销售额是多少？",
            "2024年第一季度销售金额Top3的渠道是哪些？",
        ]
    }
    
    WebUI(bot, chatbot_config=chatbot_config).run()
```

## 错误处理机制

### 1. 工具调用错误处理

```python
def safe_tool_call(func: callable, *args, **kwargs) -> str:
    """
    安全的工具调用包装器
    
    Args:
        func: 工具函数
        *args: 位置参数
        **kwargs: 关键字参数
        
    Returns:
        工具执行结果或错误信息
    """
    try:
        return func(*args, **kwargs)
    except json.JSONDecodeError as e:
        logger.error(f"JSON 解析错误: {e}")
        return f"参数解析失败: {str(e)}"
    except ValueError as e:
        logger.error(f"参数验证错误: {e}")
        return f"参数错误: {str(e)}"
    except Exception as e:
        logger.error(f"工具执行错误: {e}")
        return f"执行失败: {str(e)}"
```

### 2. 数据库错误处理

```python
def safe_execute_sql(sql: str, engine: Optional[Engine] = None) -> pd.DataFrame:
    """
    安全的 SQL 执行
    
    Args:
        sql: SQL 查询语句
        engine: 数据库引擎
        
    Returns:
        查询结果 DataFrame
    """
    try:
        return execute_sql(sql, engine)
    except ConnectionError as e:
        logger.error(f"数据库连接错误: {e}")
        raise
    except Exception as e:
        logger.error(f"SQL 执行错误: {e}")
        raise
```

---

*最后更新: 2026年2月22日*
*代码实现版本: v1.0*
*开发团队: AI系统开发组*
