# 三国演义词嵌入分析系统 - 使用指南

## 环境准备

### 1. 系统要求
- **操作系统**: Windows 10+, macOS 10.15+, Ubuntu 18.04+
- **Python版本**: 3.11+
- **内存**: 最小4GB，推荐8GB+
- **存储空间**: 最小1GB，推荐2GB+

### 2. 依赖安装

#### 方式一：使用uv（推荐）
```bash
# 进入项目目录
cd practice/14-CASE-三国演义Embedding

# 创建虚拟环境
uv venv --python 3.11

# 激活虚拟环境
source .venv/bin/activate  # Linux/Mac
# 或
.venv\Scripts\activate     # Windows

# 安装依赖
uv sync

# 运行测试
uv run python code/test_environment.py
```

#### 方式二：使用pip
```bash
# 创建虚拟环境
python -m venv .venv

# 激活虚拟环境
source .venv/bin/activate  # Linux/Mac
# 或
.venv\Scripts\activate     # Windows

# 安装依赖
pip install -r requirements.txt

# 运行测试
python code/test_environment.py
```

### 3. 验证安装

```bash
# 检查Python版本
python --version  # 应显示 Python 3.11+

# 检查依赖安装
python -c "import gensim; print(f'Gensim版本: {gensim.__version__}')"
python -c "import jieba; print('jieba安装成功')"
python -c "import numpy; print(f'NumPy版本: {numpy.__version__}')"
```

## 快速开始

### 1. 运行主程序

#### 完整训练流程
```bash
# 激活虚拟环境
source .venv/bin/activate

# 运行训练程序
uv run python code/three_kingdoms.py
```

#### 预期输出
```
============================================================
1. 加载三国演义文本
============================================================
文本总长度: 605242 字符

正在分词...
分词结果: 402725 个词

构建训练句子...
总句子数: 40272

词频统计（前20）:
  ，: 43567
  。: 24449
  ：: 10289
  ... （更多词频统计）

============================================================
2. 训练Word2Vec模型
============================================================
训练参数:
  vector_size: 100
  window: 5
  min_count: 5
  workers: 4
  sg: 0
  epochs: 100
  seed: 42

开始训练...
训练完成！
词汇表大小: 7579
向量维度: 100

保存模型到: model/three_kingdoms.model
模型保存完成！

============================================================
3. 分析与'曹操'最相近的词
============================================================

与 '曹操' 最相近的 15 个词:
  1. 马超: 0.5087
  2. 袁术: 0.4905
  3. 刘璋: 0.4357
  4. 周瑜: 0.4320
  5. 张鲁: 0.4267
  ... （更多结果）

============================================================
4. 词类比计算
============================================================

计算: 曹操 + 刘备 - 张飞 = ?

结果:
  1. 明公: 0.4252
  2. 孤: 0.4051
  3. 东吴: 0.3991
  ... （更多结果）

============================================================
分析完成！
============================================================
```

### 2. 运行演示程序

```bash
# 运行演示程序（使用已训练的模型）
uv run python code/word2vec_demo.py
```

#### 预期输出
```
============================================================
三国演义 Word2Vec 模型使用示例
============================================================
从 model/three_kingdoms.model 加载模型...
模型加载成功！词汇表大小: 7579

============================================================
词汇表信息
============================================================

词汇表大小: 7579
向量维度: 100

常见人物词:
  ✓ 曹操
  ✓ 刘备
  ✓ 孙权
  ✓ 诸葛亮
  ... （更多人物）

============================================================
词相似度分析
============================================================

与 '曹操' 最相近的 10 个词:
  1. 马超: 0.5087
  2. 袁术: 0.4905
  ... （更多结果）

============================================================
词类比演示
============================================================

示例1: 曹操 + 刘备 - 张飞 = ?
  1. 明公: 0.4252
  2. 孤: 0.4051
  ... （更多结果）

============================================================
演示完成！
============================================================
```

## 词相似度分析

### 1. 基本使用

```python
from gensim.models import Word2Vec

# 加载模型
model = Word2Vec.load('model/three_kingdoms.model')

# 查找与"曹操"最相似的10个词
similar_words = model.wv.most_similar('曹操', topn=10)

# 显示结果
for word, similarity in similar_words:
    print(f"{word}: {similarity:.4f}")
```

### 2. 批量查询

```python
def batch_similarity_analysis(model, words: list, topn: int = 5):
    """
    批量相似度分析
    
    Args:
        model: Word2Vec模型
        words: 待分析词列表
        topn: 每个词返回的相似词数量
    """
    results = {}
    for word in words:
        if word in model.wv:
            similar = model.wv.most_similar(word, topn=topn)
            results[word] = similar
        else:
            results[word] = None
            print(f"警告: '{word}' 不在词汇表中")
    return results

# 使用示例
words_to_analyze = ['曹操', '刘备', '诸葛亮', '关羽', '张飞']
results = batch_similarity_analysis(model, words_to_analyze)

for word, similar_words in results.items():
    print(f"\n与 '{word}' 相似的词:")
    if similar_words:
        for w, sim in similar_words:
            print(f"  {w}: {sim:.4f}")
```

### 3. 相似度矩阵

```python
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def plot_similarity_matrix(model, words: list):
    """
    绘制词相似度矩阵热力图
    
    Args:
        model: Word2Vec模型
        words: 词列表
    """
    # 过滤不在词汇表中的词
    valid_words = [w for w in words if w in model.wv]
    
    # 计算相似度矩阵
    n = len(valid_words)
    similarity_matrix = np.zeros((n, n))
    
    for i, word1 in enumerate(valid_words):
        for j, word2 in enumerate(valid_words):
            similarity_matrix[i, j] = model.wv.similarity(word1, word2)
    
    # 绘制热力图
    plt.figure(figsize=(10, 8))
    sns.heatmap(
        similarity_matrix,
        annot=True,
        fmt='.2f',
        xticklabels=valid_words,
        yticklabels=valid_words,
        cmap='RdYlBu_r'
    )
    plt.title('词相似度矩阵')
    plt.tight_layout()
    plt.savefig('output/similarity_matrix.png', dpi=300)
    plt.show()

# 使用示例
characters = ['曹操', '刘备', '孙权', '诸葛亮', '周瑜', '关羽', '张飞', '赵云']
plot_similarity_matrix(model, characters)
```

## 词类比计算

### 1. 基本概念

词类比是词向量的重要应用，基于向量运算发现词汇之间的语义关系：

```
经典类比示例：
- 男人 : 女人 = 国王 : 王后
- 北京 : 中国 = 东京 : 日本

数学表达：
vec(王后) ≈ vec(国王) - vec(男人) + vec(女人)
```

### 2. 三国演义类比示例

```python
# 类比1: 曹操 + 刘备 - 张飞 = ?
result = model.wv.most_similar(
    positive=['曹操', '刘备'],
    negative=['张飞'],
    topn=5
)
# 结果: 明公、孤、东吴...

# 类比2: 诸葛亮 + 刘备 - 关羽 = ?
result = model.wv.most_similar(
    positive=['诸葛亮', '刘备'],
    negative=['关羽'],
    topn=5
)

# 类比3: 曹操 - 董卓 = ?
result = model.wv.most_similar(
    positive=['曹操'],
    negative=['董卓'],
    topn=5
)
```

### 3. 类比分析函数

```python
def analyze_analogy(model, positive: list, negative: list, topn: int = 10):
    """
    分析词类比并显示详细结果
    
    Args:
        model: Word2Vec模型
        positive: 正面词列表
        negative: 负面词列表
        topn: 返回结果数量
    """
    # 构建公式字符串
    pos_str = " + ".join(positive)
    neg_str = " - ".join(negative) if negative else "无"
    
    print(f"\n类比计算: {pos_str} - ({neg_str}) = ?")
    print("-" * 50)
    
    try:
        result = model.wv.most_similar(
            positive=positive,
            negative=negative,
            topn=topn
        )
        
        print("结果:")
        for i, (word, similarity) in enumerate(result, 1):
            print(f"  {i}. {word}: {similarity:.4f}")
        
        return result
        
    except KeyError as e:
        print(f"错误: 词汇表中缺少词 - {e}")
        return None

# 批量类比分析
analogies = [
    (['曹操', '刘备'], ['张飞']),
    (['诸葛亮', '刘备'], ['关羽']),
    (['曹操'], ['董卓']),
    (['刘备', '关羽'], ['张飞']),
]

for positive, negative in analogies:
    analyze_analogy(model, positive, negative)
```

## 交互式使用

### 1. Python交互模式

```python
# 启动交互模式
python -i code/word2vec_demo.py

# 或者
from gensim.models import Word2Vec
model = Word2Vec.load('model/three_kingdoms.model')

# 交互查询
>>> model.wv.most_similar('诸葛亮', topn=5)
[('孔明', 0.65), ('刘备', 0.58), ...]

>>> model.wv.similarity('曹操', '刘备')
0.45

>>> model.wv.doesnt_match(['曹操', '刘备', '孙权', '桌子'])
'桌子'  # 不属于人物类别的词
```

### 2. Jupyter Notebook使用

```python
# 在Jupyter中运行
%load_ext autoreload
%autoreload 2

from gensim.models import Word2Vec
import matplotlib.pyplot as plt
import seaborn as sns

# 加载模型
model = Word2Vec.load('model/three_kingdoms.model')

# 可视化词向量
from sklearn.decomposition import PCA

def plot_word_vectors(model, words: list):
    """可视化词向量（降维到2D）"""
    # 获取词向量
    vectors = [model.wv[w] for w in words if w in model.wv]
    valid_words = [w for w in words if w in model.wv]
    
    # PCA降维
    pca = PCA(n_components=2)
    coords = pca.fit_transform(vectors)
    
    # 绘图
    plt.figure(figsize=(12, 8))
    plt.scatter(coords[:, 0], coords[:, 1], alpha=0.5)
    
    for i, word in enumerate(valid_words):
        plt.annotate(word, (coords[i, 0], coords[i, 1]))
    
    plt.title('词向量可视化（PCA降维）')
    plt.xlabel('PC1')
    plt.ylabel('PC2')
    plt.grid(True)
    plt.show()

# 使用示例
characters = ['曹操', '刘备', '孙权', '诸葛亮', '周瑜', 
              '关羽', '张飞', '赵云', '马超', '黄忠']
plot_word_vectors(model, characters)
```

## 常见问题解决

### 1. 词汇不在词汇表中

#### 问题现象
```python
>>> model.wv.most_similar('某个生僻词')
KeyError: "Key '某个生僻词' not present in vocabulary"
```

#### 解决方案
```python
def safe_similarity(model, word: str, topn: int = 10):
    """安全的相似度查询"""
    if word not in model.wv:
        print(f"警告: '{word}' 不在词汇表中")
        # 尝试分词后查询
        import jieba
        sub_words = jieba.lcut(word)
        if len(sub_words) > 1:
            print(f"尝试查询分词结果: {sub_words}")
            for sub_word in sub_words:
                if sub_word in model.wv:
                    return model.wv.most_similar(sub_word, topn=topn)
        return None
    return model.wv.most_similar(word, topn=topn)
```

### 2. 模型加载失败

#### 问题现象
```
FileNotFoundError: [Errno 2] No such file or directory: 'model/three_kingdoms.model'
```

#### 解决方案
```bash
# 检查模型文件是否存在
ls -la model/

# 如果不存在，需要重新训练
uv run python code/three_kingdoms.py
```

### 3. 内存不足

#### 问题现象
```
MemoryError: Unable to allocate array
```

#### 解决方案
```python
# 1. 减少向量维度
params = {'vector_size': 50, ...}  # 从100降到50

# 2. 增加最小词频
params = {'min_count': 10, ...}  # 从5增加到10

# 3. 分批处理
def process_in_batches(data, batch_size=10000):
    results = []
    for i in range(0, len(data), batch_size):
        batch = data[i:i+batch_size]
        # 处理批次
        results.extend(process_batch(batch))
    return results
```

### 4. 分词效果不佳

#### 问题现象
某些人物名或专有名词被错误分词

#### 解决方案
```python
import jieba

# 添加自定义词典
jieba.add_word('诸葛亮')
jieba.add_word('草船借箭')
jieba.add_word('赤壁之战')

# 或加载词典文件
jieba.load_userdict('data/custom_dict.txt')
```

## 性能调优

### 1. 训练参数优化

```python
# 快速训练（适合原型验证）
quick_params = {
    'vector_size': 50,
    'window': 3,
    'min_count': 5,
    'workers': 4,
    'sg': 0,
    'epochs': 20,
}

# 平衡训练（适合一般用途）
balanced_params = {
    'vector_size': 100,
    'window': 5,
    'min_count': 5,
    'workers': 4,
    'sg': 0,
    'epochs': 100,
}

# 高质量训练（适合精确分析）
quality_params = {
    'vector_size': 200,
    'window': 10,
    'min_count': 3,
    'workers': 4,
    'sg': 1,  # Skip-gram
    'epochs': 200,
}
```

### 2. 查询性能优化

```python
# 预加载模型到内存
class ModelManager:
    _instance = None
    _model = None
    
    @classmethod
    def get_model(cls):
        if cls._model is None:
            cls._model = Word2Vec.load('model/three_kingdoms.model')
        return cls._model

# 使用单例模式
model = ModelManager.get_model()
```

### 3. 内存优化

```python
# 释放不需要的资源
def train_and_save():
    model = Word2Vec(sentences, **params)
    model.save('model/three_kingdoms.model')
    
    # 释放内存
    del model
    import gc
    gc.collect()
```

## 监控和调试

### 1. 训练过程监控

```python
from gensim.models.callbacks import CallbackAny2Vec

class LossLogger(CallbackAny2Vec):
    """训练损失日志回调"""
    
    def __init__(self):
        self.epoch = 0
        self.losses = []
    
    def on_epoch_end(self, model):
        loss = model.get_latest_training_loss()
        self.losses.append(loss)
        self.epoch += 1
        if self.epoch % 10 == 0:
            print(f"Epoch {self.epoch}, Loss: {loss:.4f}")

# 使用回调
loss_logger = LossLogger()
model = Word2Vec(
    sentences,
    callbacks=[loss_logger],
    epochs=100
)
```

### 2. 模型质量评估

```python
def evaluate_model(model, test_pairs: list):
    """
    评估模型质量
    
    Args:
        model: Word2Vec模型
        test_pairs: 测试词对列表 [(word1, word2, expected_similarity), ...]
    """
    errors = []
    for word1, word2, expected in test_pairs:
        if word1 in model.wv and word2 in model.wv:
            actual = model.wv.similarity(word1, word2)
            error = abs(actual - expected)
            errors.append(error)
            print(f"{word1}-{word2}: 预期={expected:.2f}, 实际={actual:.4f}, 误差={error:.4f}")
    
    avg_error = sum(errors) / len(errors)
    print(f"\n平均误差: {avg_error:.4f}")
    return avg_error

# 使用示例
test_pairs = [
    ('曹操', '刘备', 0.5),   # 预期相似度
    ('诸葛亮', '孔明', 0.9),  # 同一人不同称呼
    ('关羽', '张飞', 0.7),   # 兄弟关系
]
evaluate_model(model, test_pairs)
```

---

*最后更新: 2026年2月15日*
*使用指南版本: v1.0*
*技术支持: build-your-own-ai项目团队*
