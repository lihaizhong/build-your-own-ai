# Cursor编程从入门到精通 - 代码实现详解

## 核心代码结构

### 1. 项目路径管理模块

```python
from pathlib import Path

def get_project_path(*paths: str) -> Path:
    """获取项目路径的统一方法"""
    try:
        current_dir = Path(__file__).parent
        project_dir = current_dir.parent
        return project_dir.joinpath(*paths)
    except NameError:
        return Path.cwd().joinpath(*paths)
```

**功能特点：**
- **统一路径管理**: 提供项目路径的标准化获取方法
- **容错处理**: 处理不同运行环境下的路径差异
- **灵活扩展**: 支持任意层级的路径构建

## Excel数据处理实现

### 1. 员工信息表读取

#### 核心读取函数
```python
def read_employee_excel():
    """
    读取员工基本信息表.xlsx文件的前5行数据
    """
    # 获取脚本目录并准备 user_data 目录
    current_dir = get_project_path()
    user_data_dir = current_dir / "user_data"
    user_data_dir.mkdir(parents=True, exist_ok=True)

    # 优先使用 user_data 中的文件
    candidate = user_data_dir / "员工基本信息表.xlsx"
    excel_file = candidate if candidate.exists() else (current_dir / "员工基本信息表.xlsx")
    
    # 检查文件是否存在
    if not excel_file.exists():
        create_path = user_data_dir / "员工基本信息表.xlsx"
        print(f"⚠️ 找不到文件，正在创建示例文件...")
        create_sample_excel(create_path)
        excel_file = create_path
    
    try:
        # 读取Excel文件的前5行数据
        df = pd.read_excel(excel_file, nrows=5)
        
        # 显示文件信息
        print(f"文件总行数：{len(pd.read_excel(excel_file))}")
        print(f"文件列数：{df.shape[1]}")
        
        return df
        
    except Exception as e:
        print(f"读取Excel文件时发生错误：{e}")
        return None
```

#### 示例数据生成
```python
def create_sample_excel(file_path):
    """创建示例的员工基本信息表Excel文件"""
    employee_data = {
        '员工编号': ['E001', 'E002', 'E003', 'E004', 'E005'],
        '姓名': ['张三', '李四', '王五', '赵六', '钱七'],
        '性别': ['男', '女', '男', '女', '男'],
        '年龄': [28, 32, 25, 29, 35],
        '部门': ['技术部', '人事部', '技术部', '财务部', '市场部'],
        '职位': ['软件工程师', '人事专员', '前端工程师', '会计师', '市场专员'],
        '入职日期': ['2022-01-15', '2021-03-20', '2023-06-10', '2020-11-05', '2022-08-12'],
        '薪资': [12000, 8000, 10000, 9000, 7500]
    }
    
    df = pd.DataFrame(employee_data)
    df.to_excel(file_path, index=False, engine='openpyxl')
```

### 2. 数据合并模块

#### 主合并函数
```python
def merge_employee_data():
    """合并员工基本信息表和员工绩效表数据"""
    current_dir = get_project_path()
    user_data_dir = current_dir / "user_data"
    user_data_dir.mkdir(parents=True, exist_ok=True)

    # 文件路径配置
    employee_info_file = user_data_dir / "员工基本信息表.xlsx"
    employee_performance_file = user_data_dir / "员工绩效表.xlsx"
    merged_file = user_data_dir / "员工综合信息表_2024Q4.xlsx"
    
    try:
        # 读取数据
        info_df = pd.read_excel(employee_info_file)
        performance_df = pd.read_excel(employee_performance_file)
        
        # 基于员工编号进行左连接合并
        merged_df = pd.merge(
            info_df, 
            performance_df, 
            on='员工编号', 
            how='left',
            suffixes=('', '_绩效')
        )
        
        # 处理重复列名
        if '姓名_绩效' in merged_df.columns:
            merged_df = merged_df.drop('姓名_绩效', axis=1)
        
        # 重新排列列顺序
        basic_columns = list(info_df.columns)
        performance_columns = [col for col in performance_df.columns 
                               if col not in ['员工编号', '姓名']]
        final_columns = basic_columns + performance_columns
        merged_df = merged_df[final_columns]
        
        # 添加合并时间戳
        merged_df['数据合并时间'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        return merged_df
        
    except Exception as e:
        print(f"合并过程中发生错误：{e}")
        return None
```

#### 统计摘要生成
```python
def create_summary_sheet(writer, merged_df, info_df, performance_df):
    """创建数据统计摘要表"""
    summary_data = {
        '统计项目': [
            '员工基本信息总数',
            '员工绩效记录总数', 
            '合并后总记录数',
            '有绩效数据员工数',
            '无绩效数据员工数',
            '平均综合得分'
        ],
        '数值': [
            len(info_df),
            len(performance_df),
            len(merged_df),
            merged_df['综合得分'].notna().sum(),
            merged_df['综合得分'].isna().sum(),
            round(merged_df['综合得分'].mean(), 2)
        ]
    }
    
    summary_df = pd.DataFrame(summary_data)
    summary_df.to_excel(writer, sheet_name='数据统计摘要', index=False)
```

### 3. 疫情数据处理模块

#### 数据处理器类
```python
class CovidDataProcessor:
    """疫情数据处理器"""
    
    def __init__(self):
        self.data_file = Path(__file__).parent / "香港各区疫情数据_20250322.xlsx"
        self.df = None
        self.load_data()
    
    def load_data(self):
        """加载疫情数据"""
        try:
            if self.data_file.exists():
                self.df = pd.read_excel(self.data_file)
                print(f"成功加载数据：{len(self.df)} 条记录")
        except Exception as e:
            print(f"数据加载失败：{e}")
    
    def get_daily_summary(self):
        """获取每日汇总数据"""
        if self.df is None:
            return {"dates": [], "new_cases": [], "total_cases": []}
        
        daily_data = self.df.groupby('日期').agg({
            '新增确诊': 'sum',
            '累计确诊': 'sum'
        }).reset_index()
        
        return {
            "dates": daily_data['日期'].tolist(),
            "new_cases": daily_data['新增确诊'].tolist(),
            "total_cases": daily_data['累计确诊'].tolist()
        }
    
    def get_district_distribution(self):
        """获取各区域疫情分布"""
        if self.df is None:
            return []
        
        latest_date = self.df['日期'].max()
        latest_data = self.df[self.df['日期'] == latest_date]
        
        district_data = latest_data.groupby('地区').agg({
            '新增确诊': 'sum',
            '累计确诊': 'sum',
            '现有确诊': 'sum'
        }).reset_index()
        
        result = []
        for _, row in district_data.iterrows():
            result.append({
                "name": row['地区'],
                "value": int(row['累计确诊']),
                "new_cases": int(row['新增确诊']),
                "active_cases": int(row['现有确诊'])
            })
        
        return sorted(result, key=lambda x: x['value'], reverse=True)
```

## 可视化大屏实现

### 1. Flask服务实现

#### 主应用类
```python
from flask import Flask, render_template, jsonify

app = Flask(__name__)

# 创建数据处理器实例
data_processor = CovidDataProcessor()

@app.route('/')
def dashboard():
    """主页路由 - 显示可视化大屏"""
    return render_template('dashboard.html')

@app.route('/api/daily_summary')
def api_daily_summary():
    """每日汇总数据API"""
    data = data_processor.get_daily_summary()
    return jsonify(data)

@app.route('/api/district_distribution')
def api_district_distribution():
    """区域分布数据API"""
    data = data_processor.get_district_distribution()
    return jsonify(data)

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5001)
```

### 2. 医院病床数据处理器

```python
class HospitalBedDataProcessor:
    """医院病床数据处理器"""
    
    def __init__(self):
        self.data_file = Path(__file__).parent / "医院病床数据.xlsx"
        self.df = None
        self.load_data()
    
    def generate_mock_data(self):
        """生成模拟病床数据"""
        departments = [
            {'name': '内科', 'total_beds': 120, 'floor': 2},
            {'name': '外科', 'total_beds': 100, 'floor': 3},
            {'name': '儿科', 'total_beds': 80, 'floor': 4},
            {'name': 'ICU', 'total_beds': 40, 'floor': 6}
        ]
        
        data = []
        for dept in departments:
            base_occupancy = random.uniform(0.7, 0.95)
            occupied_beds = int(dept['total_beds'] * base_occupancy)
            
            data.append({
                'department': dept['name'],
                'total_beds': dept['total_beds'],
                'occupied_beds': occupied_beds,
                'available_beds': dept['total_beds'] - occupied_beds,
                'occupancy_rate': round(occupied_beds / dept['total_beds'] * 100, 1),
                'floor': dept['floor']
            })
        
        self.df = pd.DataFrame(data)
    
    def get_key_indicators(self):
        """获取关键指标数据"""
        if self.df is None:
            return {}
        
        total_beds = self.df['total_beds'].sum()
        total_occupied = self.df['occupied_beds'].sum()
        
        return {
            "total_beds": int(total_beds),
            "occupied_beds": int(total_occupied),
            "available_beds": int(total_beds - total_occupied),
            "occupancy_rate": round(total_occupied / total_beds * 100, 1)
        }
```

### 3. ECharts图表配置

#### 地图可视化
```javascript
// 疫情地图配置
const mapOption = {
    tooltip: {
        trigger: 'item',
        formatter: function (params) {
            return `${params.name}<br/>累计确诊: ${params.value}例`;
        }
    },
    visualMap: {
        min: 0,
        max: 1000,
        inRange: {
            color: ['#1dd1a1', '#48dbfb', '#feca57', '#ff9ff3', '#ff4757']
        }
    },
    series: [{
        name: '疫情分布',
        type: 'map',
        map: 'HongKong',
        data: mapData
    }]
};
```

#### 仪表盘配置
```javascript
// 关键指标仪表盘
const gaugeOption = {
    series: [{
        name: '恢复率',
        type: 'gauge',
        radius: '65%',
        min: 0,
        max: 100,
        data: [{ value: 85.2, name: '恢复率%' }],
        axisLine: {
            lineStyle: {
                color: [[0.3, '#fd666d'], [0.7, '#feca57'], [1, '#67e0e3']],
                width: 6
            }
        },
        detail: {
            fontSize: 16,
            formatter: '{value}%'
        }
    }]
};
```

## 错误处理和调试机制

### 1. 异常处理策略

```python
def safe_read_excel(file_path):
    """安全读取Excel文件"""
    try:
        df = pd.read_excel(file_path)
        return df
    except FileNotFoundError:
        logger.error(f"文件不存在: {file_path}")
        return None
    except pd.errors.EmptyDataError:
        logger.error(f"文件为空: {file_path}")
        return None
    except Exception as e:
        logger.error(f"读取文件失败: {e}")
        return None
```

### 2. 数据验证

```python
def validate_employee_data(df):
    """验证员工数据完整性"""
    required_columns = ['员工编号', '姓名', '部门']
    
    for col in required_columns:
        if col not in df.columns:
            raise ValueError(f"缺少必需列: {col}")
    
    if df['员工编号'].duplicated().any():
        raise ValueError("员工编号存在重复")
    
    return True
```

### 3. 日志记录

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

def process_data(file_path):
    """处理数据并记录日志"""
    logger.info(f"开始处理文件: {file_path}")
    try:
        df = pd.read_excel(file_path)
        logger.info(f"成功读取 {len(df)} 条记录")
        return df
    except Exception as e:
        logger.error(f"处理失败: {e}")
        raise
```

---

*最后更新: 2026年2月21日*
*代码实现版本: v1.0*
*开发团队: AI系统开发组*
