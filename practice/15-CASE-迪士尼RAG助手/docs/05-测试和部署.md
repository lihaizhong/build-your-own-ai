# 迪士尼RAG问答助手 - 测试和部署

## 测试策略

### 测试金字塔

```
                    ┌─────────────┐
                    │   E2E测试   │  (端到端测试)
                    │   10%       │
                ┌───┴─────────────┴───┐
                │     集成测试        │  (模块间交互)
                │       30%           │
            ┌───┴─────────────────────┴───┐
            │         单元测试            │  (函数级别)
            │           60%               │
            └─────────────────────────────┘
```

### 测试分类

| 测试类型 | 覆盖范围 | 频率 |
|----------|----------|------|
| 单元测试 | 各模块函数 | 每次提交 |
| 集成测试 | 模块间交互 | 每日构建 |
| 功能测试 | 完整功能流程 | 每周 |
| 性能测试 | 响应时间、并发 | 每周 |
| 回归测试 | 全量功能 | 每次发布 |

---

## 单元测试

### 测试目录结构

```
tests/
├── __init__.py
├── conftest.py              # 测试配置和fixtures
├── test_config.py           # 配置模块测试
├── test_data_processor.py   # 数据处理层测试
├── test_embedding.py        # 向量化层测试
├── test_retrieval.py        # 检索层测试
└── test_generator.py        # 生成层测试
```

### 测试配置 (conftest.py)

```python
import pytest
from pathlib import Path
import sys

# 添加项目路径
sys.path.insert(0, str(Path(__file__).parent.parent / "code"))

from config import Config

@pytest.fixture
def test_config():
    """测试配置"""
    config = Config()
    config.documents_dir = Path(__file__).parent / "test_data" / "documents"
    config.images_dir = Path(__file__).parent / "test_data" / "images"
    config.indexes_dir = Path(__file__).parent / "test_data" / "indexes"
    return config

@pytest.fixture
def sample_text_chunk():
    """示例文本块"""
    from data_processor import TextChunk
    return TextChunk(
        text="迪士尼乐园是全球知名的主题公园。",
        source="test.docx",
        page=1,
        metadata={"type": "paragraph"}
    )

@pytest.fixture
def sample_image_data():
    """示例图像数据"""
    from data_processor import ImageData
    return ImageData(
        image_path=Path("test_data/images/test.jpg"),
        ocr_text="迪士尼城堡",
        metadata={"file_name": "test.jpg"}
    )
```

### 数据处理层测试

```python
# tests/test_data_processor.py

import pytest
from pathlib import Path
from data_processor import DocumentProcessor, ImageProcessor, TextChunk

class TestDocumentProcessor:
    """文档处理器测试"""
    
    def test_process_text_file(self, test_config, tmp_path):
        """测试文本文件处理"""
        # 创建测试文件
        test_file = tmp_path / "test.txt"
        test_file.write_text("这是一个测试文档。", encoding="utf-8")
        
        processor = DocumentProcessor(documents_dir=tmp_path)
        chunks = processor.process_file(test_file)
        
        assert len(chunks) > 0
        assert "测试文档" in chunks[0].text
    
    def test_process_docx_file(self, test_config):
        """测试Word文档处理"""
        processor = DocumentProcessor()
        # 假设有测试文档
        test_file = Path("tests/test_data/documents/test.docx")
        
        if test_file.exists():
            chunks = processor.process_file(test_file)
            assert isinstance(chunks, list)
            if chunks:
                assert isinstance(chunks[0], TextChunk)
    
    def test_unsupported_format(self, test_config, tmp_path):
        """测试不支持的格式"""
        test_file = tmp_path / "test.xyz"
        test_file.write_text("test content")
        
        processor = DocumentProcessor(documents_dir=tmp_path)
        chunks = processor.process_file(test_file)
        
        assert chunks == []
    
    def test_chunk_creation(self, sample_text_chunk):
        """测试文本块创建"""
        assert sample_text_chunk.text == "迪士尼乐园是全球知名的主题公园。"
        assert sample_text_chunk.source == "test.docx"
        assert sample_text_chunk.page == 1

class TestImageProcessor:
    """图像处理器测试"""
    
    def test_process_image(self, test_config):
        """测试图像处理"""
        processor = ImageProcessor()
        test_image = Path("tests/test_data/images/test.jpg")
        
        if test_image.exists():
            image_data = processor.process_image(test_image)
            assert image_data.image_path == test_image
            assert isinstance(image_data.ocr_text, str)
    
    def test_ocr_extraction(self, test_config):
        """测试OCR提取"""
        processor = ImageProcessor()
        # 需要有Tesseract支持
        # 可以使用mock跳过实际OCR
        pass
```

### 向量化层测试

```python
# tests/test_embedding.py

import pytest
import numpy as np
from unittest.mock import Mock, patch
from embedding import TextEmbeddingModel, ImageEmbeddingModel, FAISSIndex

class TestTextEmbeddingModel:
    """文本Embedding模型测试"""
    
    @patch('embedding.TextEmbedding.call')
    def test_embed_text(self, mock_call):
        """测试文本向量化"""
        # Mock API响应
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.output = {
            'embeddings': [{'embedding': [0.1] * 1024}]
        }
        mock_call.return_value = mock_response
        
        model = TextEmbeddingModel(api_key="test_key")
        embedding = model.embed_text("测试文本")
        
        assert len(embedding) == 1024
        assert all(isinstance(x, float) for x in embedding)
    
    def test_embed_empty_text(self):
        """测试空文本处理"""
        model = TextEmbeddingModel(api_key="test_key")
        embedding = model.embed_text("")
        
        assert len(embedding) == 1024
        assert all(x == 0.0 for x in embedding)

class TestFAISSIndex:
    """FAISS索引测试"""
    
    def test_create_index(self):
        """测试索引创建"""
        index = FAISSIndex(embedding_dim=128)
        assert index.size == 0
    
    def test_add_vectors(self):
        """测试添加向量"""
        index = FAISSIndex(embedding_dim=128)
        vectors = np.random.randn(10, 128).astype(np.float32)
        documents = [{"id": i} for i in range(10)]
        
        index.add_vectors(vectors, documents)
        
        assert index.size == 10
        assert len(index.documents) == 10
    
    def test_search(self):
        """测试向量搜索"""
        index = FAISSIndex(embedding_dim=128)
        vectors = np.random.randn(10, 128).astype(np.float32)
        documents = [{"id": i} for i in range(10)]
        index.add_vectors(vectors, documents)
        
        query = vectors[0]  # 使用第一个向量作为查询
        results = index.search(query, k=3)
        
        assert len(results) <= 3
        assert results[0][0] == 0  # 第一个结果应该是自身
    
    def test_save_and_load(self, tmp_path):
        """测试保存和加载"""
        index = FAISSIndex(embedding_dim=128)
        vectors = np.random.randn(5, 128).astype(np.float32)
        documents = [{"id": i} for i in range(5)]
        index.add_vectors(vectors, documents)
        
        # 保存
        index_path = tmp_path / "test_index.faiss"
        docs_path = tmp_path / "test_docs.pkl"
        index.save(index_path, docs_path)
        
        # 加载
        new_index = FAISSIndex(embedding_dim=128)
        new_index.load(index_path, docs_path)
        
        assert new_index.size == 5
        assert len(new_index.documents) == 5
```

### 检索层测试

```python
# tests/test_retrieval.py

import pytest
from unittest.mock import Mock, patch
from retrieval import TextRetriever, ImageRetriever, HybridRetriever, RetrievalResult

class TestTextRetriever:
    """文本检索器测试"""
    
    def test_retrieve(self, test_config):
        """测试文本检索"""
        # 创建mock vector store
        mock_store = Mock()
        mock_store.text_index = Mock()
        mock_store.text_index.size = 10
        mock_store.text_embedding_model = Mock()
        mock_store.text_embedding_model.embed_text.return_value = [0.1] * 1024
        mock_store.text_index.search.return_value = [(0, 0.5), (1, 0.6)]
        mock_store.text_index.documents = [
            Mock(text="测试内容1", source="test1.txt", metadata={}),
            Mock(text="测试内容2", source="test2.txt", metadata={})
        ]
        
        retriever = TextRetriever(mock_store)
        results = retriever.retrieve("测试查询")
        
        assert isinstance(results, list)
    
    def test_empty_index(self):
        """测试空索引处理"""
        mock_store = Mock()
        mock_store.text_index = None
        
        retriever = TextRetriever(mock_store)
        results = retriever.retrieve("测试查询")
        
        assert results == []

class TestHybridRetriever:
    """混合检索器测试"""
    
    def test_image_keyword_detection(self):
        """测试图像关键词检测"""
        mock_store = Mock()
        mock_store.text_index = None
        mock_store.image_index = None
        
        retriever = HybridRetriever(mock_store)
        
        # 应该触发图像检索的查询
        assert retriever._should_trigger_image_search("展示一下海报")
        assert retriever._should_trigger_image_search("有没有图片")
        
        # 不应该触发图像检索的查询
        assert not retriever._should_trigger_image_search("迪士尼门票价格")
    
    def test_retrieve(self):
        """测试混合检索"""
        mock_store = Mock()
        mock_store.text_index = Mock()
        mock_store.text_index.size = 0
        mock_store.image_index = Mock()
        mock_store.image_index.size = 0
        
        retriever = HybridRetriever(mock_store)
        results = retriever.retrieve("测试查询")
        
        assert "text" in results
        assert "image" in results
```

### 生成层测试

```python
# tests/test_generator.py

import pytest
from unittest.mock import Mock, patch
from generator import PromptBuilder, AnswerGenerator, RAGPipeline

class TestPromptBuilder:
    """提示词构建器测试"""
    
    def test_build_context_with_text(self):
        """测试构建文本上下文"""
        builder = PromptBuilder()
        
        results = {
            "text": [
                RetrievalResult(
                    content="迪士尼乐园信息",
                    source="test.txt",
                    score=0.85,
                    metadata={}
                )
            ],
            "image": []
        }
        
        context = builder.build_context(results)
        
        assert "相关文档信息" in context
        assert "迪士尼乐园信息" in context
    
    def test_build_context_with_image(self):
        """测试构建图像上下文"""
        builder = PromptBuilder()
        
        results = {
            "text": [],
            "image": [
                RetrievalResult(
                    content="迪士尼城堡",
                    source="test.jpg",
                    score=0.8,
                    metadata={},
                    result_type="image"
                )
            ]
        }
        
        context = builder.build_context(results)
        
        assert "相关图像信息" in context
        assert "迪士尼城堡" in context

class TestAnswerGenerator:
    """答案生成器测试"""
    
    @patch('generator.OpenAI')
    def test_generate(self, mock_openai):
        """测试答案生成"""
        mock_client = Mock()
        mock_response = Mock()
        mock_response.choices = [Mock(message=Mock(content="测试答案"))]
        mock_client.chat.completions.create.return_value = mock_response
        mock_openai.return_value = mock_client
        
        generator = AnswerGenerator(api_key="test_key")
        answer = generator.generate("测试问题", {"text": [], "image": []})
        
        assert answer == "测试答案"

class TestRAGPipeline:
    """RAG管道测试"""
    
    def test_query(self):
        """测试完整查询流程"""
        mock_retriever = Mock()
        mock_retriever.retrieve.return_value = {"text": [], "image": []}
        
        mock_generator = Mock()
        mock_generator.generate.return_value = "测试答案"
        
        pipeline = RAGPipeline(mock_retriever, mock_generator)
        result = pipeline.query("测试问题")
        
        assert result["answer"] == "测试答案"
        assert result["question"] == "测试问题"
```

### 运行测试

```bash
# 运行所有测试
cd practice/15-CASE-迪士尼RAG助手
python -m pytest tests/ -v

# 运行特定测试文件
python -m pytest tests/test_data_processor.py -v

# 运行特定测试类
python -m pytest tests/test_embedding.py::TestFAISSIndex -v

# 带覆盖率报告
python -m pytest tests/ --cov=code --cov-report=html
```

---

## 集成测试

### 端到端测试

```python
# tests/test_integration.py

import pytest
from pathlib import Path
from config import config, load_env_config
from data_processor import DocumentProcessor, ImageProcessor
from embedding import VectorStore
from retrieval import HybridRetriever
from generator import AnswerGenerator, RAGPipeline

class TestEndToEnd:
    """端到端集成测试"""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """测试环境设置"""
        load_env_config()
        self.vector_store = VectorStore()
    
    def test_full_pipeline(self, tmp_path):
        """测试完整流程"""
        # 1. 创建测试文档
        test_doc = tmp_path / "test.txt"
        test_doc.write_text("迪士尼乐园位于上海浦东新区。")
        
        # 2. 处理文档
        processor = DocumentProcessor(documents_dir=tmp_path)
        chunks = processor.process_directory()
        assert len(chunks) > 0
        
        # 3. 构建索引
        self.vector_store.build_text_index(chunks)
        assert self.vector_store.text_index.size > 0
        
        # 4. 检索
        retriever = HybridRetriever(self.vector_store)
        results = retriever.retrieve("迪士尼乐园在哪里？")
        assert len(results["text"]) > 0
    
    @pytest.mark.skipif(
        not Path("user_data/indexes/text_index.faiss").exists(),
        reason="索引文件不存在"
    )
    def test_query_with_existing_index(self):
        """测试使用已有索引查询"""
        self.vector_store.load_indexes()
        
        retriever = HybridRetriever(self.vector_store)
        generator = AnswerGenerator()
        pipeline = RAGPipeline(retriever, generator)
        
        result = pipeline.query("迪士尼门票价格")
        
        assert "answer" in result
        assert len(result["answer"]) > 0
```

### API集成测试

```python
# tests/test_api_integration.py

import pytest
import os
from unittest.mock import patch

class TestDashScopeIntegration:
    """DashScope API集成测试"""
    
    @pytest.mark.skipif(
        not os.environ.get("DASHSCOPE_API_KEY"),
        reason="需要API密钥"
    )
    def test_text_embedding_api(self):
        """测试文本Embedding API"""
        from embedding import TextEmbeddingModel
        
        model = TextEmbeddingModel()
        embedding = model.embed_text("测试文本")
        
        assert len(embedding) == 1024
        assert all(isinstance(x, float) for x in embedding)
    
    @pytest.mark.skipif(
        not os.environ.get("DASHSCOPE_API_KEY"),
        reason="需要API密钥"
    )
    def test_llm_generation_api(self):
        """测试LLM生成API"""
        from generator import AnswerGenerator
        
        generator = AnswerGenerator()
        answer = generator.generate(
            "迪士尼有哪些经典动画？",
            {"text": [], "image": []}
        )
        
        assert isinstance(answer, str)
        assert len(answer) > 0
```

---

## 性能测试

### 响应时间测试

```python
# tests/test_performance.py

import pytest
import time
from config import load_env_config
from embedding import VectorStore
from retrieval import HybridRetriever
from generator import AnswerGenerator, RAGPipeline

class TestPerformance:
    """性能测试"""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        load_env_config()
        self.vector_store = VectorStore()
        self.vector_store.load_indexes()
    
    def test_retrieval_latency(self):
        """测试检索延迟"""
        retriever = HybridRetriever(self.vector_store)
        
        # 执行多次取平均
        latencies = []
        for _ in range(10):
            start = time.time()
            retriever.retrieve("迪士尼门票价格")
            latencies.append(time.time() - start)
        
        avg_latency = sum(latencies) / len(latencies)
        print(f"平均检索延迟: {avg_latency*1000:.2f}ms")
        
        # 检索延迟应该小于500ms
        assert avg_latency < 0.5
    
    def test_generation_latency(self):
        """测试生成延迟"""
        retriever = HybridRetriever(self.vector_store)
        generator = AnswerGenerator()
        pipeline = RAGPipeline(retriever, generator)
        
        start = time.time()
        result = pipeline.query("迪士尼门票价格")
        latency = time.time() - start
        
        print(f"生成延迟: {latency:.2f}s")
        
        # 完整查询延迟应该小于10秒
        assert latency < 10.0
    
    def test_concurrent_queries(self):
        """测试并发查询"""
        import concurrent.futures
        
        retriever = HybridRetriever(self.vector_store)
        generator = AnswerGenerator()
        pipeline = RAGPipeline(retriever, generator)
        
        queries = [
            "迪士尼门票价格",
            "迪士尼在哪里",
            "迪士尼酒店信息"
        ] * 3  # 9个并发查询
        
        start = time.time()
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            futures = [executor.submit(pipeline.query, q) for q in queries]
            results = [f.result() for f in concurrent.futures.as_completed(futures)]
        
        total_time = time.time() - start
        print(f"并发查询总时间: {total_time:.2f}s")
        
        assert len(results) == 9
```

### 内存使用测试

```python
import tracemalloc
import pytest

class TestMemoryUsage:
    """内存使用测试"""
    
    def test_index_loading_memory(self):
        """测试索引加载内存"""
        tracemalloc.start()
        
        from embedding import VectorStore
        vector_store = VectorStore()
        vector_store.load_indexes()
        
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        
        print(f"索引加载内存使用: {peak / 1024 / 1024:.2f} MB")
        
        # 内存使用应该小于500MB
        assert peak < 500 * 1024 * 1024
```

---

## 部署策略

### 开发环境部署

```bash
# 1. 克隆项目
git clone https://github.com/lihaizhong/build-your-own-ai.git
cd build-your-own-ai

# 2. 创建虚拟环境
uv venv --python 3.11
source .venv/bin/activate

# 3. 安装依赖
uv sync

# 4. 配置环境变量
cp .env.example .env
# 编辑.env填入API密钥

# 5. 进入项目目录
cd practice/15-CASE-迪士尼RAG助手

# 6. 构建索引
python -m code.main --build

# 7. 启动服务
python -m code.main --interactive
```

### Docker部署

#### Dockerfile

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    tesseract-ocr \
    tesseract-ocr-chi-sim \
    libgl1-mesa-glx \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# 设置工作目录
WORKDIR /app

# 安装uv
RUN pip install uv

# 复制项目文件
COPY pyproject.toml uv.lock ./
RUN uv sync

COPY practice/15-CASE-迪士尼RAG助手 ./disney-rag

# 设置环境变量
ENV PYTHONPATH=/app/disney-rag

# 暴露端口（如果需要Web服务）
EXPOSE 8000

# 启动命令
CMD ["uv", "run", "python", "-m", "disney-rag.code.main", "--interactive"]
```

#### docker-compose.yml

```yaml
version: '3.8'

services:
  disney-rag:
    build:
      context: ../..
      dockerfile: practice/15-CASE-迪士尼RAG助手/Dockerfile
    container_name: disney-rag
    environment:
      - DASHSCOPE_API_KEY=${DASHSCOPE_API_KEY}
    volumes:
      - ./data:/app/disney-rag/data
      - ./user_data:/app/disney-rag/user_data
    ports:
      - "8000:8000"
    restart: unless-stopped
```

#### 构建和运行

```bash
# 构建镜像
docker-compose build

# 启动服务
docker-compose up -d

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down
```

### 生产环境部署

#### 系统要求

| 组件 | 最低要求 | 推荐配置 |
|------|----------|----------|
| CPU | 2核 | 4核+ |
| 内存 | 4GB | 8GB+ |
| 存储 | 10GB | 50GB+ SSD |
| 网络 | 10Mbps | 100Mbps+ |

#### Nginx配置

```nginx
# /etc/nginx/sites-available/disney-rag
upstream disney_rag {
    server 127.0.0.1:8000;
}

server {
    listen 80;
    server_name your-domain.com;
    
    location / {
        proxy_pass http://disney_rag;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 流式输出支持
        proxy_buffering off;
        proxy_cache off;
    }
}
```

#### Systemd服务

```ini
# /etc/systemd/system/disney-rag.service
[Unit]
Description=Disney RAG Q&A Assistant
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/disney-rag
ExecStart=/opt/disney-rag/.venv/bin/python -m code.main --interactive
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

---

## 监控和日志

### 日志配置

```python
# 日志配置已在main.py中设置
from loguru import logger
import sys

# 控制台输出
logger.add(
    sys.stdout,
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <level>{message}</level>",
    level="INFO"
)

# 文件输出
logger.add(
    "output/logs/disney_rag_{time:YYYY-MM-DD}.log",
    rotation="1 day",
    retention="7 days",
    level="DEBUG"
)
```

### 监控指标

```python
# 可选：添加Prometheus监控
from prometheus_client import Counter, Histogram, start_http_server

# 定义指标
QUERY_COUNT = Counter('disney_rag_query_total', 'Total queries')
QUERY_LATENCY = Histogram('disney_rag_query_latency_seconds', 'Query latency')

@QUERY_LATENCY.time()
def process_query(question: str):
    QUERY_COUNT.inc()
    # ... 处理查询
```

### 健康检查

```python
# health_check.py
def health_check():
    """健康检查"""
    checks = {
        "api_key": bool(os.environ.get("DASHSCOPE_API_KEY")),
        "text_index": Path("user_data/indexes/text_index.faiss").exists(),
        "image_index": Path("user_data/indexes/image_index.faiss").exists(),
    }
    
    all_healthy = all(checks.values())
    return {
        "status": "healthy" if all_healthy else "unhealthy",
        "checks": checks
    }
```

---

## CI/CD流水线

### GitHub Actions

```yaml
# .github/workflows/disney-rag.yml
name: Disney RAG CI/CD

on:
  push:
    paths:
      - 'practice/15-CASE-迪士尼RAG助手/**'
  pull_request:
    paths:
      - 'practice/15-CASE-迪士尼RAG助手/**'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install uv
        run: pip install uv
      
      - name: Install dependencies
        run: uv sync
      
      - name: Run tests
        run: |
          cd practice/15-CASE-迪士尼RAG助手
          uv run pytest tests/ -v
        env:
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          files: ./coverage.xml
  
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      
      - name: Build Docker image
        run: |
          cd practice/15-CASE-迪士尼RAG助手
          docker build -t disney-rag:${{ github.sha }} .
      
      - name: Push to registry
        run: |
          docker tag disney-rag:${{ github.sha }} your-registry/disney-rag:latest
          docker push your-registry/disney-rag:latest
```

---

## 部署验证

### 验证清单

```bash
# 1. 检查服务状态
curl http://localhost:8000/health

# 2. 验证索引
ls -la user_data/indexes/

# 3. 测试查询
python -m code.main -q "迪士尼门票价格"

# 4. 检查日志
tail -f output/logs/disney_rag_*.log

# 5. 验证API连接
python -c "
from code.config import load_env_config
from code.embedding import TextEmbeddingModel
load_env_config()
model = TextEmbeddingModel()
print('API连接成功' if model.embed_text('test') else 'API连接失败')
"
```

### 回滚策略

```bash
# 1. 备份当前版本
cp -r user_data/indexes user_data/indexes.backup

# 2. 回滚到上一版本
docker tag your-registry/disney-rag:previous your-registry/disney-rag:latest
docker-compose up -d

# 3. 验证回滚
curl http://localhost:8000/health
```

---

*最后更新: 2026年2月15日*
*文档版本: v1.0*
