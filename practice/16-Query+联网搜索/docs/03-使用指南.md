# Query+联网搜索改写系统 - 使用指南

## 环境准备

### 1. 系统要求
- **Python**: 3.11+（推荐3.14）
- **操作系统**: macOS / Linux / Windows
- **网络**: 需要访问阿里云DashScope API

### 2. 依赖安装

#### 使用uv（推荐）
```bash
# 在项目根目录
cd practice/16-Query+联网搜索

# 使用根目录的虚拟环境
# 或创建独立环境
uv venv --python 3.11
source .venv/bin/activate

# 安装依赖
uv pip install openai python-dotenv loguru
```

#### 使用pip
```bash
pip install openai python-dotenv loguru
```

### 3. API密钥配置

#### 创建环境变量文件
在项目根目录创建 `.env` 文件：

```bash
# 在项目根目录
cd /path/to/build-your-own-ai

# 创建 .env 文件
cat > .env << EOF
DASHSCOPE_API_KEY=your_api_key_here
EOF
```

#### 获取API密钥
1. 访问 [阿里云DashScope控制台](https://dashscope.console.aliyun.com/)
2. 创建API Key
3. 将API Key填入 `.env` 文件

### 4. 验证环境
```bash
# 进入项目目录
cd practice/16-Query+联网搜索

# 运行测试
uv run python code/main.py
```

## 快速开始

### 1. 基础使用

#### 运行演示程序
```bash
cd practice/16-Query+联网搜索
uv run python code/main.py
```

**预期输出：**
```
╔══════════════════════════════════════════════════════════╗
║                                                          ║
║        Query + 联网搜索改写系统 v1.0.0                   ║
║                                                          ║
║     自动判断搜索需求 · 智能改写查询 · 生成搜索策略       ║
║                                                          ║
╚══════════════════════════════════════════════════════════╝

============================================================
 基础功能演示
============================================================

【天气查询】
查询: 今天北京的天气怎么样？
✓ 需要联网搜索
  类型: 天气
  改写: 北京天气 2026年2月15日
  关键词: 北京, 天气, 今天
  平台: 中国天气网, 墨迹天气, 百度
...
```

### 2. Python代码调用

#### 导入模块
```python
# 方式1：导入完整管道
from pipeline import WebSearchPipeline

# 方式2：导入单独模块
from query_classifier import QueryClassifier
from query_rewriter import WebQueryRewriter
from search_strategy import SearchStrategyGenerator
```

#### 完整处理流程
```python
from pipeline import WebSearchPipeline

# 创建管道实例
pipeline = WebSearchPipeline()

# 处理查询
result = pipeline.process("今天北京的天气怎么样？")

# 输出结果
print(result.format_summary())
```

#### 快速处理
```python
# 快速处理，只返回关键信息
result = pipeline.quick_process("最新的iPhone价格是多少？")

print(result)
# {
#     "need_web_search": True,
#     "search_type": "时效性",
#     "rewritten_query": "iPhone 最新价格 2026年2月",
#     "keywords": ["iPhone", "价格", "最新"],
#     "platforms": ["Google", "百度", "必应"]
# }
```

### 3. 单独模块使用

#### 仅使用分类器
```python
from query_classifier import QueryClassifier

classifier = QueryClassifier()

# 完整分类
result = classifier.classify("今天天气怎么样？")
print(result["search_type"])  # 天气
print(result["need_web_search"])  # True

# 快速分类
search_type = classifier.quick_classify("什么是RAG？")
print(search_type)  # SearchNeedType.NOT_NEEDED
```

#### 仅使用改写器
```python
from query_rewriter import WebQueryRewriter
from query_classifier import SearchNeedType

rewriter = WebQueryRewriter()

# 改写查询
result = rewriter.rewrite(
    query="今天天气怎么样？",
    search_type=SearchNeedType.WEATHER
)

print(result["rewritten_query"])  # 北京天气 2026年2月15日
print(result["keywords"])  # ["天气", "今天", "北京"]
```

#### 仅生成搜索策略
```python
from search_strategy import SearchStrategyGenerator
from query_classifier import SearchNeedType

generator = SearchStrategyGenerator()

strategy = generator.generate(
    query="北京天气 2026年2月",
    search_type=SearchNeedType.WEATHER,
    keywords=["北京", "天气"]
)

print(strategy.platforms)  # ["中国天气网", "墨迹天气", "百度"]
print(strategy.search_operators)  # ['"北京天气"']
```

## 交互式使用

### 1. 启动交互模式
```bash
cd practice/16-Query+联网搜索
uv run python code/main.py
```

在演示结束后，输入 `y` 进入交互模式。

### 2. 交互示例
```
请输入查询: 今天上海的天气如何？

============================================================
原始查询: 今天上海的天气如何？
------------------------------------------------------------
需要联网搜索: 是
搜索类型: 天气
判断理由: 查询包含天气相关词汇，需要获取实时天气信息

改写后查询: 上海天气 2026年2月15日
关键词: 上海, 天气, 今天

推荐平台: 中国天气网, 墨迹天气, 百度
搜索操作符: "上海天气"
优先级: 4/5
搜索建议: 建议使用中国天气网获取官方数据

搜索链接:
  - 中国天气网: http://www.weather.com.cn/weather/上海天气.shtml
  - 墨迹天气: https://tianqi.moji.com/weather/china/shanghai
============================================================

请输入查询: 什么是机器学习？

============================================================
原始查询: 什么是机器学习？
------------------------------------------------------------
需要联网搜索: 否
判断理由: 这是一个通用知识问题，可以使用已有知识库回答

建议: 使用本地知识库或已有数据回答
============================================================
```

### 3. JSON输出模式
```
请输入查询: json
当前为JSON输出模式，输入查询查看JSON结果

请输入查询: 今天天气

{
  "original_query": "今天天气",
  "need_web_search": true,
  "search_type": "天气",
  "classification_reason": "查询包含天气相关词汇",
  "rewritten_query": "天气 2026年2月15日",
  "keywords": ["天气", "今天"],
  "platforms": ["中国天气网", "墨迹天气", "百度"],
  "search_operators": ["\"天气\""],
  "priority": 3,
  "notes": "建议查询具体城市天气",
  "search_urls": {...}
}
```

## 批量处理

### 1. 批量处理示例
```python
from pipeline import WebSearchPipeline

pipeline = WebSearchPipeline()

queries = [
    "今天天气",
    "最新新闻",
    "股价行情",
    "什么是机器学习",
    "最近的科技动态"
]

# 批量处理
results = pipeline.process_batch(queries)

# 输出结果
for i, result in enumerate(results, 1):
    print(f"{i}. {result.original_query}")
    print(f"   需要: {'联网搜索' if result.need_web_search else '本地知识库'}")
    print(f"   类型: {result.search_type}")
    if result.rewritten_query:
        print(f"   改写: {result.rewritten_query}")
    print()
```

### 2. 输出示例
```
1. 今天天气
   需要: 联网搜索
   类型: 天气
   改写: 天气 2026年2月15日

2. 最新新闻
   需要: 联网搜索
   类型: 新闻资讯
   改写: 最新新闻 2026年2月

3. 股价行情
   需要: 联网搜索
   类型: 价格行情

4. 什么是机器学习
   需要: 本地知识库
   类型: 不需要联网

5. 最近的科技动态
   需要: 联网搜索
   类型: 新闻资讯
```

## 与RAG系统集成

### 1. 基础集成示例
```python
from pipeline import WebSearchPipeline

# 初始化管道
pipeline = WebSearchPipeline()

def enhanced_rag_query(user_query: str):
    """增强的RAG查询流程"""
    
    # Step 1: 判断是否需要联网搜索
    result = pipeline.process(user_query)
    
    if result.need_web_search:
        # 需要联网搜索
        print(f"检测到需要联网搜索: {result.search_type}")
        print(f"改写后查询: {result.rewritten_query}")
        print(f"推荐平台: {result.platforms}")
        
        # 执行联网搜索（需要实现）
        search_results = web_search(
            query=result.rewritten_query,
            platforms=result.platforms
        )
        
        # 结合搜索结果生成答案
        answer = generate_answer_with_context(
            query=user_query,
            context=search_results
        )
    else:
        # 使用本地知识库
        print("使用本地知识库回答")
        answer = rag_query(user_query)
    
    return answer
```

### 2. 完整集成代码
```python
from pipeline import WebSearchPipeline
from typing import Optional, List, Dict

class EnhancedRAGSystem:
    """增强的RAG系统"""
    
    def __init__(self):
        self.pipeline = WebSearchPipeline()
        # 初始化其他组件...
    
    def query(self, user_query: str) -> Dict:
        """处理用户查询"""
        
        # Step 1: 分析查询
        result = self.pipeline.process(user_query)
        
        # Step 2: 根据分析结果选择处理方式
        if result.need_web_search:
            # 联网搜索模式
            response = {
                "mode": "web_search",
                "search_type": result.search_type,
                "search_query": result.rewritten_query,
                "platforms": result.platforms,
                "urls": result.search_urls
            }
            
            # 实际执行搜索（需要实现）
            # response["search_results"] = self._do_search(result)
            
        else:
            # 本地知识库模式
            response = {
                "mode": "local_knowledge",
                "search_type": result.search_type,
                "reason": result.classification_reason
            }
            
            # 实际查询知识库（需要实现）
            # response["answer"] = self._query_knowledge_base(user_query)
        
        return response
    
    def _do_search(self, result) -> List[Dict]:
        """执行联网搜索"""
        # 实现实际的搜索逻辑
        pass
    
    def _query_knowledge_base(self, query: str) -> str:
        """查询本地知识库"""
        # 实现知识库查询逻辑
        pass


# 使用示例
if __name__ == "__main__":
    rag = EnhancedRAGSystem()
    
    # 测试联网搜索场景
    result1 = rag.query("今天北京的天气怎么样？")
    print(result1)
    
    # 测试本地知识库场景
    result2 = rag.query("什么是RAG技术？")
    print(result2)
```

## API调用详解

### 1. WebSearchPipeline API

#### `process(query, generate_urls=True)`
执行完整的处理流程。

**参数：**
- `query` (str): 用户查询
- `generate_urls` (bool): 是否生成搜索URL，默认True

**返回：**
- `PipelineResult`: 处理结果对象

**示例：**
```python
result = pipeline.process("今天天气怎么样？")
print(result.format_summary())
print(result.to_dict())
```

#### `quick_process(query)`
快速处理，只返回关键信息。

**参数：**
- `query` (str): 用户查询

**返回：**
- `dict`: 简化的结果字典

#### `process_batch(queries, generate_urls=True)`
批量处理查询。

**参数：**
- `queries` (list[str]): 查询列表
- `generate_urls` (bool): 是否生成搜索URL

**返回：**
- `list[PipelineResult]`: 处理结果列表

#### `classify_only(query)`
仅执行分类步骤。

#### `rewrite_only(query, search_type_str)`
仅执行改写步骤。

#### `strategy_only(query, search_type_str, keywords)`
仅生成搜索策略。

### 2. QueryClassifier API

#### `classify(query)`
对查询进行分类，判断是否需要联网搜索。

#### `quick_classify(query)`
快速分类，只返回搜索类型枚举。

#### `batch_classify(queries)`
批量分类查询。

### 3. WebQueryRewriter API

#### `rewrite(query, search_type, context=None)`
根据搜索类型改写查询。

#### `extract_keywords(query)`
从查询中提取关键词。

#### `expand_query(query, search_type)`
查询扩展：生成多个相关查询变体。

### 4. SearchStrategyGenerator API

#### `generate(query, search_type, keywords=None)`
生成搜索策略。

#### `get_platform_recommendation(search_type)`
根据搜索类型获取平台推荐。

#### `generate_search_url(query, platform, operator=None)`
生成搜索URL。

## 常见问题解决

### 1. API密钥问题

**问题：** `DASHSCOPE_API_KEY未设置，请检查环境变量`

**解决方案：**
```bash
# 检查环境变量
echo $DASHSCOPE_API_KEY

# 或在代码中检查
import os
print(os.environ.get("DASHSCOPE_API_KEY"))

# 确保在项目根目录的.env文件中设置了API Key
```

### 2. 网络连接问题

**问题：** `LLM调用失败: Connection error`

**解决方案：**
- 检查网络连接
- 确认可以访问 `dashscope.aliyuncs.com`
- 检查防火墙设置

### 3. 模块导入问题

**问题：** `ModuleNotFoundError: No module named 'pipeline'`

**解决方案：**
```bash
# 确保在正确的目录
cd practice/16-Query+联网搜索

# 或使用绝对导入
import sys
sys.path.insert(0, '/path/to/16-Query+联网搜索/code')
```

### 4. JSON解析错误

**问题：** `JSON解析失败`

**解决方案：**
- 这通常是LLM返回格式不规范导致
- 系统会自动返回默认结果
- 可以调整LLM的temperature参数

## 性能调优

### 1. 调整LLM参数
```python
# 在config.py中调整
@dataclass
class Config:
    llm_temperature: float = 0.7   # 调整创造性
    llm_max_tokens: int = 2000     # 调整响应长度
```

### 2. 使用缓存
```python
from functools import lru_cache

@lru_cache(maxsize=100)
def cached_classify(query: str):
    return classifier.classify(query)
```

### 3. 异步处理
```python
import asyncio

async def process_async(query: str):
    # 异步处理逻辑
    pass

# 批量异步处理
async def batch_process_async(queries: list):
    tasks = [process_async(q) for q in queries]
    return await asyncio.gather(*tasks)
```

---

*最后更新: 2026年2月15日*
*文档版本: v1.0*
*维护团队: build-your-own-ai项目团队*
