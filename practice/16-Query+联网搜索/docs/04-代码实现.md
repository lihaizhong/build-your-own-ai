# Query+联网搜索改写系统 - 代码实现详解

## 核心代码结构

### 项目文件概览

```
code/
├── __init__.py              # 模块初始化，导出主要类
├── config.py                # 配置管理模块
├── query_classifier.py      # 查询分类器
├── query_rewriter.py        # 查询改写器
├── search_strategy.py       # 搜索策略生成器
├── pipeline.py              # 整合管道
└── main.py                  # 主程序入口
```

## 配置管理模块

### config.py

配置管理模块负责管理项目的所有配置参数，使用dataclass实现类型安全的配置管理。

```python
"""
配置管理模块
管理项目的所有配置参数
"""

import os
from pathlib import Path
from typing import Dict, Any
from dataclasses import dataclass, field
from dotenv import load_dotenv

load_dotenv(verbose=True)


def get_project_root() -> Path:
    """获取项目根目录"""
    try:
        current_dir = Path(__file__).parent
        project_root = current_dir.parent
        return project_root
    except NameError:
        return Path.cwd()


@dataclass
class Config:
    """配置类"""

    # 路径配置
    project_root: Path = field(default_factory=get_project_root)
    output_dir: Path | None = None

    # LLM配置
    llm_model: str = "qwen-max"
    llm_temperature: float = 0.7
    llm_max_tokens: int = 2000

    # 搜索配置
    search_platforms: list = field(default_factory=lambda: [
        "Google", "百度", "必应", "知乎", "微博", "微信公众号",
        "GitHub", "Stack Overflow", "知乎专栏", "CSDN"
    ])

    # 时效性关键词
    time_sensitive_keywords: list = field(default_factory=lambda: [
        "今天", "昨天", "最近", "最新", "当前", "今年", "本月", "本周",
        "现在", "目前", "即时", "实时", "刚刚", "近期"
    ])

    # 天气相关关键词
    weather_keywords: list = field(default_factory=lambda: [
        "天气", "气温", "温度", "下雨", "晴天", "阴天", "台风",
        "暴雨", "雾霾", "空气质量", "湿度"
    ])

    # 新闻资讯关键词
    news_keywords: list = field(default_factory=lambda: [
        "新闻", "消息", "报道", "事件", "发生", "宣布", "发布",
        "热点", "头条", "动态", "资讯"
    ])

    # 价格行情关键词
    price_keywords: list = field(default_factory=lambda: [
        "价格", "股价", "汇率", "油价", "金价", "行情", "涨跌",
        "股市", "基金", "期货", "比特币"
    ])

    def __post_init__(self):
        """初始化路径"""
        if self.output_dir is None:
            self.output_dir = self.project_root / "output"
        self._ensure_directories()

    def _ensure_directories(self):
        """确保所有目录存在"""
        if self.output_dir is not None:
            self.output_dir.mkdir(parents=True, exist_ok=True)

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        result = {}
        for key, value in self.__dict__.items():
            if isinstance(value, Path):
                result[key] = str(value)
            else:
                result[key] = value
        return result


# 全局配置实例
config = Config()
```

**关键特性：**
- 使用 `@dataclass` 实现类型安全
- 自动创建输出目录
- 支持从环境变量加载配置
- 提供全局配置实例

## 查询分类器详解

### query_classifier.py

查询分类器通过LLM自动判断查询是否需要联网搜索，以及具体的搜索场景类型。

#### SearchNeedType枚举

```python
class SearchNeedType(Enum):
    """搜索需求类型枚举"""
    TIME_SENSITIVE = "时效性"
    WEATHER = "天气"
    NEWS = "新闻资讯"
    PRICE = "价格行情"
    REALTIME_DATA = "实时数据"
    NOT_NEEDED = "不需要联网"
```

#### QueryClassifier类核心实现

```python
class QueryClassifier:
    """查询分类器"""

    SEARCH_SCENARIOS = {
        SearchNeedType.TIME_SENSITIVE: "需要最新、即时或当前时间点的信息",
        SearchNeedType.WEATHER: "需要天气、气温、空气质量等气象相关信息",
        SearchNeedType.NEWS: "需要新闻、热点事件、动态报道等资讯信息",
        SearchNeedType.PRICE: "需要股票、汇率、商品价格等实时行情信息",
        SearchNeedType.REALTIME_DATA: "需要实时变化的数据",
        SearchNeedType.NOT_NEEDED: "不需要联网搜索，可以使用已有知识库回答",
    }

    def __init__(self, model: Optional[str] = None):
        self.model = model or config.llm_model
        self.api_key = os.environ.get("DASHSCOPE_API_KEY")
        
        self.client = OpenAI(
            api_key=self.api_key,
            base_url="https://dashscope.aliyuncs.com/compatible-mode/v1"
        )

    def _call_llm(self, system_prompt: str, user_prompt: str) -> str:
        """调用LLM生成响应"""
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1,  # 分类任务使用较低温度
            max_tokens=500
        )
        return response.choices[0].message.content or ""

    def classify(self, query: str) -> dict:
        """对查询进行分类"""
        # 构建系统提示词
        system_prompt = """你是一个专业的查询分析助手..."""
        
        # 构建用户提示词
        user_prompt = f"""请分析以下查询是否需要联网搜索：
查询：{query}
请以JSON格式返回分析结果..."""

        # 调用LLM并解析结果
        result_text = self._call_llm(system_prompt, user_prompt)
        return self._parse_result(result_text, query)
```

#### 分类提示词设计

```python
system_prompt = """你是一个专业的查询分析助手，负责判断用户查询是否需要联网搜索获取最新信息。

你需要判断以下搜索场景：
1. 时效性 - 需要最新、即时或当前时间点的信息
2. 天气 - 需要天气、气温、空气质量等气象信息
3. 新闻资讯 - 需要新闻、热点事件、动态报道
4. 价格行情 - 需要股票、汇率、商品价格等实时行情
5. 实时数据 - 需要实时变化的数据（如交通、比赛比分等）
6. 不需要联网 - 可以使用已有知识库回答的问题

请根据查询内容，判断是否需要联网搜索，并说明理由。"""

user_prompt = f"""请分析以下查询是否需要联网搜索：

查询：{query}

请以JSON格式返回分析结果：
{{
    "need_web_search": true或false,
    "search_type": "时效性/天气/新闻资讯/价格行情/实时数据/不需要联网",
    "reason": "判断理由",
    "suggested_platforms": ["建议的搜索平台"]
}}"""
```

#### 结果解析

```python
def _parse_result(self, result_text: str, query: str) -> dict:
    """解析LLM返回的结果"""
    import json
    
    try:
        # 提取JSON内容
        json_start = result_text.find("{")
        json_end = result_text.rfind("}") + 1
        json_str = result_text[json_start:json_end]
        result = json.loads(json_str)
        
        return {
            "query": query,
            "need_web_search": result.get("need_web_search", False),
            "search_type": result.get("search_type", "不需要联网"),
            "reason": result.get("reason", ""),
            "suggested_platforms": result.get("suggested_platforms", [])
        }
    except json.JSONDecodeError:
        return {
            "query": query,
            "need_web_search": False,
            "search_type": "不需要联网",
            "reason": "无法解析分类结果",
            "suggested_platforms": []
        }
```

## 查询改写器详解

### query_rewriter.py

查询改写器根据搜索场景类型对查询进行针对性改写，提升搜索效果。

#### WebQueryRewriter类核心实现

```python
class WebQueryRewriter:
    """联网搜索Query改写器"""

    REWRITE_STRATEGIES = {
        SearchNeedType.TIME_SENSITIVE: "添加时间限定词，明确时间范围",
        SearchNeedType.WEATHER: "添加地点和时间限定，使用标准天气查询格式",
        SearchNeedType.NEWS: "添加'最新'、'新闻'等关键词，优化新闻搜索",
        SearchNeedType.PRICE: "添加'实时'、'当前'等关键词，明确查询时间点",
        SearchNeedType.REALTIME_DATA: "添加'实时'、'最新'等关键词",
    }

    def rewrite(self, query: str, search_type: SearchNeedType, 
                context: Optional[str] = None) -> dict:
        """根据搜索类型改写查询"""
        
        if search_type == SearchNeedType.NOT_NEEDED:
            return {
                "original_query": query,
                "rewritten_query": query,
                "search_type": search_type.value,
                "rewrite_strategy": "无需改写",
                "keywords": []
            }

        strategy = self.REWRITE_STRATEGIES.get(search_type, "通用优化")
        current_time = datetime.now().strftime("%Y年%m月%d日")

        system_prompt = f"""你是一个专业的搜索查询优化专家...
当前查询类型: {search_type.value}
改写策略: {strategy}"""

        user_prompt = f"""请改写以下查询以优化搜索效果：
原始查询: {query}
当前日期: {current_time}
请以JSON格式返回结果..."""

        result_text = self._call_llm(system_prompt, user_prompt)
        return self._parse_rewrite_result(result_text, query, search_type, strategy)
```

#### 时间信息注入

```python
from datetime import datetime

def _build_user_prompt(self, query: str, context: Optional[str]) -> str:
    """构建用户提示词，注入时间信息"""
    current_time = datetime.now().strftime("%Y年%m月%d日")
    
    return f"""请改写以下查询以优化搜索效果：

原始查询: {query}
当前日期: {current_time}
上下文信息: {context if context else "无"}
..."""
```

#### 改写示例

| 原查询 | 搜索类型 | 改写后查询 | 关键词 |
|--------|----------|------------|--------|
| 今天北京的天气怎么样？ | 天气 | 北京天气 2026年2月15日 | 北京, 天气, 今天 |
| 最新iPhone价格 | 时效性 | iPhone 最新价格 2026年2月 | iPhone, 价格, 最新 |
| 最近有什么AI新闻 | 新闻资讯 | AI 最新新闻 2026年2月 | AI, 新闻, 最新 |
| 特斯拉今天的股价 | 价格行情 | 特斯拉 股价 实时 2026年2月15日 | 特斯拉, 股价 |

## 搜索策略生成器详解

### search_strategy.py

搜索策略生成器根据查询类型和改写结果，生成详细的搜索策略。

#### SearchStrategy数据类

```python
@dataclass
class SearchStrategy:
    """搜索策略数据类"""
    query: str                # 改写后的查询
    search_type: str          # 搜索类型
    platforms: list[str]      # 推荐平台列表
    keywords: list[str]       # 搜索关键词
    search_operators: list[str]  # 搜索操作符
    priority: int             # 优先级 (1-5)
    notes: str                # 备注
```

#### 平台特性配置

```python
PLATFORM_FEATURES = {
    "Google": {
        "适合类型": ["时效性", "新闻资讯", "价格行情", "实时数据"],
        "优势": "全球最大搜索引擎，覆盖面广",
        "搜索技巧": ["使用site:限定网站", "使用引号精确匹配"]
    },
    "百度": {
        "适合类型": ["时效性", "新闻资讯", "天气"],
        "优势": "中文搜索优化，本地化程度高",
        "搜索技巧": ["使用site:限定网站", "使用intitle:标题搜索"]
    },
    # ... 更多平台
}
```

#### 搜索URL生成

```python
url_templates = {
    "Google": "https://www.google.com/search?q={query}",
    "百度": "https://www.baidu.com/s?wd={query}",
    "必应": "https://www.bing.com/search?q={query}",
    "知乎": "https://www.zhihu.com/search?q={query}",
    "微博": "https://s.weibo.com/weibo/{query}",
    "GitHub": "https://github.com/search?q={query}",
    "Stack Overflow": "https://stackoverflow.com/search?q={query}",
    "雪球": "https://xueqiu.com/k?q={query}",
    "东方财富": "https://so.eastmoney.com/news/s?keyword={query}",
    "中国天气网": "http://www.weather.com.cn/weather/{query}.shtml",
}

def generate_search_url(self, query: str, platform: str, 
                       operator: Optional[str] = None) -> str:
    """生成搜索URL"""
    search_query = f"{operator} {query}" if operator else query
    template = url_templates.get(platform)
    if template:
        return template.format(query=search_query)
    return ""
```

#### 默认策略

```python
def _get_default_strategy(self, query: str, search_type: SearchNeedType,
                         keywords: Optional[list[str]] = None) -> SearchStrategy:
    """获取默认搜索策略"""
    default_platforms = {
        SearchNeedType.TIME_SENSITIVE: ["Google", "百度", "必应"],
        SearchNeedType.WEATHER: ["中国天气网", "墨迹天气", "百度"],
        SearchNeedType.NEWS: ["微博", "知乎", "微信公众号"],
        SearchNeedType.PRICE: ["东方财富", "雪球", "百度"],
        SearchNeedType.REALTIME_DATA: ["微博", "百度", "Google"],
        SearchNeedType.NOT_NEEDED: []
    }

    return SearchStrategy(
        query=query,
        search_type=search_type.value,
        platforms=default_platforms.get(search_type, ["Google", "百度"]),
        keywords=keywords or [],
        search_operators=[f'"{query}"'],
        priority=3,
        notes="使用默认搜索策略"
    )
```

## 整合管道详解

### pipeline.py

整合管道串联分类、改写、策略生成流程，提供统一的处理接口。

#### PipelineResult数据类

```python
@dataclass
class PipelineResult:
    """处理管道结果数据类"""
    original_query: str           # 原始查询
    need_web_search: bool         # 是否需要联网
    search_type: str              # 搜索类型
    classification_reason: str    # 分类理由
    rewritten_query: str = ""     # 改写后查询
    keywords: list[str] = field(default_factory=list)
    platforms: list[str] = field(default_factory=list)
    search_operators: list[str] = field(default_factory=list)
    priority: int = 0
    notes: str = ""
    search_urls: dict[str, str] = field(default_factory=dict)

    def to_dict(self) -> dict:
        """转换为字典"""
        return {
            "original_query": self.original_query,
            "need_web_search": self.need_web_search,
            "search_type": self.search_type,
            # ... 其他字段
        }

    def format_summary(self) -> str:
        """格式化输出摘要"""
        lines = []
        lines.append("=" * 60)
        lines.append(f"原始查询: {self.original_query}")
        lines.append("-" * 60)
        
        if self.need_web_search:
            lines.append(f"需要联网搜索: 是")
            lines.append(f"搜索类型: {self.search_type}")
            # ... 更多输出
        else:
            lines.append(f"需要联网搜索: 否")
        
        return "\n".join(lines)
```

#### WebSearchPipeline类核心实现

```python
class WebSearchPipeline:
    """联网搜索处理管道"""

    def __init__(self, model: Optional[str] = None):
        self.model = model or config.llm_model
        
        # 初始化各组件
        self.classifier = QueryClassifier(model=self.model)
        self.rewriter = WebQueryRewriter(model=self.model)
        self.strategy_generator = SearchStrategyGenerator(model=self.model)

    def process(self, query: str, generate_urls: bool = True) -> PipelineResult:
        """执行完整的处理流程"""
        
        # Step 1: 分类
        classification = self.classifier.classify(query)
        
        result = PipelineResult(
            original_query=query,
            need_web_search=classification["need_web_search"],
            search_type=classification["search_type"],
            classification_reason=classification["reason"]
        )
        
        # 如果不需要联网搜索，直接返回
        if not classification["need_web_search"]:
            return result
        
        # Step 2: 改写
        search_type = self.classifier.quick_classify(query)
        rewrite_result = self.rewriter.rewrite(query, search_type)
        
        result.rewritten_query = rewrite_result["rewritten_query"]
        result.keywords = rewrite_result["keywords"]
        
        # Step 3: 生成搜索策略
        strategy = self.strategy_generator.generate(
            query=result.rewritten_query,
            search_type=search_type,
            keywords=result.keywords
        )
        
        result.platforms = strategy.platforms
        result.search_operators = strategy.search_operators
        result.priority = strategy.priority
        result.notes = strategy.notes
        
        # Step 4: 生成搜索URL
        if generate_urls and result.platforms:
            for platform in result.platforms[:3]:
                search_query = result.keywords[0] if result.keywords else result.rewritten_query
                url = self.strategy_generator.generate_search_url(
                    query=search_query,
                    platform=platform
                )
                if url:
                    result.search_urls[platform] = url
        
        return result
```

#### 快速处理方法

```python
def quick_process(self, query: str) -> dict:
    """快速处理，只返回关键信息"""
    result = self.process(query, generate_urls=False)
    
    return {
        "need_web_search": result.need_web_search,
        "search_type": result.search_type,
        "rewritten_query": result.rewritten_query,
        "keywords": result.keywords[:3] if result.keywords else [],
        "platforms": result.platforms[:3] if result.platforms else []
    }
```

## 主程序入口

### main.py

主程序提供演示功能和交互模式。

#### 演示函数

```python
def demo_basic():
    """基础功能演示"""
    pipeline = WebSearchPipeline()
    
    test_queries = [
        ("今天北京的天气怎么样？", "天气查询"),
        ("最新的iPhone 16 Pro价格是多少？", "时效性查询"),
        ("什么是RAG技术？", "通用知识查询"),
        # ...
    ]
    
    for query, desc in test_queries:
        result = pipeline.quick_process(query)
        # 输出结果...

def demo_full_pipeline():
    """完整流程演示"""
    pipeline = WebSearchPipeline()
    result = pipeline.process("今天上海的天气怎么样，适合户外活动吗？")
    print(result.format_summary())

def demo_batch_processing():
    """批量处理演示"""
    pipeline = WebSearchPipeline()
    queries = ["今天天气", "最新新闻", "股价行情", ...]
    results = pipeline.process_batch(queries)
    # 输出结果...
```

#### 交互模式

```python
def interactive_mode():
    """交互模式"""
    pipeline = WebSearchPipeline()
    
    while True:
        query = input("请输入查询: ").strip()
        
        if query.lower() in ['quit', 'exit', 'q']:
            break
        
        result = pipeline.process(query)
        print(result.format_summary())
```

## 错误处理和调试

### 1. API调用错误处理

```python
def _call_llm(self, system_prompt: str, user_prompt: str) -> str:
    try:
        response = self.client.chat.completions.create(...)
        return response.choices[0].message.content or ""
    except Exception as e:
        logger.error(f"LLM调用失败: {e}")
        return ""
```

### 2. JSON解析错误处理

```python
def _parse_result(self, result_text: str) -> dict:
    try:
        json_str = self._extract_json(result_text)
        return json.loads(json_str)
    except json.JSONDecodeError as e:
        logger.error(f"JSON解析失败: {e}")
        return self._get_default_result()
```

### 3. 日志记录

```python
from loguru import logger

# 配置日志
logger.add("logs/app.log", rotation="1 day")

# 使用日志
logger.info(f"处理查询: {query}")
logger.error(f"处理失败: {e}")
```

---

*最后更新: 2026年2月15日*
*文档版本: v1.0*
*维护团队: build-your-own-ai项目团队*
