# 资金流入流出预测项目 - 使用指南

## 环境准备

### 1. 系统要求
- **操作系统**: Windows 10+, macOS 10.15+, Ubuntu 18.04+
- **Python版本**: 3.11+
- **内存**: 最小8GB，推荐16GB+
- **存储空间**: 最小2GB，推荐5GB+

### 2. 依赖安装

#### 方式一：使用uv（推荐）
```bash
# 克隆项目
git clone <repository-url>
cd practice/11-CASE-资金流入流出预测-P1

# 创建虚拟环境
uv venv --python 3.11

# 激活虚拟环境
source .venv/bin/activate  # Linux/Mac
# 或
.venv\Scripts\activate     # Windows

# 安装依赖
uv sync

# 运行预测
uv run python code/prophet_v6_prediction.py
```

#### 方式二：使用pip
```bash
# 创建虚拟环境
python -m venv .venv

# 激活虚拟环境
source .venv/bin/activate  # Linux/Mac
# 或
.venv\Scripts\activate     # Windows

# 安装依赖
pip install pandas numpy prophet matplotlib seaborn statsmodels

# 运行预测
python code/prophet_v6_prediction.py
```

### 3. 数据准备

确保以下数据文件存在于 `data/` 目录：
- `user_balance_table.csv` - 用户余额数据（必需）
- `user_profile_table.csv` - 用户画像数据（可选）
- `mfd_bank_shibor.csv` - 银行间拆借利率（可选）
- `mfd_day_share_interest.csv` - 股票利率数据（可选）

## 快速开始

### 1. 完整运行流程

```bash
# 1. 激活虚拟环境
source .venv/bin/activate

# 2. 运行数据预处理（首次运行）
python feature/data_analysis.py

# 3. 运行时间序列分析（可选）
python feature/time_series_analysis.py

# 4. 运行Prophet预测模型
python code/prophet_v6_prediction.py
```

### 2. 预期输出

```
=== 最终版Prophet资金流入流出预测分析 ===
🎯 最终策略：回归v1/v2成功配置，解决过拟合和欠拟合问题
💡 核心理念：基于成功经验的平衡优化

=== 加载数据并准备Prophet格式（参考v1/v2成功模式） ===
数据概况:
- 数据时间范围: 2013-07-01 至 2014-08-31
- 总天数: 427 天
- 申购数据平均: ¥XXX,XXX
- 赎回数据平均: ¥XXX,XXX

=== 创建中国节假日（v1/v2成功模式） ===
v1/v2成功模式节假日建模完成: XX 天

=== 训练申购最终版Prophet模型（v1/v2成功配置） ===
最终版模型已保存到: model/purchase_prophet_v6_model.pkl

=== 训练赎回最终版Prophet模型（v1/v2成功配置） ===
最终版模型已保存到: model/redeem_prophet_v6_model.pkl

=== 生成最终版预测结果 ===
最终版预测结果已保存到: prediction_result/prophet_v6_predictions_201409.csv

📊 最终版预测结果统计:
- 总申购预测: ¥XXX,XXX,XXX
- 总赎回预测: ¥XXX,XXX,XXX
- 净流入预测: ¥XXX,XXX,XXX
- 平均日申购: ¥XXX,XXX
- 平均日赎回: ¥XXX,XXX

=== 最终版预测完成 ===
✅ 回归v1/v2成功配置的最终版模型训练成功
📊 预测结果已保存
🏆 预期解决所有问题，分数回归90+分
```

## 数据预处理

### 1. 数据加载和汇总

```python
from feature.data_analysis import analyze_daily_flow

# 分析每日申购赎回金额
daily_summary = analyze_daily_flow()
```

**输出文件：**
- `user_data/daily_summary.csv` - 每日汇总数据
- `user_data/chart_data.json` - 图表数据

### 2. 时间序列分析

```python
from feature.time_series_analysis import perform_stationarity_analysis

# 执行平稳性分析
results = perform_stationarity_analysis()
```

**分析内容：**
- ADF平稳性检验
- 差分分析
- 描述性统计
- 可视化图表

**输出文件：**
- `user_data/stationarity_descriptive_stats.csv` - 描述性统计
- `user_data/filtered_data_*.csv` - 筛选后数据
- `user_data/redeem_diff_*.csv` - 差分数据

### 3. 数据可视化

```python
from feature.visualization import generate_chart_report

# 生成可视化报告
generate_chart_report()
```

**输出内容：**
- ASCII趋势图表
- 关键指标汇总
- 月度统计数据
- 重要发现总结

## 模型训练

### 1. Prophet模型基础训练

```python
from prophet import Prophet
import pandas as pd

# 准备数据
df = pd.read_csv('user_data/daily_summary.csv', header=None, 
                 names=['date', 'purchase', 'redeem'])
df['ds'] = pd.to_datetime(df['date'], format='%Y%m%d')

# 创建申购模型
purchase_df = df[['ds', 'purchase']].copy()
purchase_df.rename(columns={'purchase': 'y'}, inplace=True)

model = Prophet(
    yearly_seasonality=True,
    weekly_seasonality=True,
    daily_seasonality=False,
    seasonality_mode='additive'
)

model.fit(purchase_df)
```

### 2. 带节假日的模型训练

```python
# 创建节假日数据
holidays_df = create_china_holidays()

# 创建带节假日的模型
model = Prophet(
    yearly_seasonality=True,
    weekly_seasonality=True,
    daily_seasonality=False,
    seasonality_mode='additive',
    holidays=holidays_df,
    changepoint_prior_scale=0.05,
    seasonality_prior_scale=10.0,
    holidays_prior_scale=10.0
)

model.fit(purchase_df)
```

### 3. 模型参数调优

```python
# 参数调优建议
configs = [
    # 保守配置
    {'changepoint_prior_scale': 0.01, 'seasonality_prior_scale': 5.0},
    # 标准配置
    {'changepoint_prior_scale': 0.05, 'seasonality_prior_scale': 10.0},
    # 激进配置
    {'changepoint_prior_scale': 0.1, 'seasonality_prior_scale': 15.0},
]

for config in configs:
    model = Prophet(**config, holidays=holidays_df)
    model.fit(train_data)
    # 评估模型性能
    score = evaluate_model(model, test_data)
    print(f"Config: {config}, Score: {score}")
```

## 预测生成

### 1. 基础预测

```python
# 创建未来日期
future = model.make_future_dataframe(periods=30)

# 生成预测
forecast = model.predict(future)

# 查看预测结果
print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(30))
```

### 2. 结果导出

```python
# 导出竞赛格式结果
future_predictions = forecast.tail(30)

exam_format = pd.DataFrame({
    'date': future_predictions['ds'].dt.strftime('%Y%m%d'),
    'purchase': future_predictions['yhat'].round(0).astype(int)
})

exam_format.to_csv('prediction_result/predictions.csv', 
                   header=False, index=False)
```

### 3. 完整预测流程

```python
# 完整的预测流程示例
def run_complete_prediction():
    # 1. 加载数据
    df = load_and_prepare_data()
    
    # 2. 创建Prophet格式数据
    purchase_df = df[['ds', 'purchase']].copy()
    purchase_df.rename(columns={'purchase': 'y'}, inplace=True)
    
    redeem_df = df[['ds', 'redeem']].copy()
    redeem_df.rename(columns={'redeem': 'y'}, inplace=True)
    
    # 3. 创建节假日
    holidays_df = create_china_holidays()
    
    # 4. 训练模型
    purchase_model = Prophet(holidays=holidays_df)
    purchase_model.fit(purchase_df)
    
    redeem_model = Prophet(holidays=holidays_df)
    redeem_model.fit(redeem_df)
    
    # 5. 生成预测
    purchase_future = purchase_model.make_future_dataframe(periods=30)
    purchase_forecast = purchase_model.predict(purchase_future)
    
    redeem_future = redeem_model.make_future_dataframe(periods=30)
    redeem_forecast = redeem_model.predict(redeem_future)
    
    # 6. 保存结果
    save_predictions(purchase_forecast, redeem_forecast)
```

## 常见问题解决

### 1. 内存不足问题

#### 问题现象
```
MemoryError: Unable to allocate array
```

#### 解决方案
```python
# 分块处理数据
def process_in_chunks(file_path: str, chunk_size: int = 10000):
    results = []
    for chunk in pd.read_csv(file_path, chunksize=chunk_size):
        processed = process_chunk(chunk)
        results.append(processed)
    return pd.concat(results)

# 释放不需要的变量
import gc
del large_dataframe
gc.collect()
```

### 2. Prophet安装问题

#### 问题现象
```
ERROR: Cannot install prophet
```

#### 解决方案
```bash
# 安装编译依赖
# macOS
brew install cmake

# Ubuntu
sudo apt-get install build-essential cmake

# 使用conda安装
conda install -c conda-forge prophet

# 或使用pip安装
pip install prophet
```

### 3. 数据格式问题

#### 问题现象
```
ValueError: could not convert string to float
```

#### 解决方案
```python
# 检查数据格式
print(df.dtypes)

# 转换数据类型
df['purchase'] = pd.to_numeric(df['purchase'], errors='coerce')
df['redeem'] = pd.to_numeric(df['redeem'], errors='coerce')

# 处理缺失值
df = df.dropna()
```

### 4. 预测结果异常

#### 问题现象
- 预测值为负数
- 预测值过大或过小

#### 解决方案
```python
# 设置预测值下限
forecast['yhat'] = forecast['yhat'].clip(lower=0)

# 使用对数变换
df['y_log'] = np.log1p(df['y'])
model.fit(df[['ds', 'y_log']])
forecast['yhat'] = np.expm1(forecast['yhat'])

# 检查异常值
def remove_outliers(df, column, n_std=3):
    mean = df[column].mean()
    std = df[column].std()
    return df[(df[column] >= mean - n_std * std) & 
              (df[column] <= mean + n_std * std)]
```

## 性能调优

### 1. 数据处理优化

```python
# 使用更高效的数据类型
df['purchase'] = df['purchase'].astype('float32')
df['redeem'] = df['redeem'].astype('float32')

# 使用迭代器避免内存溢出
def process_large_file(file_path):
    with open(file_path, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            yield process_row(row)
```

### 2. 模型训练优化

```python
# 减少季节性傅里叶阶数
model = Prophet(
    yearly_seasonality=5,    # 默认10
    weekly_seasonality=3     # 默认3
)

# 禁用不需要的组件
model = Prophet(
    daily_seasonality=False,
    yearly_seasonality=True,
    weekly_seasonality=True
)
```

### 3. 预测加速

```python
# 批量预测
def batch_predict(model, periods_list):
    results = []
    for periods in periods_list:
        future = model.make_future_dataframe(periods=periods)
        forecast = model.predict(future)
        results.append(forecast)
    return results
```

## 监控和调试

### 1. 性能监控

```python
import time
import logging

# 设置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def timed_operation(func):
    """性能监控装饰器"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        duration = time.time() - start
        logger.info(f"{func.__name__} took {duration:.2f}s")
        return result
    return wrapper

@timed_operation
def train_model(data):
    model = Prophet()
    model.fit(data)
    return model
```

### 2. 错误处理

```python
def safe_prediction(model, future_df):
    """安全的预测函数"""
    try:
        forecast = model.predict(future_df)
        
        # 验证预测结果
        if forecast['yhat'].isnull().any():
            raise ValueError("预测结果包含空值")
        
        if (forecast['yhat'] < 0).any():
            logger.warning("预测结果包含负值，已自动修正")
            forecast['yhat'] = forecast['yhat'].clip(lower=0)
        
        return forecast
        
    except Exception as e:
        logger.error(f"预测失败: {e}")
        return None
```

---

*最后更新: 2026年2月15日*
*使用指南版本: v1.0*
*技术支持: build-your-own-ai项目团队*
