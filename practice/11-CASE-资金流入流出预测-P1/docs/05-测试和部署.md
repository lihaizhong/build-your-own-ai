# 资金流入流出预测项目 - 测试和部署

## 模型评估

### 1. 评估指标

#### MAE (Mean Absolute Error)
```python
from sklearn.metrics import mean_absolute_error

def calculate_mae(y_true, y_pred):
    """
    计算平均绝对误差
    
    MAE = (1/n) * Σ|y_true - y_pred|
    """
    mae = mean_absolute_error(y_true, y_pred)
    return mae

# 使用示例
mae_score = calculate_mae(actual_values, predicted_values)
print(f"MAE: {mae_score:.4f}")
```

#### RMSE (Root Mean Square Error)
```python
from sklearn.metrics import mean_squared_error
import numpy as np

def calculate_rmse(y_true, y_pred):
    """
    计算均方根误差
    
    RMSE = √((1/n) * Σ(y_true - y_pred)²)
    """
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    return rmse
```

#### MAPE (Mean Absolute Percentage Error)
```python
def calculate_mape(y_true, y_pred):
    """
    计算平均绝对百分比误差
    
    MAPE = (100%/n) * Σ|y_true - y_pred| / |y_true|
    """
    mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
    return mape
```

### 2. 模型性能分析

```python
def analyze_final_performance(forecast_purchase, forecast_redeem, 
                               purchase_df, redeem_df):
    """分析模型性能"""
    print("\n=== 模型性能分析 ===")
    
    # 分离训练期和预测期
    train_size = len(purchase_df)
    test_purchase = forecast_purchase.iloc[:train_size]
    test_redeem = forecast_redeem.iloc[:train_size]
    
    # 计算申购模型误差指标
    purchase_mae = mean_absolute_error(purchase_df['y'], test_purchase['yhat'])
    purchase_rmse = np.sqrt(mean_squared_error(purchase_df['y'], test_purchase['yhat']))
    purchase_mape = np.mean(np.abs((purchase_df['y'] - test_purchase['yhat']) / purchase_df['y'])) * 100
    
    # 计算赎回模型误差指标
    redeem_mae = mean_absolute_error(redeem_df['y'], test_redeem['yhat'])
    redeem_rmse = np.sqrt(mean_squared_error(redeem_df['y'], test_redeem['yhat']))
    redeem_mape = np.mean(np.abs((redeem_df['y'] - test_redeem['yhat']) / redeem_df['y'])) * 100
    
    print(f"申购模型性能:")
    print(f"  MAE: ¥{purchase_mae:,.0f}")
    print(f"  RMSE: ¥{purchase_rmse:,.0f}")
    print(f"  MAPE: {purchase_mape:.2f}%")
    
    print(f"\n赎回模型性能:")
    print(f"  MAE: ¥{redeem_mae:,.0f}")
    print(f"  RMSE: ¥{redeem_rmse:,.0f}")
    print(f"  MAPE: {redeem_mape:.2f}%")
    
    return {
        'purchase_mae': purchase_mae,
        'purchase_rmse': purchase_rmse,
        'purchase_mape': purchase_mape,
        'redeem_mae': redeem_mae,
        'redeem_rmse': redeem_rmse,
        'redeem_mape': redeem_mape
    }
```

### 3. 交叉验证

```python
from prophet.diagnostics import cross_validation, performance_metrics

def cross_validate_prophet(model, initial='365 days', period='30 days', horizon='30 days'):
    """Prophet模型交叉验证"""
    # 执行交叉验证
    df_cv = cross_validation(model, initial=initial, period=period, horizon=horizon)
    
    # 计算性能指标
    df_p = performance_metrics(df_cv)
    
    print("交叉验证结果:")
    print(df_p.head())
    
    return df_cv, df_p
```

## 单元测试

### 1. 数据加载测试

```python
import unittest
import pandas as pd

class TestDataLoader(unittest.TestCase):
    """数据加载测试"""
    
    def test_load_data(self):
        """测试数据加载"""
        df = load_and_prepare_data()
        
        # 验证数据不为空
        self.assertIsNotNone(df)
        self.assertGreater(len(df), 0)
        
        # 验证必需列存在
        self.assertIn('ds', df.columns)
        self.assertIn('purchase', df.columns)
        self.assertIn('redeem', df.columns)
    
    def test_date_format(self):
        """测试日期格式"""
        df = load_and_prepare_data()
        
        # 验证日期类型
        self.assertTrue(pd.api.types.is_datetime64_any_dtype(df['ds']))
        
        # 验证日期范围
        self.assertGreater(df['ds'].min(), pd.Timestamp('2013-01-01'))
        self.assertLess(df['ds'].max(), pd.Timestamp('2015-01-01'))
    
    def test_data_values(self):
        """测试数据值"""
        df = load_and_prepare_data()
        
        # 验证申购和赎回值为正数
        self.assertTrue((df['purchase'] >= 0).all())
        self.assertTrue((df['redeem'] >= 0).all())
```

### 2. 模型测试

```python
class TestProphetModel(unittest.TestCase):
    """Prophet模型测试"""
    
    def setUp(self):
        """测试前准备"""
        self.df = load_and_prepare_data()
        self.holidays_df = create_china_holidays_v6()
    
    def test_model_creation(self):
        """测试模型创建"""
        model = Prophet(holidays=self.holidays_df)
        self.assertIsNotNone(model)
    
    def test_model_fit(self):
        """测试模型拟合"""
        model = Prophet(holidays=self.holidays_df)
        
        prophet_df = self.df[['ds', 'purchase']].copy()
        prophet_df.rename(columns={'purchase': 'y'}, inplace=True)
        
        model.fit(prophet_df)
        
        self.assertIsNotNone(model.history)
    
    def test_prediction(self):
        """测试预测功能"""
        model = Prophet(holidays=self.holidays_df)
        
        prophet_df = self.df[['ds', 'purchase']].copy()
        prophet_df.rename(columns={'purchase': 'y'}, inplace=True)
        
        model.fit(prophet_df)
        
        future = model.make_future_dataframe(periods=30)
        forecast = model.predict(future)
        
        # 验证预测结果
        self.assertEqual(len(forecast), len(prophet_df) + 30)
        self.assertIn('yhat', forecast.columns)
    
    def test_holiday_effects(self):
        """测试节假日效应"""
        holidays_df = create_china_holidays_v6()
        
        # 验证节假日数据
        self.assertGreater(len(holidays_df), 0)
        self.assertIn('holiday', holidays_df.columns)
        self.assertIn('ds', holidays_df.columns)
```

### 3. 特征工程测试

```python
class TestFeatureEngineering(unittest.TestCase):
    """特征工程测试"""
    
    def test_holiday_creation(self):
        """测试节假日创建"""
        holidays_df = create_china_holidays_v6()
        
        # 验证节假日数量
        self.assertGreater(len(holidays_df), 50)
        
        # 验证节假日类型
        holiday_types = holidays_df['holiday'].unique()
        expected_types = ['元旦', '春节', '清明节', '劳动节', '端午节', '中秋节', '国庆节']
        
        for h_type in expected_types:
            self.assertIn(h_type, holiday_types)
    
    def test_time_features(self):
        """测试时间特征"""
        df = load_and_prepare_data()
        
        # 验证日期特征
        df['weekday'] = df['ds'].dt.dayofweek
        df['is_weekend'] = df['weekday'].isin([5, 6])
        
        # 验证特征值范围
        self.assertTrue((df['weekday'] >= 0).all() and (df['weekday'] <= 6).all())
        self.assertTrue(df['is_weekend'].isin([True, False]).all())
```

## 性能测试

### 1. 训练性能测试

```python
import time

def test_training_performance():
    """测试训练性能"""
    df = load_and_prepare_data()
    
    prophet_df = df[['ds', 'purchase']].copy()
    prophet_df.rename(columns={'purchase': 'y'}, inplace=True)
    
    # 记录训练时间
    start_time = time.time()
    
    model = Prophet(holidays=create_china_holidays_v6())
    model.fit(prophet_df)
    
    end_time = time.time()
    training_time = end_time - start_time
    
    print(f"训练时间: {training_time:.2f}秒")
    
    # 验证训练时间合理
    assert training_time < 60, "训练时间过长"
```

### 2. 预测性能测试

```python
def test_prediction_performance():
    """测试预测性能"""
    df = load_and_prepare_data()
    
    prophet_df = df[['ds', 'purchase']].copy()
    prophet_df.rename(columns={'purchase': 'y'}, inplace=True)
    
    model = Prophet(holidays=create_china_holidays_v6())
    model.fit(prophet_df)
    
    # 记录预测时间
    start_time = time.time()
    
    future = model.make_future_dataframe(periods=30)
    forecast = model.predict(future)
    
    end_time = time.time()
    prediction_time = end_time - start_time
    
    print(f"预测时间: {prediction_time:.2f}秒")
    
    # 验证预测时间合理
    assert prediction_time < 10, "预测时间过长"
```

## 部署策略

### 1. 开发环境部署

#### 本地运行
```bash
# 1. 克隆项目
git clone <repository-url>
cd practice/11-CASE-资金流入流出预测-P1

# 2. 创建虚拟环境
uv venv --python 3.11
source .venv/bin/activate

# 3. 安装依赖
uv sync

# 4. 运行预测
python code/prophet_v6_prediction.py
```

#### Jupyter Notebook
```bash
# 启动Jupyter
jupyter notebook

# 打开 资金流入流出预测.ipynb
# 按顺序执行单元格
```

### 2. 生产环境部署

#### Docker容器化

```dockerfile
# Dockerfile
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    make \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建必要的目录
RUN mkdir -p /app/data /app/model /app/prediction_result

# 设置环境变量
ENV PYTHONPATH=/app

# 运行命令
CMD ["python", "code/prophet_v6_prediction.py"]
```

#### Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  fund-prediction:
    build: .
    container_name: fund-prediction
    volumes:
      - ./data:/app/data
      - ./model:/app/model
      - ./prediction_result:/app/prediction_result
    environment:
      - PYTHONUNBUFFERED=1
    restart: unless-stopped
```

### 3. 定时任务部署

#### Cron定时任务
```bash
# 编辑crontab
crontab -e

# 添加每日预测任务（每天凌晨2点执行）
0 2 * * * cd /path/to/project && /path/to/.venv/bin/python code/prophet_v6_prediction.py >> logs/prediction.log 2>&1
```

#### Systemd服务
```ini
# /etc/systemd/system/fund-prediction.service
[Unit]
Description=Fund Flow Prediction Service
After=network.target

[Service]
Type=oneshot
User=www-data
WorkingDirectory=/path/to/project
ExecStart=/path/to/.venv/bin/python code/prophet_v6_prediction.py

[Install]
WantedBy=multi-user.target
```

## 结果导出

### 1. 竞赛格式导出

```python
def export_competition_format(predictions, output_path):
    """导出竞赛格式预测结果"""
    # 竞赛要求格式：无表头，YYYYMMDD,purchase,redeem
    exam_format = pd.DataFrame({
        'date': predictions['date'].dt.strftime('%Y%m%d'),
        'purchase': predictions['purchase_forecast'].round(0).astype(int),
        'redeem': predictions['redeem_forecast'].round(0).astype(int)
    })
    
    exam_format.to_csv(output_path, header=False, index=False)
    print(f"竞赛格式结果已导出到: {output_path}")
```

### 2. 详细结果导出

```python
def export_detailed_results(predictions, performance, output_dir):
    """导出详细预测结果"""
    import os
    
    # 导出预测详情
    detailed_file = os.path.join(output_dir, 'detailed_predictions.csv')
    predictions.to_csv(detailed_file, index=False)
    
    # 导出性能指标
    performance_file = os.path.join(output_dir, 'performance_metrics.csv')
    pd.DataFrame([performance]).to_csv(performance_file, index=False)
    
    print(f"详细结果已导出到: {output_dir}")
```

### 3. 可视化报告导出

```python
def export_visualization_report(predictions, output_path):
    """导出可视化报告"""
    import matplotlib.pyplot as plt
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # 申购预测趋势
    axes[0, 0].plot(predictions['date'], predictions['purchase_forecast'])
    axes[0, 0].fill_between(predictions['date'], 
                            predictions['purchase_lower'], 
                            predictions['purchase_upper'], 
                            alpha=0.3)
    axes[0, 0].set_title('申购预测趋势')
    
    # 赎回预测趋势
    axes[0, 1].plot(predictions['date'], predictions['redeem_forecast'])
    axes[0, 1].fill_between(predictions['date'], 
                            predictions['redeem_lower'], 
                            predictions['redeem_upper'], 
                            alpha=0.3)
    axes[0, 1].set_title('赎回预测趋势')
    
    # 净流入趋势
    axes[1, 0].bar(predictions['date'], predictions['net_flow'])
    axes[1, 0].set_title('净流入趋势')
    axes[1, 0].axhline(y=0, color='r', linestyle='--')
    
    # 周度模式
    weekly_avg = predictions.groupby('weekday')['net_flow'].mean()
    axes[1, 1].bar(range(7), weekly_avg)
    axes[1, 1].set_title('周度平均净流入')
    axes[1, 1].set_xticks(range(7))
    axes[1, 1].set_xticklabels(['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'])
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close()
    
    print(f"可视化报告已导出到: {output_path}")
```

## 持续优化

### 1. 模型版本管理

```python
def save_model_version(model, version, metrics, output_dir):
    """保存模型版本"""
    import json
    
    # 保存模型
    model_path = os.path.join(output_dir, f'model_v{version}.pkl')
    with open(model_path, 'wb') as f:
        pickle.dump(model, f)
    
    # 保存元数据
    metadata = {
        'version': version,
        'created_at': datetime.now().isoformat(),
        'metrics': metrics,
        'config': {
            'changepoint_prior_scale': model.changepoint_prior_scale,
            'seasonality_prior_scale': model.seasonality_prior_scale,
            'holidays_prior_scale': model.holidays_prior_scale
        }
    }
    
    metadata_path = os.path.join(output_dir, f'metadata_v{version}.json')
    with open(metadata_path, 'w') as f:
        json.dump(metadata, f, indent=2)
    
    print(f"模型版本 {version} 已保存")
```

### 2. 自动化调参

```python
from sklearn.model_selection import ParameterGrid

def auto_tune_model(train_data, param_grid):
    """自动调参"""
    best_score = float('inf')
    best_params = None
    
    for params in ParameterGrid(param_grid):
        model = Prophet(**params, holidays=create_china_holidays_v6())
        model.fit(train_data)
        
        # 交叉验证评估
        df_cv = cross_validation(model, horizon='30 days')
        df_p = performance_metrics(df_cv)
        
        score = df_p['mae'].mean()
        
        if score < best_score:
            best_score = score
            best_params = params
    
    return best_params, best_score
```

### 3. 性能监控

```python
class PerformanceMonitor:
    """性能监控器"""
    
    def __init__(self):
        self.history = []
    
    def log_prediction(self, prediction_time, mae_score):
        """记录预测性能"""
        self.history.append({
            'timestamp': datetime.now(),
            'prediction_time': prediction_time,
            'mae_score': mae_score
        })
    
    def get_trend(self):
        """获取性能趋势"""
        df = pd.DataFrame(self.history)
        
        return {
            'avg_prediction_time': df['prediction_time'].mean(),
            'avg_mae': df['mae_score'].mean(),
            'mae_trend': df['mae_score'].tolist()
        }
```

---

*最后更新: 2026年2月15日*
*测试和部署版本: v1.0*
*运维团队: DevOps运维组*
