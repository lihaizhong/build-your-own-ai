# Query改写系统 - 测试和部署

## 测试策略

### 1. 单元测试

#### QueryType枚举测试

```python
import unittest
from query_rewriter import QueryType


class TestQueryType(unittest.TestCase):
    """QueryType枚举测试"""
    
    def test_enum_values(self):
        """测试枚举值"""
        self.assertEqual(QueryType.CONTEXT_DEPENDENT.value, "上下文依赖型")
        self.assertEqual(QueryType.COMPARATIVE.value, "对比型")
        self.assertEqual(QueryType.VAGUE_REFERENCE.value, "模糊指代型")
        self.assertEqual(QueryType.MULTI_INTENT.value, "多意图型")
        self.assertEqual(QueryType.RHETORICAL.value, "反问型")
        self.assertEqual(QueryType.NORMAL.value, "普通型")
    
    def test_enum_comparison(self):
        """测试枚举比较"""
        self.assertEqual(
            QueryType.CONTEXT_DEPENDENT, 
            QueryType.CONTEXT_DEPENDENT
        )
        self.assertNotEqual(
            QueryType.CONTEXT_DEPENDENT, 
            QueryType.COMPARATIVE
        )
```

#### QueryRewriter类测试

```python
import unittest
from unittest.mock import Mock, patch, MagicMock
from query_rewriter import QueryRewriter, QueryType


class TestQueryRewriter(unittest.TestCase):
    """QueryRewriter类单元测试"""
    
    def setUp(self):
        """测试前准备"""
        # Mock环境变量
        self.api_key_patcher = patch.dict(
            'os.environ', 
            {'DASHSCOPE_API_KEY': 'test_key'}
        )
        self.api_key_patcher.start()
        self.rewriter = QueryRewriter()
    
    def tearDown(self):
        """测试后清理"""
        self.api_key_patcher.stop()
    
    def test_initialization(self):
        """测试初始化"""
        self.assertEqual(self.rewriter.model, "qwen-turbo-latest")
        self.assertIsNotNone(self.rewriter.api_key)
    
    def test_initialization_with_custom_model(self):
        """测试自定义模型初始化"""
        rewriter = QueryRewriter(model="qwen-max")
        self.assertEqual(rewriter.model, "qwen-max")
    
    @patch('query_rewriter.Generation.call')
    def test_call_llm_success(self, mock_call):
        """测试LLM调用成功"""
        # Mock响应
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.output.text = "  测试响应  "
        mock_call.return_value = mock_response
        
        result = self.rewriter._call_llm("测试提示")
        
        self.assertEqual(result, "测试响应")
        mock_call.assert_called_once()
    
    @patch('query_rewriter.Generation.call')
    def test_call_llm_failure(self, mock_call):
        """测试LLM调用失败"""
        # Mock失败响应
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_response.code = "InvalidParameter"
        mock_response.message = "参数错误"
        mock_call.return_value = mock_response
        
        result = self.rewriter._call_llm("测试提示")
        
        self.assertEqual(result, "")
    
    @patch('query_rewriter.Generation.call')
    def test_call_llm_exception(self, mock_call):
        """测试LLM调用异常"""
        mock_call.side_effect = Exception("网络错误")
        
        result = self.rewriter._call_llm("测试提示")
        
        self.assertEqual(result, "")
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_context_dependent(self, mock_llm):
        """测试识别上下文依赖型"""
        mock_llm.return_value = "上下文依赖型"
        
        result = self.rewriter.identify_query_type("还有其他景点吗？")
        
        self.assertEqual(result, QueryType.CONTEXT_DEPENDENT)
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_comparative(self, mock_llm):
        """测试识别对比型"""
        mock_llm.return_value = "对比型"
        
        result = self.rewriter.identify_query_type("Python和Java哪个更好？")
        
        self.assertEqual(result, QueryType.COMPARATIVE)
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_vague_reference(self, mock_llm):
        """测试识别模糊指代型"""
        mock_llm.return_value = "模糊指代型"
        
        result = self.rewriter.identify_query_type("它有什么特点？")
        
        self.assertEqual(result, QueryType.VAGUE_REFERENCE)
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_multi_intent(self, mock_llm):
        """测试识别多意图型"""
        mock_llm.return_value = "多意图型"
        
        result = self.rewriter.identify_query_type("什么是RAG？如何实现？")
        
        self.assertEqual(result, QueryType.MULTI_INTENT)
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_rhetorical(self, mock_llm):
        """测试识别反问型"""
        mock_llm.return_value = "反问型"
        
        result = self.rewriter.identify_query_type("难道不需要数据吗？")
        
        self.assertEqual(result, QueryType.RHETORICAL)
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_normal(self, mock_llm):
        """测试识别普通型"""
        mock_llm.return_value = "普通型"
        
        result = self.rewriter.identify_query_type("什么是向量数据库？")
        
        self.assertEqual(result, QueryType.NORMAL)
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_identify_query_type_unknown(self, mock_llm):
        """测试未知类型返回普通型"""
        mock_llm.return_value = "未知类型"
        
        result = self.rewriter.identify_query_type("测试查询")
        
        self.assertEqual(result, QueryType.NORMAL)


class TestRewriteMethods(unittest.TestCase):
    """改写方法测试"""
    
    def setUp(self):
        self.api_key_patcher = patch.dict(
            'os.environ', 
            {'DASHSCOPE_API_KEY': 'test_key'}
        )
        self.api_key_patcher.start()
        self.rewriter = QueryRewriter()
    
    def tearDown(self):
        self.api_key_patcher.stop()
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_rewrite_context_dependent(self, mock_llm):
        """测试上下文依赖型改写"""
        mock_llm.return_value = "巴黎除了埃菲尔铁塔还有哪些景点？"
        
        result = self.rewriter.rewrite_context_dependent_query(
            query="还有其他景点吗？",
            conversation_history="用户：巴黎有埃菲尔铁塔。"
        )
        
        self.assertEqual(result, "巴黎除了埃菲尔铁塔还有哪些景点？")
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_rewrite_comparative(self, mock_llm):
        """测试对比型改写"""
        mock_llm.return_value = "Python和Java在性能和语法方面的对比"
        
        result = self.rewriter.rewrite_comparative_query(
            query="Python和Java哪个更好？",
            context_info="两者都是流行语言"
        )
        
        self.assertEqual(result, "Python和Java在性能和语法方面的对比")
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_rewrite_vague_reference(self, mock_llm):
        """测试模糊指代型改写"""
        mock_llm.return_value = "Transformer模型的主要优势是什么？"
        
        result = self.rewriter.rewrite_vague_reference_query(
            query="它的主要优势是什么？",
            conversation_history="用户：我在研究Transformer模型。"
        )
        
        self.assertEqual(result, "Transformer模型的主要优势是什么？")
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_rewrite_multi_intent(self, mock_llm):
        """测试多意图型改写"""
        mock_llm.return_value = "什么是RAG？\n如何搭建RAG？\nRAG有什么优缺点？"
        
        result = self.rewriter.rewrite_multi_intent_query(
            query="什么是RAG？如何搭建？有什么优缺点？"
        )
        
        self.assertEqual(len(result), 3)
        self.assertEqual(result[0], "什么是RAG？")
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_rewrite_multi_intent_empty(self, mock_llm):
        """测试多意图型改写失败"""
        mock_llm.return_value = ""
        
        result = self.rewriter.rewrite_multi_intent_query(
            query="测试查询"
        )
        
        self.assertEqual(result, ["测试查询"])
    
    @patch.object(QueryRewriter, '_call_llm')
    def test_rewrite_rhetorical(self, mock_llm):
        """测试反问型改写"""
        mock_llm.return_value = "深度学习为什么需要大量数据？"
        
        result = self.rewriter.rewrite_rhetorical_query(
            query="难道深度学习不需要大量数据吗？"
        )
        
        self.assertEqual(result, "深度学习为什么需要大量数据？")


class TestAutoRewrite(unittest.TestCase):
    """auto_rewrite_query方法测试"""
    
    def setUp(self):
        self.api_key_patcher = patch.dict(
            'os.environ', 
            {'DASHSCOPE_API_KEY': 'test_key'}
        )
        self.api_key_patcher.start()
        self.rewriter = QueryRewriter()
    
    def tearDown(self):
        self.api_key_patcher.stop()
    
    @patch.object(QueryRewriter, 'identify_query_type')
    def test_auto_rewrite_normal(self, mock_identify):
        """测试普通型自动改写"""
        mock_identify.return_value = QueryType.NORMAL
        
        result = self.rewriter.auto_rewrite_query("什么是向量数据库？")
        
        self.assertEqual(result['query_type'], "普通型")
        self.assertEqual(result['rewritten_query'], "什么是向量数据库？")
        self.assertEqual(result['sub_queries'], [])
    
    @patch.object(QueryRewriter, 'identify_query_type')
    @patch.object(QueryRewriter, 'rewrite_context_dependent_query')
    def test_auto_rewrite_context_dependent(self, mock_rewrite, mock_identify):
        """测试上下文依赖型自动改写"""
        mock_identify.return_value = QueryType.CONTEXT_DEPENDENT
        mock_rewrite.return_value = "改写后的查询"
        
        result = self.rewriter.auto_rewrite_query(
            "还有其他吗？", 
            conversation_history="历史"
        )
        
        self.assertEqual(result['query_type'], "上下文依赖型")
        self.assertEqual(result['rewritten_query'], "改写后的查询")
    
    @patch.object(QueryRewriter, 'identify_query_type')
    @patch.object(QueryRewriter, 'rewrite_multi_intent_query')
    def test_auto_rewrite_multi_intent(self, mock_rewrite, mock_identify):
        """测试多意图型自动改写"""
        mock_identify.return_value = QueryType.MULTI_INTENT
        mock_rewrite.return_value = ["问题1", "问题2"]
        
        result = self.rewriter.auto_rewrite_query("多个问题")
        
        self.assertEqual(result['query_type'], "多意图型")
        self.assertEqual(result['sub_queries'], ["问题1", "问题2"])
        self.assertEqual(result['rewritten_query'], "问题1 | 问题2")


if __name__ == '__main__':
    unittest.main(verbosity=2)
```

### 2. 集成测试

```python
import pytest
import os
from query_rewriter import QueryRewriter, QueryType


@pytest.mark.integration
class TestIntegration:
    """集成测试（需要真实API Key）"""
    
    @pytest.fixture(autouse=True)
    def setup(self):
        """检查API Key"""
        self.api_key = os.environ.get('DASHSCOPE_API_KEY')
        if not self.api_key:
            pytest.skip("DASHSCOPE_API_KEY未设置，跳过集成测试")
        self.rewriter = QueryRewriter()
    
    def test_real_context_dependent_rewrite(self):
        """真实上下文依赖型改写测试"""
        history = "用户：我在学习Python。\n助手：Python是一门流行的编程语言。"
        query = "还有其他语言推荐吗？"
        
        result = self.rewriter.auto_rewrite_query(query, history)
        
        assert result['query_type'] in ['上下文依赖型', '普通型']
        assert len(result['rewritten_query']) > 0
    
    def test_real_multi_intent_rewrite(self):
        """真实多意图型改写测试"""
        query = "什么是向量数据库？如何使用？有什么优缺点？"
        
        result = self.rewriter.auto_rewrite_query(query)
        
        assert result['query_type'] in ['多意图型', '普通型']
        if result['query_type'] == '多意图型':
            assert len(result['sub_queries']) >= 2
    
    def test_real_type_identification(self):
        """真实类型识别测试"""
        test_cases = [
            ("还有其他的吗？", QueryType.CONTEXT_DEPENDENT),
            ("Python和Java哪个好？", QueryType.COMPARATIVE),
            ("它有什么特点？", QueryType.VAGUE_REFERENCE),
            ("什么是RAG？如何实现？", QueryType.MULTI_INTENT),
            ("难道不需要吗？", QueryType.RHETORICAL),
        ]
        
        for query, expected_type in test_cases:
            result = self.rewriter.identify_query_type(query)
            # 由于LLM可能有不一致输出，这里只检查是否为有效类型
            assert isinstance(result, QueryType)
```

### 3. 性能测试

```python
import time
import pytest
from unittest.mock import patch
from query_rewriter import QueryRewriter


class TestPerformance:
    """性能测试"""
    
    @pytest.fixture
    def mock_rewriter(self):
        """创建Mock Rewriter"""
        with patch.dict('os.environ', {'DASHSCOPE_API_KEY': 'test_key'}):
            rewriter = QueryRewriter()
        
        # Mock LLM调用
        def mock_call_llm(prompt):
            time.sleep(0.1)  # 模拟网络延迟
            if "类型" in prompt:
                return "普通型"
            return "改写后的查询"
        
        rewriter._call_llm = mock_call_llm
        return rewriter
    
    def test_single_query_performance(self, mock_rewriter):
        """单次查询性能测试"""
        start_time = time.time()
        
        result = mock_rewriter.auto_rewrite_query("测试查询")
        
        end_time = time.time()
        duration = end_time - start_time
        
        print(f"单次查询耗时: {duration:.3f}秒")
        assert duration < 1.0  # 应在1秒内完成
    
    def test_batch_query_performance(self, mock_rewriter):
        """批量查询性能测试"""
        queries = [f"测试查询{i}" for i in range(10)]
        
        start_time = time.time()
        
        results = []
        for query in queries:
            result = mock_rewriter.auto_rewrite_query(query)
            results.append(result)
        
        end_time = time.time()
        duration = end_time - start_time
        avg_duration = duration / len(queries)
        
        print(f"批量查询({len(queries)}个)总耗时: {duration:.3f}秒")
        print(f"平均每个查询: {avg_duration:.3f}秒")
        
        assert len(results) == len(queries)
    
    def test_type_identification_performance(self, mock_rewriter):
        """类型识别性能测试"""
        queries = [
            "还有其他的吗？",
            "Python和Java哪个好？",
            "它有什么特点？",
            "什么是RAG？如何实现？",
            "难道不需要吗？",
        ]
        
        start_time = time.time()
        
        for query in queries:
            mock_rewriter.identify_query_type(query)
        
        end_time = time.time()
        duration = end_time - start_time
        avg_duration = duration / len(queries)
        
        print(f"类型识别平均耗时: {avg_duration:.3f}秒")
        assert avg_duration < 0.5
```

## 部署方案

### 1. 开发环境部署

#### 直接运行

```bash
# 克隆项目
git clone <repository-url>
cd build-your-own-ai

# 安装依赖
uv sync

# 配置环境变量
cp .env.example .env
# 编辑 .env 添加 DASHSCOPE_API_KEY

# 运行演示
cd practice/16-CASE-Query改写/code
python main.py
```

#### 作为模块使用

```python
# 在其他项目中使用
from practice.16_CASE_Query改写.code.query_rewriter import QueryRewriter

rewriter = QueryRewriter()
result = rewriter.auto_rewrite_query("测试查询")
```

### 2. 生产环境部署

#### 封装为API服务

```python
# api_server.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional, List
from query_rewriter import QueryRewriter

app = FastAPI(title="Query Rewrite API")
rewriter = QueryRewriter()


class RewriteRequest(BaseModel):
    """改写请求模型"""
    query: str
    conversation_history: Optional[str] = ""
    context_info: Optional[str] = ""


class RewriteResponse(BaseModel):
    """改写响应模型"""
    original_query: str
    query_type: str
    rewritten_query: str
    sub_queries: List[str]


@app.post("/rewrite", response_model=RewriteResponse)
async def rewrite_query(request: RewriteRequest):
    """Query改写接口"""
    try:
        result = rewriter.auto_rewrite_query(
            query=request.query,
            conversation_history=request.conversation_history or "",
            context_info=request.context_info or ""
        )
        return RewriteResponse(**result)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "healthy"}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

#### Docker部署

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装依赖
COPY pyproject.toml uv.lock ./
RUN pip install uv && uv sync --frozen

# 复制代码
COPY practice/16-CASE-Query改写/ ./query_rewrite/

# 设置环境变量
ENV PYTHONPATH=/app

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uv", "run", "uvicorn", "query_rewrite.code.api_server:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  query-rewrite-api:
    build:
      context: ../..
      dockerfile: practice/16-CASE-Query改写/Dockerfile
    container_name: query-rewrite-api
    ports:
      - "8000:8000"
    environment:
      - DASHSCOPE_API_KEY=${DASHSCOPE_API_KEY}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### 3. Kubernetes部署

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: query-rewrite-service
  labels:
    app: query-rewrite
spec:
  replicas: 2
  selector:
    matchLabels:
      app: query-rewrite
  template:
    metadata:
      labels:
        app: query-rewrite
    spec:
      containers:
      - name: query-rewrite
        image: query-rewrite:latest
        ports:
        - containerPort: 8000
        env:
        - name: DASHSCOPE_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: dashscope-api-key
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: query-rewrite-service
spec:
  selector:
    app: query-rewrite
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8000
  type: ClusterIP
```

## 性能优化

### 1. 缓存策略

```python
from functools import lru_cache
from typing import Tuple

class CachedQueryRewriter(QueryRewriter):
    """带缓存的Query改写器"""
    
    @lru_cache(maxsize=1000)
    def _cached_identify(self, query: str, history_hash: int) -> str:
        """缓存的类型识别"""
        return super().identify_query_type(query).value
    
    def identify_query_type(
        self, 
        query: str, 
        conversation_history: str = ""
    ) -> 'QueryType':
        """使用缓存的类型识别"""
        history_hash = hash(conversation_history)
        type_str = self._cached_identify(query, history_hash)
        
        type_mapping = {
            "上下文依赖型": QueryType.CONTEXT_DEPENDENT,
            "对比型": QueryType.COMPARATIVE,
            "模糊指代型": QueryType.VAGUE_REFERENCE,
            "多意图型": QueryType.MULTI_INTENT,
            "反问型": QueryType.RHETORICAL,
            "普通型": QueryType.NORMAL,
        }
        return type_mapping.get(type_str, QueryType.NORMAL)
```

### 2. 异步处理

```python
import asyncio
from typing import List, Dict

class AsyncQueryRewriter(QueryRewriter):
    """异步Query改写器"""
    
    async def async_call_llm(self, prompt: str) -> str:
        """异步LLM调用"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None, 
            self._call_llm, 
            prompt
        )
    
    async def async_auto_rewrite(
        self,
        query: str,
        conversation_history: str = "",
        context_info: str = ""
    ) -> Dict:
        """异步自动改写"""
        # 并行执行类型识别
        type_task = asyncio.create_task(
            self._async_identify_type(query, conversation_history)
        )
        
        query_type = await type_task
        # ... 后续处理
    
    async def batch_rewrite(self, queries: List[str]) -> List[Dict]:
        """批量异步改写"""
        tasks = [
            self.async_auto_rewrite(query) 
            for query in queries
        ]
        return await asyncio.gather(*tasks)
```

### 3. 批量处理优化

```python
class BatchQueryRewriter(QueryRewriter):
    """支持批量处理的改写器"""
    
    def batch_identify_types(
        self, 
        queries: List[str]
    ) -> List['QueryType']:
        """批量类型识别"""
        # 构建批量Prompt
        batch_prompt = self._build_batch_prompt(queries)
        
        # 一次性调用LLM
        result = self._call_llm(batch_prompt)
        
        # 解析结果
        types = result.strip().split('\n')
        return [self._map_type(t.strip()) for t in types]
    
    def _build_batch_prompt(self, queries: List[str]) -> str:
        """构建批量识别Prompt"""
        queries_text = "\n".join(
            f"{i+1}. {q}" for i, q in enumerate(queries)
        )
        return f"""请分析以下查询的类型，每行一个类型：

{queries_text}

类型选项：上下文依赖型、对比型、模糊指代型、多意图型、反问型、普通型
请按顺序输出每个查询的类型，每行一个："""
```

## 监控和日志

### 1. 日志配置

```python
import logging
from loguru import logger

# 配置日志
logger.add(
    "logs/query_rewrite.log",
    rotation="10 MB",
    retention="7 days",
    level="INFO",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}"
)

class MonitoredQueryRewriter(QueryRewriter):
    """带监控的Query改写器"""
    
    def auto_rewrite_query(self, query: str, **kwargs) -> dict:
        """带监控的改写"""
        import time
        
        start_time = time.time()
        
        try:
            result = super().auto_rewrite_query(query, **kwargs)
            
            # 记录成功日志
            duration = time.time() - start_time
            logger.info(
                f"Query改写成功 | "
                f"类型: {result['query_type']} | "
                f"耗时: {duration:.3f}s | "
                f"原查询: {query[:50]}"
            )
            
            return result
            
        except Exception as e:
            # 记录错误日志
            logger.error(
                f"Query改写失败 | "
                f"错误: {str(e)} | "
                f"原查询: {query[:50]}"
            )
            raise
```

### 2. 性能指标收集

```python
from dataclasses import dataclass
from typing import Dict, List
import time

@dataclass
class PerformanceMetrics:
    """性能指标"""
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    total_duration: float = 0.0
    type_distribution: Dict[str, int] = None
    
    def __post_init__(self):
        if self.type_distribution is None:
            self.type_distribution = {}

class MetricsCollector:
    """指标收集器"""
    
    def __init__(self):
        self.metrics = PerformanceMetrics()
    
    def record_request(
        self, 
        query_type: str, 
        duration: float, 
        success: bool
    ):
        """记录请求指标"""
        self.metrics.total_requests += 1
        
        if success:
            self.metrics.successful_requests += 1
        else:
            self.metrics.failed_requests += 1
        
        self.metrics.total_duration += duration
        
        if query_type in self.metrics.type_distribution:
            self.metrics.type_distribution[query_type] += 1
        else:
            self.metrics.type_distribution[query_type] = 1
    
    def get_summary(self) -> dict:
        """获取摘要"""
        avg_duration = (
            self.metrics.total_duration / self.metrics.total_requests
            if self.metrics.total_requests > 0 else 0
        )
        
        return {
            "total_requests": self.metrics.total_requests,
            "success_rate": (
                self.metrics.successful_requests / self.metrics.total_requests * 100
                if self.metrics.total_requests > 0 else 0
            ),
            "avg_duration": avg_duration,
            "type_distribution": self.metrics.type_distribution
        }
```

### 3. 健康检查

```python
def health_check(rewriter: QueryRewriter) -> dict:
    """健康检查"""
    checks = {
        "api_key": False,
        "llm_connection": False,
        "basic_function": False
    }
    
    # 检查API Key
    if rewriter.api_key:
        checks["api_key"] = True
    
    # 检查LLM连接
    try:
        result = rewriter._call_llm("测试")
        if result:
            checks["llm_connection"] = True
    except:
        pass
    
    # 检查基本功能
    try:
        result = rewriter.auto_rewrite_query("测试查询")
        if result and "rewritten_query" in result:
            checks["basic_function"] = True
    except:
        pass
    
    all_healthy = all(checks.values())
    
    return {
        "status": "healthy" if all_healthy else "unhealthy",
        "checks": checks
    }
```

---

*最后更新: 2026年2月15日*
*测试和部署版本: v1.0*
*运维团队: DevOps运维组*
