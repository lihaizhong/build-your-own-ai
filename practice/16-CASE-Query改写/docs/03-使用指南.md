# Query改写系统 - 使用指南

## 环境准备

### 1. 系统要求
- **操作系统**: Windows 10+, macOS 10.15+, Ubuntu 18.04+
- **Python版本**: 3.11+
- **网络**: 需要访问阿里云dashscope API

### 2. 依赖安装

本项目使用根目录的 `pyproject.toml` 管理依赖，无需单独配置环境。

```bash
# 在项目根目录安装依赖
cd build-your-own-ai
uv sync
```

### 3. 环境变量配置

在项目根目录创建 `.env` 文件：

```bash
# 复制环境变量模板
cp .env.example .env

# 编辑 .env 文件，添加 API Key
# DASHSCOPE_API_KEY=your_api_key_here
```

**获取API Key**:
1. 访问 [阿里云DashScope控制台](https://dashscope.console.aliyun.com/)
2. 创建API Key
3. 将Key配置到 `.env` 文件中

## 快速开始

### 1. 运行演示程序

```bash
# 方式一：在项目根目录运行
cd practice/16-CASE-Query改写/code
python main.py

# 方式二：使用uv运行
cd build-your-own-ai
uv run python practice/16-CASE-Query改写/code/main.py
```

### 2. 预期输出

```
============================================================
 Query改写系统演示
 支持5种Query类型：上下文依赖型、对比型、模糊指代型、多意图型、反问型
============================================================

============================================================
 上下文依赖型 Query 改写
============================================================
对话历史：
用户：巴黎是法国的首都，有很多著名景点。
助手：是的，巴黎有埃菲尔铁塔、卢浮宫等著名景点。

原查询：还有其他景点吗？
查询类型：上下文依赖型
改写后：巴黎除了埃菲尔铁塔和卢浮宫，还有哪些著名景点？

============================================================
 对比型 Query 改写
============================================================
原查询：Python和Java哪个更适合做机器学习？
上下文信息：Python和Java都是流行的编程语言...
查询类型：对比型
改写后：Python和Java在机器学习领域的性能、生态系统、学习曲线方面的对比

...
```

## 核心API

### 1. 初始化QueryRewriter

```python
from query_rewriter import QueryRewriter

# 使用默认模型
rewriter = QueryRewriter()

# 指定模型
rewriter = QueryRewriter(model="qwen-turbo-latest")
```

### 2. 自动改写（推荐）

```python
result = rewriter.auto_rewrite_query(
    query="还有其他景点吗？",
    conversation_history="用户：巴黎是法国的首都。\n助手：是的。",
    context_info=""
)

# 返回结果结构
# {
#     "original_query": "还有其他景点吗？",
#     "query_type": "上下文依赖型",
#     "rewritten_query": "巴黎除了埃菲尔铁塔和卢浮宫，还有哪些著名景点？",
#     "sub_queries": []  # 多意图型时会有内容
# }
```

### 3. 参数说明

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `query` | str | 是 | 用户原始查询 |
| `conversation_history` | str | 否 | 对话历史，用于上下文依赖型和模糊指代型改写 |
| `context_info` | str | 否 | 上下文信息，用于对比型改写 |

### 4. 返回结果说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `original_query` | str | 原始查询 |
| `query_type` | str | 识别的查询类型 |
| `rewritten_query` | str | 改写后的查询 |
| `sub_queries` | list | 子查询列表（仅多意图型有内容） |

## 各类型使用示例

### 上下文依赖型示例

```python
rewriter = QueryRewriter()

conversation_history = """
用户：我想学习Python的网络编程。
助手：Python的网络编程主要使用socket、requests、aiohttp等库。
"""

query = "还有其他库吗？"

result = rewriter.auto_rewrite_query(query, conversation_history)
print(f"改写后: {result['rewritten_query']}")
# 输出: Python网络编程除了socket、requests、aiohttp之外，还有哪些常用的库？
```

### 对比型示例

```python
rewriter = QueryRewriter()

query = "React和Vue哪个更好？"
context_info = "React由Facebook开发，Vue由尤雨溪开发，都是流行的前端框架"

result = rewriter.auto_rewrite_query(query, context_info=context_info)
print(f"改写后: {result['rewritten_query']}")
# 输出: React和Vue在性能、学习曲线、生态系统、社区支持方面的对比分析
```

### 模糊指代型示例

```python
rewriter = QueryRewriter()

conversation_history = """
用户：最近在研究BERT模型，它在NLP任务上表现很好。
助手：BERT确实是一个强大的预训练语言模型。
"""

query = "它的主要特点是什么？"

result = rewriter.auto_rewrite_query(query, conversation_history)
print(f"改写后: {result['rewritten_query']}")
# 输出: BERT模型的主要特点是什么？
```

### 多意图型示例

```python
rewriter = QueryRewriter()

query = "什么是RAG？怎么实现？有什么优缺点？"

result = rewriter.auto_rewrite_query(query)

print(f"查询类型: {result['query_type']}")
print("拆分后的子查询:")
for i, sub_query in enumerate(result['sub_queries'], 1):
    print(f"  {i}. {sub_query}")

# 输出:
# 查询类型: 多意图型
# 拆分后的子查询:
#   1. 什么是RAG？
#   2. 怎么实现RAG？
#   3. RAG有什么优缺点？
```

### 反问型示例

```python
rewriter = QueryRewriter()

query = "难道机器学习不需要数学基础吗？"

result = rewriter.auto_rewrite_query(query)
print(f"改写后: {result['rewritten_query']}")
# 输出: 机器学习为什么需要数学基础？
```

### 普通型示例

```python
rewriter = QueryRewriter()

query = "什么是向量数据库？"

result = rewriter.auto_rewrite_query(query)
print(f"查询类型: {result['query_type']}")
print(f"改写后: {result['rewritten_query']}")
# 输出:
# 查询类型: 普通型
# 改写后: 什么是向量数据库？
# (普通型查询无需改写)
```

## 与RAG系统集成

### 1. 基础集成方案

```python
from query_rewriter import QueryRewriter

class EnhancedRAGSystem:
    """增强的RAG系统，集成Query改写"""
    
    def __init__(self):
        self.rewriter = QueryRewriter()
        self.vector_store = VectorStore()  # 你的向量存储
        self.llm = LLM()                  # 你的LLM
    
    def query(self, user_query: str, conversation_history: str = "") -> str:
        """处理用户查询"""
        
        # 1. Query改写
        rewrite_result = self.rewriter.auto_rewrite_query(
            user_query, 
            conversation_history
        )
        
        # 2. 根据改写结果进行检索
        if rewrite_result['sub_queries']:
            # 多意图型：对每个子查询分别检索
            all_docs = []
            for sub_query in rewrite_result['sub_queries']:
                docs = self.vector_store.search(sub_query, top_k=3)
                all_docs.extend(docs)
            retrieved_docs = self._deduplicate(all_docs)
        else:
            # 其他类型：使用改写后的查询检索
            retrieved_docs = self.vector_store.search(
                rewrite_result['rewritten_query'], 
                top_k=5
            )
        
        # 3. 生成回答
        context = self._format_context(retrieved_docs)
        answer = self.llm.generate(user_query, context)
        
        return answer
    
    def _deduplicate(self, docs: list) -> list:
        """去重文档"""
        seen = set()
        unique_docs = []
        for doc in docs:
            if doc['id'] not in seen:
                seen.add(doc['id'])
                unique_docs.append(doc)
        return unique_docs
```

### 2. 完整集成示例

```python
from typing import List, Dict, Any
from query_rewriter import QueryRewriter

class RAGWithQueryRewrite:
    """完整的RAG + Query改写系统集成"""
    
    def __init__(
        self,
        embedding_model,
        vector_store,
        llm,
        rewrite_model: str = "qwen-turbo-latest"
    ):
        self.embedding_model = embedding_model
        self.vector_store = vector_store
        self.llm = llm
        self.rewriter = QueryRewriter(model=rewrite_model)
        
        # 对话历史管理
        self.conversation_history: List[Dict] = []
    
    def chat(self, query: str) -> Dict[str, Any]:
        """处理用户对话"""
        
        # 1. 格式化对话历史
        history_str = self._format_history()
        
        # 2. Query改写
        rewrite_result = self.rewriter.auto_rewrite_query(
            query=query,
            conversation_history=history_str
        )
        
        # 3. 检索相关文档
        retrieved_docs = self._retrieve(rewrite_result)
        
        # 4. 生成回答
        context = self._build_context(retrieved_docs)
        answer = self._generate_answer(query, context)
        
        # 5. 更新对话历史
        self._update_history(query, answer)
        
        return {
            "answer": answer,
            "rewrite_info": rewrite_result,
            "sources": retrieved_docs[:3]  # 返回前3个来源
        }
    
    def _format_history(self) -> str:
        """格式化对话历史"""
        if not self.conversation_history:
            return ""
        
        lines = []
        for turn in self.conversation_history[-5:]:  # 最近5轮对话
            lines.append(f"用户：{turn['user']}")
            lines.append(f"助手：{turn['assistant']}")
        return "\n".join(lines)
    
    def _retrieve(self, rewrite_result: Dict) -> List[Dict]:
        """检索相关文档"""
        docs = []
        
        if rewrite_result['sub_queries']:
            # 多意图型：分别检索
            for sub_query in rewrite_result['sub_queries']:
                sub_docs = self.vector_store.search(sub_query, top_k=3)
                docs.extend(sub_docs)
            # 去重
            docs = self._deduplicate(docs)
        else:
            # 其他类型：使用改写查询检索
            search_query = rewrite_result['rewritten_query']
            docs = self.vector_store.search(search_query, top_k=5)
        
        return docs
    
    def _build_context(self, docs: List[Dict]) -> str:
        """构建上下文"""
        context_parts = []
        for i, doc in enumerate(docs, 1):
            context_parts.append(f"[文档{i}] {doc['content']}")
        return "\n\n".join(context_parts)
    
    def _generate_answer(self, query: str, context: str) -> str:
        """生成回答"""
        prompt = f"""基于以下上下文回答用户问题。

上下文：
{context}

用户问题：{query}

请给出准确、详细的回答："""
        
        return self.llm.generate(prompt)
    
    def _update_history(self, query: str, answer: str):
        """更新对话历史"""
        self.conversation_history.append({
            "user": query,
            "assistant": answer
        })
    
    def _deduplicate(self, docs: List[Dict]) -> List[Dict]:
        """去重"""
        seen = set()
        unique = []
        for doc in docs:
            doc_id = doc.get('id', doc.get('content', '')[:50])
            if doc_id not in seen:
                seen.add(doc_id)
                unique.append(doc)
        return unique
    
    def clear_history(self):
        """清空对话历史"""
        self.conversation_history = []
```

### 3. 使用集成系统

```python
# 初始化
rag = RAGWithQueryRewrite(
    embedding_model=your_embedding_model,
    vector_store=your_vector_store,
    llm=your_llm
)

# 对话
response = rag.chat("什么是RAG？")
print(response['answer'])

# 后续对话（带上下文）
response = rag.chat("它有什么优点？")  # 自动识别模糊指代
print(response['answer'])
# 系统会将"它"改写为"RAG"

# 多意图查询
response = rag.chat("什么是向量数据库？如何选择？有什么优缺点？")
print(response['answer'])
# 系统会拆分为3个子查询分别检索
```

## 最佳实践

### 1. 对话历史管理

```python
# 推荐：维护有限长度的对话历史
MAX_HISTORY_TURNS = 5

def manage_history(history: list, new_turn: dict) -> list:
    """管理对话历史长度"""
    history.append(new_turn)
    if len(history) > MAX_HISTORY_TURNS:
        history = history[-MAX_HISTORY_TURNS:]
    return history
```

### 2. 错误处理

```python
def safe_rewrite(rewriter, query: str, history: str = "") -> dict:
    """安全的Query改写"""
    try:
        result = rewriter.auto_rewrite_query(query, history)
        if not result['rewritten_query']:
            # 改写失败，使用原查询
            result['rewritten_query'] = query
        return result
    except Exception as e:
        logger.error(f"Query改写失败: {e}")
        return {
            "original_query": query,
            "query_type": "普通型",
            "rewritten_query": query,
            "sub_queries": []
        }
```

### 3. 性能优化

```python
# 缓存常见查询的改写结果
from functools import lru_cache

class CachedQueryRewriter(QueryRewriter):
    """带缓存的Query改写器"""
    
    @lru_cache(maxsize=1000)
    def _cached_identify(self, query: str) -> str:
        """缓存的类型识别"""
        return self.identify_query_type(query).value
```

### 4. 日志记录

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def log_rewrite_result(result: dict):
    """记录改写结果"""
    logger.info(f"""
    Query改写完成:
    - 原查询: {result['original_query']}
    - 类型: {result['query_type']}
    - 改写后: {result['rewritten_query']}
    - 子查询数: {len(result['sub_queries'])}
    """)
```

### 5. 批量处理

```python
def batch_rewrite(rewriter: QueryRewriter, queries: list[str]) -> list[dict]:
    """批量改写查询"""
    results = []
    for query in queries:
        result = rewriter.auto_rewrite_query(query)
        results.append(result)
    return results
```

## 常见问题解决

### 1. API Key未配置

```
错误: DASHSCOPE_API_KEY未设置，请检查环境变量
```

**解决方案**:
```bash
# 检查环境变量
echo $DASHSCOPE_API_KEY

# 或在代码中设置
import os
os.environ['DASHSCOPE_API_KEY'] = 'your_api_key'
```

### 2. 改写效果不佳

**问题**: LLM改写结果不符合预期

**解决方案**:
```python
# 尝试使用更强的模型
rewriter = QueryRewriter(model="qwen-max")

# 或调整Prompt（需要修改源码）
```

### 3. 响应速度慢

**问题**: LLM调用耗时较长

**解决方案**:
```python
# 使用缓存
from functools import lru_cache

# 使用更快的模型
rewriter = QueryRewriter(model="qwen-turbo")

# 异步处理
import asyncio
async def async_rewrite(rewriter, query):
    # 实现异步改写
    pass
```

---

*最后更新: 2026年2月15日*
*使用指南版本: v1.0*
*技术支持: build-your-own-ai项目团队*
