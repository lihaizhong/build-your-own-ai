# 大模型原理与API使用 - 代码实现详解

## 核心代码结构

### 1. 项目文件概览

```
code/
├── 1-情感分析-Qwen.py              # 基础API调用
├── 2-天气Function-Qwen.py          # Function Calling
├── 3-表格提取-Qwen.py              # 多模态调用
├── 4-运维事件处置-Qwen.py          # 多轮工具调用
├── 5-情感分析-Deepseek-阿里代理.py  # DeepSeek模型
├── 6-联网搜索.py                   # 联网搜索
└── 陪伴机器人.py                   # 情感陪伴应用
```

### 2. 代码模式分类

| 模式 | 文件 | 难度 | 核心技术 |
|------|------|------|----------|
| 基础调用 | 1, 5 | ⭐ | 单次API调用 |
| Function Calling | 2 | ⭐⭐ | 函数定义、二次调用 |
| 多模态 | 3 | ⭐⭐⭐ | 图像+文本处理 |
| 多轮调用 | 4, 7 | ⭐⭐⭐ | 工具调用循环 |
| 特殊功能 | 6 | ⭐⭐ | 联网搜索 |

## 情感分析实现

### 1. 基础情感分析 (1-情感分析-Qwen.py)

#### 完整代码解析
```python
"""
情感分析示例 - 使用DeepSeek模型

功能：对用户评论进行情感分析，判断正面或负面情感
"""

import os
from dotenv import load_dotenv
import dashscope
from dashscope import Generation

# 1. 加载环境变量
load_dotenv()

# 2. 配置API密钥
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# 3. 定义API调用函数
def get_response(messages):
    """
    统一的API调用封装
    
    Args:
        messages: 消息列表
        
    Returns:
        API响应对象
    """
    response = Generation.call(
        model="deepseek-v3",
        messages=messages,
        result_format="message"
    )
    return response

# 4. 主函数
def main():
    """主函数"""
    print("=" * 80)
    print("情感分析示例 - 使用DeepSeek模型")
    print("=" * 80)
    
    # 系统提示词
    system_prompt = """你是一个情感分析助手。
请判断用户评论的情感倾向，只回复"正向"、"负向"或"中性"，不要有其他内容。"""
    
    # 测试评论
    comments = [
        "这个产品质量很好，性价比很高，非常满意！",
        "服务态度很差，不会再来了",
        "还行吧，没什么特别的"
    ]
    
    for comment in comments:
        print(f"\n用户评论: {comment}")
        
        # 构建消息
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": comment}
        ]
        
        # 调用API
        response = get_response(messages)
        
        # 输出结果
        print(f"回复: {response.output.choices[0].message.content}")
    
    print("\n" + "=" * 80)
    print("分析完成")
    print("=" * 80)

if __name__ == "__main__":
    main()
```

#### 关键设计点
- **环境变量管理**: 使用python-dotenv加载API密钥
- **统一封装**: get_response函数封装API调用
- **消息格式**: 标准的system-user消息结构

### 2. DeepSeek调用 (5-情感分析-Deepseek-阿里代理.py)

#### 代码差异
```python
# 使用DeepSeek模型
response = Generation.call(
    model="deepseek-r1",  # 使用r1模型
    messages=messages,
    result_format="message"
)

# DeepSeek-r1的特殊输出
# 包含思维链(reasoning_content)和最终回答(content)
message = response.output.choices[0].message
if hasattr(message, 'reasoning_content'):
    print(f"思考过程: {message.reasoning_content}")
print(f"最终回答: {message.content}")
```

## Function Calling实现

### 天气查询示例 (2-天气Function-Qwen.py)

#### 完整代码解析
```python
"""
天气查询示例 - Function Calling

功能：通过Function Calling调用高德API获取实时天气
"""

import os
import json
import requests
from dotenv import load_dotenv
import dashscope
from dashscope import Generation

# 加载环境变量
load_dotenv()
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")
AMAP_API_KEY = os.getenv("AMAP_API_KEY")

# 定义函数描述
functions = [{
    "name": "get_current_weather",
    "description": "获取指定地区的当前天气状况",
    "parameters": {
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "城市名称，如：北京、上海"
            }
        },
        "required": ["location"]
    }
}]

def get_current_weather(location: str) -> dict:
    """
    调用高德API获取天气信息
    
    Args:
        location: 城市名称
        
    Returns:
        天气信息字典
    """
    url = "https://restapi.amap.com/v3/weather/weatherInfo"
    params = {
        "city": location,
        "key": AMAP_API_KEY,
        "extensions": "base"
    }
    
    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        return {"error": str(e)}

def get_response(messages, functions=None):
    """API调用封装"""
    kwargs = {
        "model": "qwen-max",
        "messages": messages,
        "result_format": "message"
    }
    if functions:
        kwargs["functions"] = functions
    
    return Generation.call(**kwargs)

def main():
    """主函数"""
    print("=" * 80)
    print("天气查询示例 - Function Calling")
    print("=" * 80)
    
    user_query = "北京今天天气怎么样？"
    print(f"\n用户: {user_query}")
    
    # 初始消息
    messages = [
        {"role": "user", "content": user_query}
    ]
    
    # 第一次调用 - 模型决定是否调用函数
    print("\n[模型决定是否调用函数]")
    response = get_response(messages, functions=functions)
    message = response.output.choices[0].message
    
    # 检查是否需要调用函数
    if message.function_call:
        function_name = message.function_call.name
        arguments = json.loads(message.function_call.arguments)
        
        print(f"函数名: {function_name}")
        print(f"参数: {arguments}")
        
        # 执行函数
        print("\n[执行函数]")
        if function_name == "get_current_weather":
            result = get_current_weather(arguments["location"])
            print(f"调用高德API获取{arguments['location']}天气...")
        
        # 添加函数调用记录
        messages.append({
            "role": "assistant",
            "content": "",
            "function_call": {
                "name": function_name,
                "arguments": message.function_call.arguments
            }
        })
        
        # 添加函数结果
        messages.append({
            "role": "function",
            "name": function_name,
            "content": json.dumps(result, ensure_ascii=False)
        })
        
        # 第二次调用 - 整合结果
        print("\n[整合结果]")
        response = get_response(messages)
        final_message = response.output.choices[0].message
        
        print(f"\n回复: {final_message.content}")
    else:
        # 不需要调用函数，直接回复
        print(f"\n回复: {message.content}")
    
    print("\n" + "=" * 80)
    print("查询完成")
    print("=" * 80)

if __name__ == "__main__":
    main()
```

#### Function Calling流程图
```
用户问题
    │
    ▼
┌─────────────────┐
│ 第一次API调用    │
│ (带functions参数)│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 模型判断是否     │
│ 需要调用函数     │
└────────┬────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
 不需要      需要
    │         │
    │         ▼
    │    ┌─────────────────┐
    │    │ 提取function_call│
    │    │ 执行对应函数      │
    │    └────────┬────────┘
    │             │
    │             ▼
    │    ┌─────────────────┐
    │    │ 第二次API调用    │
    │    │ (带函数结果)     │
    │    └────────┬────────┘
    │             │
    └──────┬──────┘
           │
           ▼
      返回最终回复
```

## 表格提取实现

### 多模态调用 (3-表格提取-Qwen.py)

#### 完整代码解析
```python
"""
表格提取示例 - 多模态调用

功能：使用视觉大模型从图片中提取表格数据
"""

import os
from dotenv import load_dotenv
import dashscope
from dashscope import MultiModalConversation

# 加载环境变量
load_dotenv()
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

def extract_table_from_image(image_url: str) -> str:
    """
    从图片中提取表格数据
    
    Args:
        image_url: 图片URL或本地路径
        
    Returns:
        提取的表格数据（JSON格式）
    """
    messages = [
        {
            "role": "user",
            "content": [
                {"image": image_url},
                {"text": "请提取图片中的表格数据，以JSON格式输出。保持表格结构，字段名使用原文。"}
            ]
        }
    ]
    
    response = MultiModalConversation.call(
        model="qwen-vl-plus",
        messages=messages
    )
    
    return response.output.choices[0].message.content

def main():
    """主函数"""
    print("=" * 80)
    print("表格提取示例 - 多模态调用")
    print("=" * 80)
    
    # 示例图片URL
    image_url = "https://example.com/table.png"
    
    print(f"\n处理图片: {image_url}")
    print("\n提取结果:")
    
    result = extract_table_from_image(image_url)
    print(result)
    
    print("\n" + "=" * 80)
    print("提取完成")
    print("=" * 80)

if __name__ == "__main__":
    main()
```

#### 多模态消息格式
```python
# 多模态消息结构
message = {
    "role": "user",
    "content": [
        {"image": "图片URL或Base64"},
        {"text": "文本提示"}
    ]
}

# 支持的图片格式
# - URL: "https://example.com/image.jpg"
# - 本地文件: "file:///path/to/image.jpg"
# - Base64: "data:image/jpeg;base64,/9j/4AAQ..."
```

## 运维事件处置实现

### 多轮工具调用 (4-运维事件处置-Qwen.py)

#### 完整代码解析
```python
"""
运维事件处置示例 - 多轮工具调用

功能：模拟运维场景，通过多轮工具调用处理告警事件
"""

import os
import json
from dotenv import load_dotenv
import dashscope
from dashscope import Generation

# 加载环境变量
load_dotenv()
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# 定义工具
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_status",
            "description": "调用监控系统接口，获取当前数据库服务器性能指标",
            "parameters": {},
            "required": []
        }
    },
    {
        "type": "function",
        "function": {
            "name": "get_slow_queries",
            "description": "获取慢查询日志",
            "parameters": {
                "type": "object",
                "properties": {
                    "limit": {
                        "type": "integer",
                        "description": "返回的慢查询数量"
                    }
                },
                "required": ["limit"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "restart_service",
            "description": "重启指定服务",
            "parameters": {
                "type": "object",
                "properties": {
                    "service_name": {
                        "type": "string",
                        "description": "服务名称"
                    }
                },
                "required": ["service_name"]
            }
        }
    }
]

def get_current_status() -> dict:
    """模拟获取系统状态"""
    return {
        "cpu_usage": 85,
        "memory_usage": 78,
        "disk_usage": 65,
        "active_connections": 150,
        "status": "warning"
    }

def get_slow_queries(limit: int) -> list:
    """模拟获取慢查询"""
    return [
        {"query": "SELECT * FROM orders WHERE...", "duration": 5.2},
        {"query": "UPDATE products SET...", "duration": 3.8}
    ][:limit]

def restart_service(service_name: str) -> dict:
    """模拟重启服务"""
    return {"status": "success", "message": f"服务 {service_name} 已重启"}

def execute_tool(tool_name: str, arguments: dict):
    """执行工具函数"""
    tools_map = {
        "get_current_status": get_current_status,
        "get_slow_queries": get_slow_queries,
        "restart_service": restart_service
    }
    
    if tool_name in tools_map:
        return tools_map[tool_name](**arguments)
    return {"error": f"未知工具: {tool_name}"}

def get_response(messages):
    """API调用封装"""
    return Generation.call(
        model="qwen-turbo",
        messages=messages,
        tools=tools,
        result_format="message"
    )

def main():
    """主函数 - 多轮工具调用"""
    print("=" * 80)
    print("运维事件处置示例 - 多轮工具调用")
    print("=" * 80)
    
    # 初始告警
    alert_message = "收到告警：数据库服务器CPU使用率过高，请检查并处理。"
    print(f"\n告警: {alert_message}")
    
    # 初始消息
    messages = [
        {"role": "system", "content": "你是一个运维助手，帮助处理系统告警。"},
        {"role": "user", "content": alert_message}
    ]
    
    # 工具调用循环
    iteration = 0
    while True:
        iteration += 1
        print(f"\n--- 第 {iteration} 轮调用 ---")
        
        response = get_response(messages)
        message = response.output.choices[0].message
        
        # 添加助手消息
        messages.append(message.to_dict())
        
        finish_reason = response.output.choices[0].finish_reason
        
        if finish_reason == 'stop':
            # 生成最终回复
            print(f"\n最终回复: {message.content}")
            break
        
        # 处理工具调用
        if hasattr(message, 'tool_calls') and message.tool_calls:
            for tool_call in message.tool_calls:
                tool_name = tool_call['function']['name']
                arguments = json.loads(tool_call['function']['arguments'])
                
                print(f"调用工具: {tool_name}")
                print(f"参数: {arguments}")
                
                # 执行工具
                result = execute_tool(tool_name, arguments)
                print(f"结果: {result}")
                
                # 添加工具响应
                messages.append({
                    "role": "tool",
                    "content": json.dumps(result, ensure_ascii=False),
                    "name": tool_name,
                    "tool_call_id": tool_call['id']
                })
    
    print("\n" + "=" * 80)
    print("处置完成")
    print("=" * 80)

if __name__ == "__main__":
    main()
```

#### 多轮调用流程图
```
告警信息
    │
    ▼
┌─────────────────┐
│ 第1轮API调用     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 模型返回tool_calls│
│ (get_current_status)│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 执行工具函数      │
│ 返回系统状态      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 第2轮API调用     │
│ (带工具结果)      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 模型返回tool_calls│
│ (get_slow_queries)│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 执行工具函数      │
│ 返回慢查询日志    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 第3轮API调用     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ finish_reason=stop│
│ 返回最终分析报告  │
└─────────────────┘
```

## 陪伴机器人实现

### 情感陪伴应用 (陪伴机器人.py)

#### 完整代码解析
```python
"""
情感陪伴机器人

功能：智能情感陪伴，结合时间和上下文进行对话
"""

import os
from datetime import datetime
import pytz
from dotenv import load_dotenv
import dashscope
from dashscope import Generation

# 加载环境变量
load_dotenv()
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

def get_time_greeting() -> str:
    """根据时间返回问候语"""
    tz = pytz.timezone('Asia/Shanghai')
    hour = datetime.now(tz).hour
    
    if 5 <= hour < 12:
        return "早上好"
    elif 12 <= hour < 14:
        return "中午好"
    elif 14 <= hour < 18:
        return "下午好"
    else:
        return "晚上好"

def get_response(messages):
    """API调用封装"""
    return Generation.call(
        model="qwen-turbo",
        messages=messages,
        result_format="message"
    )

def main():
    """主函数"""
    print("=" * 80)
    print("情感陪伴机器人")
    print("=" * 80)
    
    # 时间问候
    greeting = get_time_greeting()
    
    # 初始化对话
    messages = [
        {
            "role": "system",
            "content": f"""你是一个温暖、善解人意的陪伴机器人。
{greeting}！你的任务是：
1. 倾听用户的感受
2. 给予情感支持和鼓励
3. 提供积极的建议
4. 保持耐心和友善

请用温柔、理解的语气回应用户。"""
        }
    ]
    
    # 初始问候
    response = get_response(messages)
    assistant_message = response.output.choices[0].message.content
    messages.append({"role": "assistant", "content": assistant_message})
    
    print(f"\n机器人: {assistant_message}")
    
    # 对话循环
    while True:
        user_input = input("\n用户: ")
        
        if user_input.lower() in ['退出', 'bye', 'exit', '再见']:
            print("\n机器人: 再见！希望今天对你来说是美好的一天！")
            break
        
        messages.append({"role": "user", "content": user_input})
        
        response = get_response(messages)
        assistant_message = response.output.choices[0].message.content
        messages.append({"role": "assistant", "content": assistant_message})
        
        print(f"\n机器人: {assistant_message}")
    
    print("\n" + "=" * 80)
    print("对话结束")
    print("=" * 80)

if __name__ == "__main__":
    main()
```

## 代码模式总结

### 1. API调用封装模式

```python
# 统一的API调用封装
def get_response(messages, **kwargs):
    """统一的API调用接口"""
    default_kwargs = {
        "model": "qwen-turbo",
        "messages": messages,
        "result_format": "message"
    }
    default_kwargs.update(kwargs)
    return Generation.call(**default_kwargs)
```

### 2. 消息构建模式

```python
# 标准消息结构
messages = [
    {"role": "system", "content": "系统提示词"},
    {"role": "user", "content": "用户消息"},
    {"role": "assistant", "content": "助手回复"}
]

# 多模态消息
messages = [{
    "role": "user",
    "content": [
        {"image": "图片URL"},
        {"text": "文本内容"}
    ]
}]
```

### 3. 工具定义模式

```python
# Function Calling格式
functions = [{
    "name": "function_name",
    "description": "函数描述",
    "parameters": {
        "type": "object",
        "properties": {
            "param1": {"type": "string", "description": "参数描述"}
        },
        "required": ["param1"]
    }
}]

# Tool Calling格式（新版）
tools = [{
    "type": "function",
    "function": {
        "name": "function_name",
        "description": "函数描述",
        "parameters": {...}
    }
}]
```

### 4. 错误处理模式

```python
def safe_call(messages, max_retries=3):
    """安全的API调用"""
    for attempt in range(max_retries):
        try:
            response = get_response(messages)
            if response.status_code == 200:
                return response
            else:
                print(f"API返回错误: {response.message}")
        except Exception as e:
            print(f"调用失败: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)
    
    raise Exception("API调用失败")
```

---

*最后更新: 2026年2月21日*
*代码实现版本: v1.0*
*开发团队: AI系统开发组*
